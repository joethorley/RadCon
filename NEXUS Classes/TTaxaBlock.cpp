#include "TTaxaBlock.h"#include "TTabString.h"// JLT 000624#include "wstream.h"extern ostream *logStream;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TTaxaBlock::AddLeaf (const TString& name, const unsigned int leaf){	CHECK_ (!IsLeaf (name));	CHECK_ (leaf && leaf <= kMaxLeaves);	CHECK_ (!IsLeaf (leaf));	fLeafSet += leaf;	TLeafName* leafName = new TLeafName (name, leaf);	fArray[leaf - 1] = leafName;	fBTree.AddItem (leafName);}void TTaxaBlock::AddLeaves (const TTaxaBlock& taxaBlock){	for (unsigned int leafNumber = taxaBlock.FirstLeaf (); leafNumber; leafNumber = taxaBlock.NextLeaf ())	{		TString leafName = taxaBlock.GetLeafName (leafNumber);		if (!IsLeaf (leafName))			AddLeaf (leafName);	}}void TTaxaBlock::Copy (const TObject& obj){	CHECK_ (Class () == obj.Class ());	const TTaxaBlock& taxaBlock = (const TTaxaBlock&)obj;	fBTree.Copy (taxaBlock.fBTree);	fLeafSet.Copy (taxaBlock.fLeafSet);	for (fLeafSet.FirstLeaf (); fLeafSet.CurLeaf (); fLeafSet.NextLeaf ())	{		const TLeafName leafName (taxaBlock.GetLeafName (fLeafSet.CurLeaf ())); // JLT 010412 made const		TLeafName* item = NULL;		fBTree.FindItem ((const TObject&)leafName, (TObject*&)item);		fArray[fLeafSet.CurLeaf () - 1] = item; // JLT 010412	}}void TTaxaBlock::Clear (void){	fLeafSet.SetEmpty ();	fBTree.DeleteAll ();	fArray.Fill (NULL);}								bool TTaxaBlock::IsEqual (const TObject& obj) const{	CHECK (Class () == obj.Class ());	const TTaxaBlock& taxaBlock = (const TTaxaBlock&)obj;		if (fLeafSet.IsEqual (taxaBlock.fLeafSet))	{		for (fLeafSet.FirstLeaf (); fLeafSet.CurLeaf (); fLeafSet.NextLeaf ())			if (GetLeafName (fLeafSet.CurLeaf ()) != taxaBlock.GetLeafName (fLeafSet.CurLeaf ()))				return (false);		return (true);	}	return (false);}bool TTaxaBlock::IsEqual (const TTaxaBlock& taxaBlock, const TLeafSet& leafSet) const{	CHECK_ (leafSet.IsSubset (GetLeafSet ()) && leafSet.IsSubset (taxaBlock.GetLeafSet ()));		for (leafSet.FirstLeaf (); leafSet.CurLeaf (); leafSet.NextLeaf ())		if (GetLeafName (leafSet.CurLeaf ()) != taxaBlock.GetLeafName (leafSet.CurLeaf ()))			return (false);	return (true);}bool TTaxaBlock::IsLeaf (const TString& leafName) const{	TLeafName toFind (leafName);	return (fBTree.FindItem (toFind));}void TTaxaBlock::InsertLeaf (const TString& leafName, const unsigned int leaf){	CHECK (!IsLeaf (leafName));		if (IsLeaf (leaf))	{		TString name = GetLeafName (leaf);				unsigned int leaves = fBTree.GetItems ();				PruneLeaf (leaf);				CHECK_ (leaves == fBTree.GetItems () + 1);		InsertLeaf (name, leaf + 1);	}	AddLeaf (leafName, leaf);}const TString& TTaxaBlock::GetLeafName (const unsigned int leafNumber) const{	if (IsLeaf (leafNumber))		return (((TTaxaBlock*)this)->fString = *(fArray[leafNumber-1]));	else		((TTaxaBlock*)this)->fString.SetNull ();	return (fString);}unsigned int TTaxaBlock::GetLeafNumber (const TString& leafName) const{	const TLeafName toFind (leafName);	const TLeafName* item = NULL;	if (fBTree.FindItem ((const TObject&)toFind, (const TObject*&)item)) // JLT 010412 added casts		return (item->GetNumber ());	return (0);}// this function returns the size of the union of the two sets of leavesunsigned int TTaxaBlock::GetUnionLeaves (const TTaxaBlock& taxaBlock) const{	unsigned int leaves = GetLeaves ();		for (unsigned int leaf = taxaBlock.FirstLeaf (); leaf; leaf = taxaBlock.NextLeaf ())		if (!IsLeaf (taxaBlock.GetLeafName (leaf)))			++leaves;	return (leaves);}TTaxaBlock& TTaxaBlock::operator = (const TTaxaBlock& taxaBlock){	fBTree = taxaBlock.fBTree;	fLeafSet = taxaBlock.fLeafSet;	for (fLeafSet.FirstLeaf (); fLeafSet.CurLeaf (); fLeafSet.NextLeaf ())	{		const TLeafName leafName (taxaBlock.GetLeafName (fLeafSet.CurLeaf ()));		TLeafName* item = NULL;		fBTree.FindItem ((const TObject&)leafName, (TObject*&)item); // JLT 010412 added casts		fArray[fLeafSet.CurLeaf () - 1] = item;	}	return (*this);}void TTaxaBlock::PruneLeaf (const unsigned int leaf){	CHECK_ (IsLeaf (leaf));	TLeafName leafName (GetLeafName (leaf));	fBTree.DeleteItem (leafName);	fArray[leaf - 1] = NULL;	fLeafSet -= leaf;}void TTaxaBlock::MapLeaves (const TLeafMap& leafMap){	CHECK_ (leafMap.GetLeafSet ().IsSubset (GetLeafSet ()));		TTaxaBlock taxaBlock (*this);	Clear ();		unsigned int leaf;	for (taxaBlock.FirstLeaf (); (leaf = taxaBlock.CurLeaf ()) != 0; taxaBlock.NextLeaf ())	{		CHECK_ (!IsLeaf (leafMap.GetMapping (leaf)) && taxaBlock.IsLeaf (leaf));		TString leafName = taxaBlock.GetLeafName (leaf);		AddLeaf (leafName, leafMap.GetMapping (leaf)); //changed from InsertLeaf ()	}}void TTaxaBlock::PruneLeaves (const TLeafSet& leafSet){	CHECK_ (leafSet.IsSubset (fLeafSet));	for (leafSet.FirstLeaf (); leafSet.CurLeaf (); leafSet.NextLeaf ())		PruneLeaf (leafSet.CurLeaf ());}TTaxaBlock::TTaxaBlock (void)	: fArray (10, 10){}TTaxaBlock::TTaxaBlock (const TTaxaBlock& taxaBlock)	: fBTree (taxaBlock.fBTree)	, fLeafSet (taxaBlock.fLeafSet)	, fArray (10, 10){	for (fLeafSet.FirstLeaf (); fLeafSet.CurLeaf (); fLeafSet.NextLeaf ())	{		const TLeafName leafName (taxaBlock.GetLeafName (fLeafSet.CurLeaf ()));		TLeafName* item = NULL;		fBTree.FindItem ((const TObject&)leafName, (TObject*&)item);		fArray[fLeafSet.CurLeaf () - 1] = item;	}}ostream& TTaxaBlock::Write (ostream &o, const TLeafSet& leafSet) const{	CHECK_ (fLeafSet.IsSuperset (leafSet));		o << "begin taxa;" << EOLN;	o << "dimensions ntax = " << leafSet.GetLeaves () << ";" << EOLN;	o << "taxlabels";	int characterNumber = 9;	int length = 0;	for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())	{		TLeafName leafName = GetLeafName (leaf);		if (characterNumber + leafName.Length () + 1 + (leafName.IsQuoted () ? 2 : 0) > kFileWidth)		{			o << EOLN;			characterNumber = 0;		}		o << ' ';		++characterNumber;		leafName.WriteQuoted (o);		characterNumber += leafName.Length() + (leafName.IsQuoted () ? 2 : 0) ;	}	if (characterNumber == kFileWidth)		o << EOLN <<"\t\t";	o << ";" << EOLN;	return (o << "end;");}ostream& TTaxaBlock::WriteAsNexus (ostream &o, const TLeafSet& leafSet) const{	CHECK_ (fLeafSet.IsSuperset (leafSet));		o << EOLN;	o << "begin taxa;" << EOLN;	o << "\tdimensions ntax = " << leafSet.GetLeaves () << ";" << EOLN;	o << "\ttaxlabels" << EOLN;		for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())	{		TLeafName leafName = GetLeafName (leaf);		o << "\t\t";		leafName.WriteQuoted (o);		o << EOLN;	}	o << "\t;" << EOLN;	o << "end;" << EOLN;	return (o);}ostream& TTaxaBlock::WriteCharacters (ostream& o, const TLeafSet& leafSet) const{	CHECK_ (fLeafSet.IsSuperset (leafSet));		o << EOLN;	o << "begin characters;" << EOLN;	o << "\tdimensions nchar = 1;" << EOLN;	o << "\tmatrix" << EOLN;		for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())	{		TLeafName leafName = GetLeafName (leaf);		o << "\t\t";		leafName.WriteQuoted (o);		o << "\t\t\t";		o << " 1";		o << EOLN;	}	o << "\t;" << EOLN;	o << "end;" << EOLN;	return (o);}ostream& TTaxaBlock::WriteAsList (ostream& o, const TLeafSet& leafSet) const{	CHECK_ (fLeafSet.IsSuperset (leafSet));		TTabString tabString (kFileWidth);	tabString.SetTab (5);		o << "Leaves:" << EOLN;		TString string;	for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())	{		string.AddToThis ((int)leaf);		string.AddToThis (')');		tabString.AddToThis (string);				tabString.AddToken (GetLeafName (leaf));		tabString.SetNewLine ();		tabString.Write (o);		tabString.SetNull ();		string.SetNull ();	}	return (o);} // JLT 000303#include "wstream.h"extern ostream *logStream;void TTaxaBlock::WriteToLogAsList (const TLeafSet& leafSet) const{	#ifdef VCLASS		WriteAsList (*logStream, leafSet);		logStream->flush();	#else		Write (cout);	#endif}TTaxaBlock::~TTaxaBlock (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif