// Functions which read in Nexus tokens taken from NEXUS home page// Copyright © 1997, David R. Maddison, David L. Swofford, and Wayne P. Maddison //	C++ Translation//	Copyright (c) 1998, Joseph L. Thorley. All rights reserved.#include "TReadNexusToken.h"TReadNexusToken::TReadNexusToken (void)	: fCurToken(10,10){		fCurFileChar = ' ';}// after this function, CurrentFilePosition will be one text character past the tokenTString& TReadNexusToken::nextToken (void){		fCurToken = "";	while (Nexus::IsWhiteSpaceCharacter (nonCommentFileCharacter()))			// skip along to next dark character that is not a comment		nextFileCharacter(); 	 	if (nonCommentFileCharacter() == '\'') //let's see what the first character of the token is 	{	// the first dark character is a single quote  // note that in this section we ignore [ and ], as they are not special within a quoted token 		do{ 			do{				nextFileCharacter();				if(fCurFileChar != '\'')					fCurToken.AddToThis (fCurFileChar); 			} while(fCurFileChar != '\''); // we may have found the last single quote 			nextFileCharacter(); 			if(fCurFileChar=='\'') 			{	// we aren't at the end of the token. // Instead we have found two single quotes //in a row inside the token 				fCurToken.AddToThis (fCurFileChar);	// we need to add just one of the quotes		 			} 		} while(fCurFileChar == '\'' ); // we skip out only if we HAVEN'T found the second of two quotes 	} 	else if (Nexus::IsPunctuationCharacter (nonCommentFileCharacter ())) // this reads in the '@' from [@ ] subsequently get token until ']' 	{ // the token is punctuation 		fCurToken.AddToThis (nonCommentFileCharacter ()); 		nextFileCharacter(); 	} 	else if (nonCommentFileCharacter () == '!') // OutputComment 	{ 		do{ 				fCurToken.AddToThis (nonCommentFileCharacter ()); 				nextFileCharacter (); 		} while (nonCommentFileCharacter () != ']'); 		nextFileCharacter (); 	} 	else	// we have a normal unquoted NEXUS word 	{	 		while (!Nexus::IsWhiteSpaceCharacter (nonCommentFileCharacter()) && !Nexus::IsPunctuationCharacter(nonCommentFileCharacter())) 		{ 			fCurToken.AddToThis (nonCommentFileCharacter ()); 			nextFileCharacter(); 		} 	} 	return (fCurToken); }// this procedures returns CurrentFileCharacter, unless// CurrentFileCharacter is the start of a comment, in which case// it skips over the comment and returns the first CurrentFileCharacter after commentchar TReadNexusToken::nonCommentFileCharacter (void){	while (fCurFileChar=='[')	{		if ((isReadCommandComments () && peekNextFileCharacter () == '&') || (isReadOutputComments () && peekNextFileCharacter () == '!'))			nextFileCharacter ();		else			skipComment ();	}	return (fCurFileChar);}void TReadNexusToken::skipBlock (void){	do {		skipToSemicolon();	} while (nextToken().ToUpper() != "END"  && fCurToken != "ENDBLOCK");}void TReadNexusToken::skipComment (void){	do 	{ 		nextFileCharacter();  		if(fCurFileChar == '[') 			skipComment();  	} while (fCurFileChar!=']'); 	nextFileCharacter();}// this procedure skips through the file until the semicolon// at the end of the current command is encounteredvoid TReadNexusToken::skipToSemicolon (void){	while (nextToken () != ";")  		;}