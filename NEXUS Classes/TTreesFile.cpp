#include "TTreesFile.h"#include "DialogIDs.h"// JLT 000624#include "wstream.h"extern ostream *logStream;extern BOOL gAborted;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TTreesFile::Copy (const TObject& obj) { 	CHECK_ (Class () == obj.Class ()); 	const TTreesFile& treesFile = (const TTreesFile&)obj;		fTaxaBlock->Copy (*treesFile.fTaxaBlock);	fTreesBlock->Copy (*treesFile.fTreesBlock);}bool TTreesFile::IsEqual (const TObject& obj) const { 	CHECK_ (Class () == obj.Class ()); 	const TTreesFile& treesFile = (const TTreesFile&)obj;	return (fTaxaBlock->IsEqual (*treesFile.fTaxaBlock) && fTreesBlock->IsEqual (*treesFile.fTreesBlock));}bool TTreesFile::GetIthTree (const unsigned int i, TTree& tree, const bool label, const bool selected) const{	if (fTreesBlock->GetIthTree (i, tree, selected))	{		if (label)			tree.LabelLeaves (*fTaxaBlock);		return (true);	}	return (false);}unsigned int TTreesFile::GetLeafNumber (const char* name) const{	TString string = name;	return (fTaxaBlock->GetLeafNumber (name));}void TTreesFile::MapLeaves (const TLeafMap leafMap){	CHECK_ (fTaxaBlock->GetLeafSet () == leafMap.GetLeafSet ());	CHECK_ (GetLeafSet (false, false) == leafMap.GetLeafSet ());		fTaxaBlock->MapLeaves (leafMap);	fTreesBlock->MapLeaves (leafMap);	CHECK_ (fTaxaBlock->GetLeafSet () == GetLeafSet (false, false));}unsigned int TTreesFile::SaveTrees (ostream& o, const bool characters, const bool selected) const{	CHECK (Trees (selected));	const TLeafSet leafSet = GetLeafSet (true, selected);	o << "#NEXUS" << EOLN << EOLN;		fTaxaBlock->Write (o, leafSet) << EOLN << EOLN;		if (characters)		fTaxaBlock->WriteCharacters (o, leafSet) << EOLN << EOLN;		o << "begin trees;" << EOLN;	TTree tree;	unsigned int i = 0;	MonitorDialog = TheApp->CreateMonitor (dlgProgressBar);	MonitorDialog->SetItemText (4, "Saving Trees");	MonitorDialog->SetMeter (GetTrees (selected));	MonitorDialog->Show ();		unsigned int defaultTree = GetItemSet ().NumberOfItem (GetCurTreeNumber ());	if (!defaultTree)		defaultTree = 1;			while (GetIthTree (++i, tree, true, selected))	{		o << (IsRooted () ? "tree " : "utree ");		if (i == defaultTree)			o << "*";		tree.GetName ().WriteQuoted (o);			o << " = ";		o << (IsRooted () ? "[&R] " : "[&U] ");		if (IsSourceTrees ())			o << "[&W " << tree.GetWeight () << "] ";		o << EOLN; 		tree.WriteAsNewickTreeDescription (o, kFileWidth);		o << EOLN;			MonitorDialog->UpdateMeter (i);				MonitorDialog->ProcessExternal ();		if ((gAborted = MonitorDialog->HasAborted ()) == true)			break;	}	if (!gAborted)		--i;			o << "end;" << EOLN;	TheApp->DestroyDialog ();	return (i);}ostream& TTreesFile::ShowTrees (ostream& o, const TItemSet& itemSet, const bool name, const bool selected) const{	CHECK_ (!itemSet.IsEmpty ());	CHECK_ (itemSet.LastItem () <= GetTrees ());		TTree tree;	unsigned int i = 0;	while (++i <= itemSet.GetItems ())	{		GetIthTree (itemSet.IthItem (i), tree, true, selected);// JLT 000624		tree.SetNodeHeights ();		tree.WriteToLog (name);	}	return (o);}TTreesFile::TTreesFile (TTaxaBlock* taxaBlock, TTreesBlock* treesBlock)	: fTaxaBlock (taxaBlock)	, fTreesBlock (treesBlock){}TTreesFile::TTreesFile (const TTaxaBlock& taxaBlock, TTreesBlock* treesBlock)	: fTreesBlock (treesBlock){	fTaxaBlock = new TTaxaBlock (taxaBlock);}TTreesFile::TTreesFile (const TTreesFile& treesFile){	fTaxaBlock = (TTaxaBlock*)treesFile.fTaxaBlock->Clone ();	fTreesBlock = (TTreesBlock*)treesFile.fTreesBlock->Clone ();}ostream& TTreesFile::Write (ostream& o) const{	fTaxaBlock->Write (o);	return (fTreesBlock->Write (o));}ostream& TTreesFile::WriteInfoLeaves (ostream& o) const{	fTaxaBlock->WriteToLogAsList (fTaxaBlock->GetLeafSet ());	return (o);}	TTreesFile::~TTreesFile (void){	delete (fTaxaBlock);	delete (fTreesBlock);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif// this function adds trees from sourceTreesFile.// the trees to be added must be rooted or unrooted depending on the whether the trees belonging to this TSourceTreesFiles// are rooted or unrooted, respectively.// the trees added are the selected trees in sourceTreesFile.// sourceTreesFile must contain at least one selected tree.// this TSourceTreesFile must not be full i.e. the total trees must be less than the maximum number of trees.// the union of the leafsets for the two treesfiles must not exceed the maximum number of leaves.// the selected trees are added from sourceTreesFile consecutively until they are all added or the maximum // number of trees is reached.void TSourceTreesFile::AddTrees (const TSourceTreesFile& sourceTreesFile){	CHECK_ (IsRooted () ? sourceTreesFile.IsRooted () : !sourceTreesFile.IsRooted ());	CHECK_ (GetTotalTrees () < kMaxTrees);	CHECK_ (!sourceTreesFile.IsEmpty (true));	CHECK_ (sourceTreesFile.GetTotalLeafSet (true, false) == sourceTreesFile.GetLeafSet (true, true));	CHECK_ (fTaxaBlock->GetUnionLeaves (*sourceTreesFile.fTaxaBlock) <= kMaxLeaves);			fTaxaBlock->AddLeaves (sourceTreesFile.GetTaxaBlock ());	TLeafMap leafMap;	TLeafSet leafSet = sourceTreesFile.GetTaxaBlock ().GetLeafSet ();	for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())		leafMap.AddMapping (leaf, fTaxaBlock->GetLeafNumber (sourceTreesFile.GetTaxaBlock ().GetLeafName (leaf)));			MonitorDialog = TheApp->CreateMonitor (dlgProgressBar);	MonitorDialog->SetItemText (4, "Adding Trees");	MonitorDialog->SetMeter (sourceTreesFile.GetTrees (true) < (kMaxTrees - GetTotalTrees ()) ? sourceTreesFile.GetTrees (true) : (kMaxTrees - GetTotalTrees ()));	MonitorDialog->Show ();		TTree tree (IsRooted ());	unsigned int i = 0;	while (sourceTreesFile.GetIthTree (++i, tree, false, true) && GetTotalTrees () < kMaxTrees)	{		tree.MapLeaves (leafMap);		fTreesBlock->AddTree (tree);		MonitorDialog->UpdateMeter (i);				MonitorDialog->ProcessExternal ();		gAborted = MonitorDialog->HasAborted ();	}	TheApp->DestroyDialog ();		// might be excess leaves if not all added...}void TSourceTreesFile::CondenseTrees (const CondenseTreesOptionType option, const bool bootstrap){	CHECK_ (GetTotalLeafSet (false, false) == fTaxaBlock->GetLeafSet ());		((TSourceTreesBlock*)fTreesBlock)->CondenseTrees (option, bootstrap);	const TLeafSet leafSet = (fTaxaBlock->GetLeafSet () - GetTotalLeafSet (false, false));		if (!leafSet.IsEmpty ())	{		fTaxaBlock->PruneLeaves (leafSet);		TLeafMap leafMap (fTaxaBlock->GetLeafSet (), fTaxaBlock->GetLeafSet ().GetLeaves ());		MapLeaves (leafMap);	}}unsigned int TSourceTreesFile::GetUnionLeaves (const TSourceTreesFile& sourceTreesFile) const{	return (fTaxaBlock->GetUnionLeaves (*sourceTreesFile.fTaxaBlock));}void TSourceTreesFile::GraftLeafAsOutgroup (const TString& leaf){	CHECK_ (!fTaxaBlock->IsLeaf (leaf) && GetTotalLeaves (false, false) < kMaxLeaves);	fTaxaBlock->AddLeaf (leaf, GetTotalLeaves (false, false) + 1);	((TSourceTreesBlock*)fTreesBlock)->GraftLeafAsOutgroup (GetTotalLeaves (false, false) + 1);}TSourceTreesFile::TSourceTreesFile (TTaxaBlock* taxaBlock, TSourceTreesBlock* sourceTreesBlock, const char* name)	:	TTreesFile (taxaBlock, sourceTreesBlock)	,	fName (name){	CHECK_ (taxaBlock && sourceTreesBlock);}TSourceTreesFile::TSourceTreesFile (const TSourceTreesFile& sourceTreesFile) 	: TTreesFile (sourceTreesFile) { 	CHECK_ (0);}ostream& TSourceTreesFile::WriteClusters (ostream& o, const float limit, const bool writeWeights, const bool writeDifferences) const{	CHECK_ (0 <= limit && limit <= 1);		((const TSourceTreesBlock*)fTreesBlock)->WriteClusters (o, limit, writeWeights, writeDifferences); 	o << EOLN;	fTaxaBlock->WriteAsList (o, fTreesBlock->GetLeafSet (true, true));	return (o);}void TSourceTreesFile::WriteClustersToLog (const bool writeWeights, const bool writeDifferences) const{	// JLT 000624	#ifdef VCLASS 		WriteClusters (*logStream, 0, writeWeights, writeDifferences); // JLT 010418 set limit to 0 so all clusters drawn to file		logStream->flush();	#else		Write (cout, name);	#endif}ostream& TSourceTreesFile::WriteSplits (ostream& o, const float limit, const bool weights) const{	CHECK_ (0 <= limit && limit <= 1);		((const TSourceTreesBlock*)fTreesBlock)->WriteSplits (o, limit, weights); 	o << EOLN;	fTaxaBlock->WriteAsList (o, fTreesBlock->GetLeafSet (true, true));	return (o);}void TSourceTreesFile::WriteSplitsToLog (const bool weights) const{	// JLT 000624	#ifdef VCLASS 		WriteSplits (*logStream, 1, weights);		logStream->flush();	#else		Write (cout, name);	#endif}ostream& TSourceTreesFile::WriteInfoTrees (ostream& o) const{	*Log << (int)GetTotalTrees () << ' ' << "Source "<< (GetTotalTrees () == 1 ? "Tree " : "Trees ");	*Log << EOLN;//	*Log << EOLN;	*Log << (int)GetTotalLeaves (false, true) << ' ' << (GetTotalLeaves (false, true) == 1 ? "Leaf occurs " : "Leaves occur ") << "in at least 1 of the Source Trees ";	if (GetTotalLeaves (false, true))	{		*Log << "(";		GetTotalLeafSet (false, true).WriteToLog ();		*Log << ")";	}	*Log << EOLN;	*Log << (int)GetTotalLeaves (true, true) << ' ' << (GetTotalLeaves (true, true) == 1 ? "Leaf occurs " : "Leaves occur ") << "in all of the Source Trees ";	if (GetTotalLeaves (true, true))	{		*Log << "(";		GetTotalLeafSet (true, true).WriteToLog ();		*Log << ")";	}	*Log << EOLN;	//	*Log << EOLN;	if (!GetPrunedLeaves ())		*Log << "No Leaves are Pruned from the Source Trees";	else	{		*Log << (int)GetPrunedLeaves () << ' ' << (GetPrunedLeaves () == 1 ? "Leaf is " : "Leaves are ") << "Pruned from the Source Trees ";		*Log << "(";		GetPrunedLeafSet ().WriteToLog ();		*Log << ")";	}	*Log << EOLN;		*Log << EOLN;	if (GetTotalTrees () == GetTrees (false))		*Log << "All Source Trees are Active";	else if (!GetTrees (false))		*Log << "No Source Trees are Active";	else	{		*Log << (int)GetTrees (false) << ' ' << "Source " << (GetTrees (false) == 1 ? "Tree is " : "Trees are ") << "Active ";		if (GetTrees (false)) 		{			*Log << "(";			((const TSourceTreesBlock*)fTreesBlock)->GetActive ().WriteToLog ();			*Log << ")";		}		*Log << EOLN;		//		*Log << EOLN;		*Log << (int)GetLeaves (false, false) << ' ' << (GetLeaves (false, false) == 1 ? "Leaf occurs " : "Leaves occur ") << "in at least 1 of the Active Trees ";		if (GetLeaves (false, false))		{			*Log << "(";			GetLeafSet (false, false).WriteToLog ();			*Log << ")";		}		*Log << EOLN;				*Log << (int)GetLeaves (true, false) << ' ' << (GetLeaves (true, false) == 1 ? "Leaf occurs " : "Leaves occur ") << "in all of the Active Trees ";		if (GetLeaves (true, false))		{			*Log << "(";			GetLeafSet (true, false).WriteToLog ();			*Log << ")";		}	}	*Log << EOLN;		*Log << EOLN;	if (GetTrees (false) == GetTrees (true))		*Log << "All Active Trees are Selected";	else if (!GetTrees (true))		*Log << "No Active Trees are Selected";	else	{		*Log << (int)GetTrees (true) << ' ' << "Active " << (GetTrees (true) == 1 ? "Tree is " : "Trees are ") << "Selected ";		if (GetTrees (true)) 		{			*Log << "(";			GetItemSet ().WriteToLog ();			*Log << ")";		}		*Log << EOLN;		//		*Log << EOLN;		*Log << (int)GetLeaves (false, true) << ' ' << (GetLeaves (false, true) == 1 ? "Leaf occurs " : "Leaves occur ") << "in at least 1 of the Selected Trees ";		if (GetLeaves (false, true))		{			*Log << "(";			GetTotalLeafSet (false, true).WriteToLog ();			*Log << ")";		}		*Log << EOLN;		*Log << (int)GetLeaves (true, true) << ' ' << (GetLeaves (true, true) == 1 ? "Leaf occurs " : "Leaves occur ") << "in all of the Selected Trees ";		if (GetLeaves (true, true))		{			*Log << "(";			GetLeafSet (true, true).WriteToLog ();			*Log << ")";		}	}	*Log << EOLN;	return (o);}TSourceTreesFile::~TSourceTreesFile (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TSourceTreesFileList::DetachItem (TSourceTreesFile*& treesFile){	if (!IsEmpty ())	{		TObject* item = NULL;		fList.DetachItem (item, false);		treesFile = (TSourceTreesFile*)item;	}}TSourceTreesFileList::TSourceTreesFileList (void)	:	fList (){}TSourceTreesFileList::~TSourceTreesFileList (void){}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TConsensusTreesFile::Consensus (void){	MonitorDialog = TheApp->CreateMonitor (dlgProgressBar);	MonitorDialog->SetItemText (4, (char*)GetProgressBarName ());	MonitorDialog->Show ();		consensus (MonitorDialog);	TheApp->DestroyDialog();}void TConsensusTreesFile::consensus (VMonitor* monitor){	CHECK_ (!fTreesDone);	CHECK_ (!fWeightsDone);		monitor->SetMeter (fSourceTrees);		while (!gAborted && fTreesDone < fSourceTrees)	{		nextTree ();			addTree ();		fWeightsDone += fCurSourceTree.GetWeight ();				monitor->UpdateMeter (++fTreesDone);		monitor->ProcessExternal ();		gAborted = monitor->HasAborted ();	}	CHECK_ (gAborted || fTreesDone == fSourceTrees);	CHECK_ (gAborted || fWeightsDone == fSourceWeights);}TConsensusTreesFile::TConsensusTreesFile (const TConsensusTreesFile& consensusTreesFile) 	: TTreesFile (consensusTreesFile) { 	CHECK_ (0); }TConsensusTreesFile::TConsensusTreesFile (const TSourceTreesFile& sourceTreesFile) 	: 	TTreesFile (sourceTreesFile.GetTaxaBlock ())	,	fConsensusTree (sourceTreesFile.IsRooted ())	,	fCurSourceTree (sourceTreesFile.IsRooted ())	,	fSourceName (sourceTreesFile.GetName ()){	CHECK_ (!fTreesBlock);	 	fTreesBlock = new TTreesBlock (sourceTreesFile.IsRooted ());	fTreesBlock->SetTreeStyle (sourceTreesFile.GetTreeStyle ());	fTreesDone = 0;	fWeightsDone = 0;		fSourceTreesBlock = &(sourceTreesFile.GetTreesBlock ());	fSourceTrees = fSourceTreesBlock->GetTrees (true);	fSourceWeights = fSourceTreesBlock->GetWeight (true);				SetFlag (kEqualLeafSets, fSourceTreesBlock->IsEqualLeafSets (true));}ostream& TConsensusTreesFile::WriteInfoTrees (ostream& dummy) const{	*Log << (int)GetTrees (false) << ' ' << "Consensus "<< (GetTrees (false) == 1 ? "Tree " : "Trees ");	*Log << EOLN;//	*Log << EOLN;		*Log << (int)GetLeaves (false, false) << ' ' << (GetLeaves (false, false) == 1 ? "Leaf occurs " : "Leaves occur ") << "in at least 1 of the Consensus Trees ";	if (GetLeaves (false, false))	{		*Log << "(";		GetLeafSet (false, false).WriteToLog ();		*Log << ")";	}		*Log << EOLN;		*Log << (int)GetLeaves (true, false) << ' ' << (GetLeaves (true, false) == 1 ? "Leaf occurs " : "Leaves occur ") << "in all of the Consensus Trees ";	if (GetLeaves (true, false))	{		*Log << "(";		GetLeafSet (true, false).WriteToLog ();		*Log << ")";	}	*Log << EOLN;	*Log << EOLN;	if (GetTrees (false) == GetTrees (true))		*Log << "All Consensus Trees are Selected";	else if (!GetTrees (true))		*Log << "No Consensus Trees are Selected";	else	{			*Log << (int)GetTrees (true) << ' ' << "Consensus " << (GetTrees (true) == 1 ? "Tree is " : "Trees are ") << "Selected ";		if (GetTrees (true)) 		{			*Log << "(";			GetItemSet ().WriteToLog ();			*Log << ")";		}		*Log << EOLN;//		*Log << EOLN;		*Log << (int)GetLeaves (false, true) << ' ' << (GetLeaves (false, true) == 1 ? "Leaf occurs " : "Leaves occur ") << "in at least 1 of the Selected Trees ";		if (GetLeaves (false, true))		{			*Log << "(";			GetLeafSet (false, true).WriteToLog ();			*Log << ")";		}		*Log << EOLN;				*Log << (int)GetLeaves (true, true) << ' ' << (GetLeaves (true, true) == 1 ? "Leaf occurs " : "Leaves occur ") << "all of the Selected Trees ";		if (GetLeaves (true, true))		{			*Log << "(";			GetLeafSet (true, true).WriteToLog ();			*Log << ")";		}	}	*Log << EOLN;	return (dummy);}TConsensusTreesFile::~TConsensusTreesFile (void) { }