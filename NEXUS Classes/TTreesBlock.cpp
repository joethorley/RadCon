#include "TTreesBlock.h"#include "DialogIDs.h"#include "VMsg.h"#include "CMinLimits.h"// JLT 000624#include "wstream.h"extern ostream *logStream;extern VMonitor* MonitorDialog;extern BOOL gAborted;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TTreesBlock::AddTree (const TTree& tree){	CHECK_ (IsRooted () ? tree.IsRooted () : !tree.IsRooted ());	CHECK_ (tree.GetLeaves () > (IsRooted () ? 2 : 3));		if (IsEmpty ())		fCurTreeNumber = 1;		if (!IsRooted ())	{		((TTree&)tree).Root ();		fTreeStore.AddItem (tree);		((TTree&)tree).UnRoot ();	}	else		fTreeStore.AddItem (tree);			fSelected += fTreeStore.GetItems (); 	clearSets ();	SetFlag (kLeafSetsUpdated, false);}void TTreesBlock::Copy (const TObject& obj){	CHECK_ (Class () == obj.Class ());		const TTreesBlock& treesBlock = (const TTreesBlock&)obj;		fTreeStore.Copy (treesBlock.fTreeStore);	fSelected.Copy (treesBlock.fSelected);		fIntersectionAll.Copy (treesBlock.fIntersectionAll);	fIntersectionSelected.Copy (treesBlock.fIntersectionSelected);	fUnionAll.Copy (treesBlock.fUnionAll);	fUnionSelected.Copy (treesBlock.fUnionSelected);	fTreeStyle = treesBlock.fTreeStyle;		fCurTreeNumber = treesBlock.fCurTreeNumber;	SetFlag (kRooted, treesBlock.IsFlag (kRooted));	SetFlag (kLeafSetsUpdated, treesBlock.IsFlag (kLeafSetsUpdated));}bool TTreesBlock::getIthTree (const unsigned int i, TTree& tree) const{	if (!tree.IsRooted ())		tree.Root ();			if (fTreeStore.GetIthTree (i, tree))	{		if (!IsRooted ())			tree.UnRoot ();			return (true);	}	return (false);}bool TTreesBlock::GetIthTree (const unsigned int i, TTree& tree, const bool selected) const { 	if (getIthTree (convert (i, selected), tree))	{		tree.ReArrange (); // so that all drawn the same way can control here...		return (true);	}	return (false);}// assumes maxleaves * maxtrees is less than ULONG_MAX = 400 * 10^6unsigned long TTreesBlock::GetInternalBranches (const bool selected) const{	unsigned long internalBranches = 0;	TTree tree;	unsigned short i = 0;	while (GetIthTree (++i, tree, selected))		internalBranches += tree.InternalBranches ();			return (internalBranches);}// this is where needs doing...// 10000 (maxtrees) -> use unsigned long int// could dramatically improve if not need to rearrange trees. This is for saftey.// better to just pull out as is...and compare using a ItemSet of trees chnage at some dateunsigned int TTreesBlock::GetNumberDifferentTrees (const bool selected) const {	unsigned int treesDone = 0;	TTreeStore treeStore;	MonitorDialog = TheApp->CreateMonitor (dlgProgressBarNoStop);	MonitorDialog->SetItemText (4, "Recoding trees for comparisons");	MonitorDialog->SetMeter (GetTrees (selected));	MonitorDialog->Show ();			TTree tree;	for (unsigned int i = 1; GetIthTree (i, tree, selected); ++i)	{		if (!IsRooted ())		{			tree.Root ();			tree.ReRoot (tree.GetLeafSet ().FirstLeaf ());		}		tree.ReArrange ();		treeStore.AddItem (tree);			MonitorDialog->UpdateMeter (i);		MonitorDialog->ProcessExternal ();	}		CHECK_ (treeStore.GetItems () == GetTrees (selected));		MonitorDialog->SetItemText (4, "Comparing trees");	MonitorDialog->SetMeter (GetTrees (selected));	const TAncestorFunction* anf1;	unsigned int i1 = 0;	while (treeStore.GetIthAncestorFunction (++i1, anf1))	{			unsigned int trees = 1;				unsigned int i2 = i1 + 1;		const TAncestorFunction* anf2;		while (treeStore.GetIthAncestorFunction (i2, anf2))		{			if (anf1->IsEqual (*anf2))			{				++trees;				++treesDone;				treeStore.DeleteIthItem (i2);			}			else				++i2;		}		MonitorDialog->UpdateMeter (++treesDone);		MonitorDialog->ProcessExternal ();	}	TheApp->DestroyDialog ();		 	return ((unsigned int)treeStore.GetItems ()); }// 10000 (maxtrees) * (1500 * 1499 * 1498 / 6)// 1 * 10^4 * 5.7 * 10^8 = 5.7 * 10^12// ULLONG_MAX = 1.8 * 10^19unsigned long long TTreesBlock::GetResolvedTriplets (const bool selected) const{	CHECK_ (IsRooted ());	CHECK_ (kMaxLeaves <= 1500)		unsigned long long triplets = 0;	TTree tree;	unsigned short i = 0;	while (GetIthTree (++i, tree, selected))		triplets += tree.GetResolvedTriplets ();		return (triplets);}// 10000 (maxtrees) * (500 * 499 * 498 * 497 / 24)// 1 * 10^4 * 2.6 * 10^9 = 2.6 * 10^13// ULLONG_MAX = 1.8 * 10^19unsigned long long TTreesBlock::GetResolvedQuartets (const bool selected) const{	CHECK_ (!IsRooted ());	CHECK_ (kMaxLeaves <= 500);		unsigned long long quartets = 0;	TTree tree;	unsigned int i = 0;	while (GetIthTree (++i, tree, selected))		quartets += tree.GetResolvedQuartets ();		return (quartets);}const TLeafSet& TTreesBlock::GetLeafSet (const bool intersection, const bool selected) const {	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();			if (intersection)		return (selected ? fIntersectionSelected : fIntersectionAll);	return (selected ? fUnionSelected : fUnionAll);}bool TTreesBlock::IsBinary (const bool selected) const{	unsigned int i = 0;	while (GetIthItem (++i, selected))		if (!fTreeStore.IsIthTreeBinary (convert (i, selected), IsRooted ()))			return (false);	return (true);}	bool TTreesBlock::IsEqual (const TObject& obj) const{	CHECK_ (Class () == obj.Class ());		const TTreesBlock& treesBlock = (const TTreesBlock&)obj;		return (fTreeStore.IsEqual (treesBlock.fTreeStore));}// JLT 001001 replaced bug(?) return (GetLeafSet (true, selected) == GetLeafSet (false, selected)); bool TTreesBlock::IsEqualLeafSets (const bool selected) const {	CHECK_ (!IsEmpty (selected));		const TLeafSet* leafSetPtr;	GetIthTreeLeafSet (1, leafSetPtr, selected);	const TLeafSet leafSet = *leafSetPtr;		unsigned int i = 1;	while (GetIthTreeLeafSet (++i, leafSetPtr, selected))		if (leafSet != *leafSetPtr)			return (false);	return (true);}void TTreesBlock::MapLeaves (const TLeafMap& leafMap){	#if CONDCOMP_	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();	CHECK_ (fUnionAll == leafMap.GetLeafSet ());#endif // CONDCOMP_			TTree tree (true); // JLT 000502 from TTree tree (IsRooted ());	unsigned int i = 0;	while (fTreeStore.GetIthTree (++i, tree))	{		tree.MapLeaves (leafMap);		fTreeStore.SetIthTree (i, tree);	}	clearSets ();	SetFlag (kLeafSetsUpdated, false);}TTreesBlock& TTreesBlock::operator = (const TTreesBlock& treesBlock){	fTreeStore = treesBlock.fTreeStore;	fSelected = treesBlock.fSelected;		fIntersectionAll = treesBlock.fIntersectionAll;	fIntersectionSelected = treesBlock.fIntersectionSelected;	fUnionAll = treesBlock.fUnionAll;	fUnionSelected = treesBlock.fUnionSelected;	fTreeStyle = treesBlock.fTreeStyle;		fCurTreeNumber = treesBlock.fCurTreeNumber;	clearSets ();	SetFlag (kRooted, treesBlock.IsFlag (kRooted));	SetFlag (kLeafSetsUpdated, treesBlock.IsFlag (kLeafSetsUpdated));	return (*this);}void TTreesBlock::SelectAll (const bool select) {	TItemSet itemSet (GetTrees (false));	SelectSet (itemSet, select); }void TTreesBlock::SelectIth (const unsigned int i, const bool select) {	TItemSet itemSet;	itemSet += i;	SelectSet (itemSet, select);}void TTreesBlock::writeSelection (void) const{	*Log << EOLN << (int)fSelected.GetItems () << ' ' << "Consensus " << (fSelected.GetItems () == 1 ? "Tree is " : "Trees are ") << "Selected ";	if (fSelected.GetItems ()) 	{		*Log << "(";		fSelected.WriteToLog ();		*Log << ")";	}	*Log << EOLN;}void TTreesBlock::SelectSet (TItemSet itemSet, const bool select) { 	CHECK_ (itemSet.LastItem () <= GetTrees ()); 		if (select)		itemSet -= fSelected;	else		itemSet *= fSelected;		if (!itemSet.IsEmpty ())	{		*Log << EOLN << EOLN << (int)itemSet.GetItems () << ' ' << "Consensus " << (itemSet.GetItems () == 1 ? "Tree " : "Trees ") << (select ? "Selected " : "Deselected ");		*Log << "(";		itemSet.WriteToLog ();		*Log << ")";		select ? fSelected += itemSet : fSelected -= itemSet; 		*Log << EOLN;		SetFlag (kLeafSetsUpdated, false);		clearSets ();//		writeSelection ();		}}		void TTreesBlock::SetSelection (const TItemSet& itemSet) {	if (itemSet != fSelected)	{		TItemSet delta = itemSet - fSelected;			if (!delta.IsEmpty ())		{			*Log << EOLN << EOLN << (int)delta.GetItems () << ' ' << "Consensus " << (delta.GetItems () == 1 ? "Tree " : "Trees ") << "Selected ";			*Log << "(";			delta.WriteToLog ();			*Log << ")";			fSelected += delta;		}		delta = fSelected - itemSet;		if (!delta.IsEmpty ())		{			*Log << EOLN << (int)delta.GetItems () << ' ' << "Consensus " << (delta.GetItems () == 1 ? "Tree " : "Trees ") << "Deselected ";			*Log << "(";			delta.WriteToLog ();			*Log << ")";			fSelected -= delta;		}		*Log << EOLN;		SetFlag (kLeafSetsUpdated, false);		clearSets ();//		writeSelection ();		}}TTreesBlock::TTreesBlock (const bool rooted) 	:	fTreeStore ()	,	fSelected ()	,	fIntersectionAll ()	, 	fIntersectionSelected ()	,	fUnionAll ()	,	fUnionSelected ()	, 	fCurTreeNumber (0)	,	fTreeStyle (){	fTreeStyle.SetRectangular (TheApp->Preferences.GetIntPreference ("TREES", "RECTANGULAR", 1)); // sets default tree style	fTreeStyle.SetDrawName (TheApp->Preferences.GetIntPreference ("TREES", "DRAWNAMES", 1)); // sets default tree style	// JLT 010310 added option to control node heights but then found out that when the tree was not rectangular it all went to shit!!!	fTreeStyle.SetNodeHeights (TTreeStyle::kCardinality);#if 0	int nodeHeights = TheApp->Preferences.GetIntPreference ("PREFERENCES", "NODE_HEIGHTS", 1); // sets default node heights	switch (nodeHeights)	{		case 1:			fTreeStyle.SetNodeHeights (TTreeStyle::kCardinality);			break;					case 2:			fTreeStyle.SetNodeHeights (TTreeStyle::kTopDown);					break;					case 3:			fTreeStyle.SetNodeHeights (TTreeStyle::kBottomUp);								break;				default:			CHECK_ (0);			break;	}#endif 	SetFlag (kRooted, rooted);	SetFlag (kLeafSetsUpdated, false);	}TTreesBlock::TTreesBlock (const TTreesBlock& treesBlock)	: 	fTreeStore (treesBlock.fTreeStore)	,	fSelected (treesBlock.fSelected)	,	fIntersectionAll (treesBlock.fIntersectionAll)	, 	fIntersectionSelected (treesBlock.fIntersectionSelected)	,	fUnionAll (treesBlock.fUnionAll)	,	fUnionSelected (treesBlock.fUnionSelected)	,	fCurTreeNumber (treesBlock.fCurTreeNumber)	,	fTreeStyle (treesBlock.fTreeStyle){	SetFlag (kRooted, treesBlock.IsFlag (kRooted));	SetFlag (kLeafSetsUpdated, treesBlock.IsFlag (kLeafSetsUpdated));}void TTreesBlock::upDateLeafSets (void) const{	CHECK_ (!IsFlag (kLeafSetsUpdated));		((TTreesBlock*)this)->fIntersectionAll.SetEmpty ();	((TTreesBlock*)this)->fIntersectionSelected.SetEmpty ();	((TTreesBlock*)this)->fUnionAll.SetEmpty ();	((TTreesBlock*)this)->fUnionSelected.SetEmpty ();		unsigned int i = 1;	const TLeafSet* item;	fTreeStore.GetIthTreeLeafSet (i, item);	((TTreesBlock*)this)->fUnionAll = ((TTreesBlock*)this)->fIntersectionAll = *item;	if (!fSelected.IsEmpty () && fTreeStore.GetIthTreeLeafSet (fSelected.IthItem (i), item))		((TTreesBlock*)this)->fUnionSelected = ((TTreesBlock*)this)->fIntersectionSelected = *item;		while (fTreeStore.GetIthTreeLeafSet (++i, item))	{		((TTreesBlock*)this)->fIntersectionAll *= *item;		((TTreesBlock*)this)->fUnionAll += *item;		if (fSelected.IsItem (i))		{			((TTreesBlock*)this)->fIntersectionSelected *= *item;			((TTreesBlock*)this)->fUnionSelected += *item;		}	}			SetFlag (kLeafSetsUpdated, true);}TTreesBlock::~TTreesBlock (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TSourceTreesBlock::TReplicates::DeletedFromReplicate (const unsigned int replicate, const unsigned int trees){	CHECK_ ((GetReplicates () < replicate + 1) || (trees < (GetStartIthReplicate (replicate + 1) - GetStartIthReplicate (replicate))));		unsigned int i = replicate;	while (++i <= GetReplicates ())		fVArray[i-1] -= trees;}TSourceTreesBlock::TReplicates::TReplicates (void) 	: fVArray (1, 100) { 	fVArray[0] = 1; }TSourceTreesBlock::TReplicates::~TReplicates (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TSourceTreesBlock::AddTree (const TTree& tree){	if (IsEmpty ())		SetFlag (kBootstrap, tree.GetName ().IsBootstrap () && tree.GetName ().GetReplicateNumber () == 1 && tree.GetName ().GetTreeNumber () == 1); 	else	{		if (IsFlag (kBootstrap))		{						const TLeafSet* leafSet;			fTreeStore.GetIthTreeLeafSet (1, leafSet); 			if (tree.GetLeafSet () != *leafSet)				{				fReplicates.Clear ();				SetFlag (kBootstrap, false); 			}			else			{							const TTreeName* treeName;				fTreeStore.GetIthTreeName (fTreeStore.GetItems (), treeName);				if (!(tree.GetName ().IsBootstrap (treeName->GetReplicateNumber (), (treeName->GetTreeNumber () + 1))) && !(tree.GetName ().IsBootstrap (treeName->GetReplicateNumber () + 1, 1)))				{					fReplicates.Clear ();					SetFlag (kBootstrap, false); 				}				else if (fReplicates.GetReplicates () < tree.GetName ().GetReplicateNumber ())					fReplicates.SetStartNextReplicate (GetTrees () + 1);			}		}	}	fActive += (fTreeStore.GetItems () + 1);	fSelectedActive += (fTreeStore.GetItems () + 1);	fSelectedAll += (fTreeStore.GetItems () + 1);	TTreesBlock::AddTree (tree);	clearSets ();}void TSourceTreesBlock::clearSets (void) const{	if (fClusterList)	{		delete (fClusterList);		((TSourceTreesBlock*)this)->fClusterList = NULL;	}	if (fSplitSet)	{		delete (fSplitSet);		((TSourceTreesBlock*)this)->fSplitSet = NULL;	}}void TSourceTreesBlock::CondenseTrees (const CondenseTreesOptionType option, const bool bootstrap){	deleteInactiveTrees ();	deletePrunedLeaves ();	CHECK_ (fPruned.IsEmpty ());	CHECK_ (GetLeafSet (false, true) == GetTotalLeafSet (false, false));	CHECK_ (GetTrees () == GetTotalTrees ());	unsigned int treesDone = 0;		TTreeStore treeStore;	MonitorDialog = TheApp->CreateMonitor (dlgProgressBarNoStop);	MonitorDialog->SetItemText (4, "Recoding trees for condensing");	MonitorDialog->SetMeter (GetTrees ());	MonitorDialog->Show ();			TTree tree;	for (unsigned int i = 1; GetIthTree (i, tree); ++i)	{		if (!IsRooted ())		{			tree.Root ();			tree.ReRoot (tree.GetLeafSet ().FirstLeaf ());		}		tree.ReArrange ();		treeStore.AddItem (tree);			MonitorDialog->UpdateMeter (i);		MonitorDialog->ProcessExternal ();	}		CHECK_ (treeStore.GetItems () == fTreeStore.GetItems ());		MonitorDialog->SetItemText (4, "Condensing trees");	MonitorDialog->SetMeter (GetTrees ());	if (!bootstrap)	{		CHECK_ (option != kWeightBootstrap);				if (IsBootstrap ())		{			fReplicates.Clear ();			SetFlag (kBootstrap, false); 		}				const TAncestorFunction* anf1;		unsigned int i1 = 0;		while (treeStore.GetIthAncestorFunction (++i1, anf1))		{				unsigned int trees = 1;			double sumWeight = anf1->GetWeight ();			double maxWeight = anf1->GetWeight ();			double minWeight = anf1->GetWeight ();						unsigned int i2 = i1 + 1;			const TAncestorFunction* anf2;			while (treeStore.GetIthAncestorFunction (i2, anf2))			{				if (anf1->IsEqual (*anf2))				{					sumWeight += anf2->GetWeight ();					CHECK_ (sumWeight <= kMaxWeight); // need better way of handling....										maxWeight = Max (maxWeight, anf2->GetWeight ());					minWeight = Min (minWeight, anf2->GetWeight ());					++trees;					++treesDone;					treeStore.DeleteIthItem (i2);					fTreeStore.DeleteIthItem (i2);				}				else					++i2;			}			switch (option)			{				case kWeightSum:					fTreeStore.SetIthTreeWeight (i1, sumWeight);					break;				case kWeightMean:					fTreeStore.SetIthTreeWeight (i1, sumWeight / (double)trees);					break;				case kWeightMax:					fTreeStore.SetIthTreeWeight (i1, maxWeight);					break;				case kWeightMin:					fTreeStore.SetIthTreeWeight (i1, minWeight);					break;				default:					CHECK (0);					break;			}			MonitorDialog->UpdateMeter (++treesDone);			MonitorDialog->ProcessExternal ();		}			}	else	{		CHECK_ (IsBootstrap ());		unsigned int replicate = 0;		TTreeName name;		unsigned int i1;		while ((i1 = fReplicates.GetStartIthReplicate (++replicate)) != 0)		{			unsigned int deleted = 0;						--i1;			const TAncestorFunction* anf1;			while (treeStore.GetIthAncestorFunction (++i1, anf1) && anf1->GetName ().GetReplicateNumber () == replicate)			{				unsigned int trees = 1;				double sumWeight = anf1->GetWeight ();				double maxWeight = anf1->GetWeight ();				double minWeight = anf1->GetWeight ();				unsigned int i2 = i1 + 1;				const TAncestorFunction* anf2;				while (treeStore.GetIthAncestorFunction (i2, anf2) && anf2->GetName ().GetReplicateNumber () == replicate)				{					if (anf1->IsEqual (*anf2))					{						sumWeight += anf2->GetWeight ();						maxWeight = Max (maxWeight, anf2->GetWeight ());						minWeight = Min (minWeight, anf2->GetWeight ());						++trees;						++deleted;						++treesDone;						treeStore.DeleteIthItem (i2);						fTreeStore.DeleteIthItem (i2);					}					else						++i2;				}				name.SetBootstrap (replicate, (i1 + 1) - fReplicates.GetStartIthReplicate (replicate));				fTreeStore.SetIthTreeName (i1, name);				switch (option)				{					case kWeightSum:						fTreeStore.SetIthTreeWeight (i1, sumWeight);						break;					case kWeightMean:						fTreeStore.SetIthTreeWeight (i1, sumWeight / (double)trees);						break;					case kWeightMax:						fTreeStore.SetIthTreeWeight (i1, maxWeight);						break;					case kWeightMin:						fTreeStore.SetIthTreeWeight (i1, minWeight);						break;					case kWeightBootstrap:						break;					default:						CHECK_ (0);						break;				}				MonitorDialog->UpdateMeter (++treesDone);				MonitorDialog->ProcessExternal ();			}			fReplicates.DeletedFromReplicate (replicate, deleted);			if (option == kWeightBootstrap)				setWeightsTreesIthReplicate (replicate);		}	}	CHECK_ (treeStore.GetItems () == fTreeStore.GetItems ());	TItemSet active = fTreeStore.GetItems ();	setActive (active);		TheApp->DestroyDialog ();	}void TSourceTreesBlock::Copy (const TObject& obj){	CHECK_ (Class () == obj.Class ());	const TSourceTreesBlock& sourceTreesBlock = (const TSourceTreesBlock&)obj;	TTreesBlock::Copy (obj);	CHECK_ (0);}void TSourceTreesBlock::deleteInactiveTrees (void){		if (fActive.GetItems () != fTreeStore.GetItems ())	{			const unsigned int minLeaves = (IsRooted () ? 3 : 4);				unsigned int i = 1;		const TLeafSet* leafSet; // JLT 010412		if (fPruned.IsEmpty ())		{			while (fTreeStore.GetIthTreeLeafSet (i, leafSet))			{				if (minLeaves <= leafSet->GetLeaves ())					++i;				else					fTreeStore.DeleteIthItem (i);			}		}		else		{							while (fTreeStore.GetIthTreeLeafSet (i, leafSet))			{				if (minLeaves <= (*leafSet - fPruned).GetLeaves ())					++i;				else					fTreeStore.DeleteIthItem (i);					}		}		TItemSet active (fTreeStore.GetItems ());		setActive (active);				SetFlag (kLeafSetsUpdated, false);	}}void TSourceTreesBlock::deletePrunedLeaves (void){#if CONDCOMP_	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();	CHECK_ (fActive.GetItems () == fTreeStore.GetItems () && fActive.IsSequential ());#endif // CONDCOMP_	if (!fPruned.IsEmpty ())	{		MonitorDialog = TheApp->CreateMonitor (dlgProgressBarNoStop);		MonitorDialog->SetItemText (4, "Deleting Pruned Leaves");		MonitorDialog->SetMeter (fTreeStore.GetItems ());		MonitorDialog->Show ();		const TLeafSet* leafSet; // JLT 010412 made const		unsigned int i = 0;		TTree tree (true); // 000502 JLT from TTree tree (IsRooted ());		while (fTreeStore.GetIthTreeLeafSet (++i, leafSet))		{			if (!(*leafSet * fPruned).IsEmpty ())			{				fTreeStore.GetIthTree (i, tree);				tree.PruneLeaves (fPruned);				fTreeStore.SetIthTree (i, tree);			}				if (!(i%10))			{				MonitorDialog->UpdateMeter (i);				MonitorDialog->ProcessExternal ();			}		}		TheApp->DestroyDialog ();				if (IsFlag (kLeafSetsUpdated))		{			fIntersectionAll -= fPruned;			fIntersectionSelected -= fPruned;			fUnionAll -= fPruned;			fUnionSelected -= fPruned;			fIntersectionActive -= fPruned;			fUnionActive -= fPruned;		}		fPruned.SetEmpty ();	}}const TLeafSet& TSourceTreesBlock::GetLeafSet (const bool intersection, const bool selected) const{	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();		if (intersection)		((TSourceTreesBlock*)this)->fLeafSet = (selected ? fIntersectionSelected : fIntersectionActive);	else		((TSourceTreesBlock*)this)->fLeafSet = (selected ? fUnionSelected : fUnionActive);		if (!fPruned.IsEmpty ())		((TSourceTreesBlock*)this)->fLeafSet -= fPruned;		return (fLeafSet);}bool TSourceTreesBlock::getIthTree (const unsigned int i, TTree& tree) const{	if (TTreesBlock::getIthTree (i, tree))	{		if (!fPruned.IsEmpty ())			tree.PruneLeaves (fPruned);		CHECK_ (3 < tree.GetLeaves () || (IsRooted () && tree.GetLeaves () == 3));		return (true);	}	return (false);}double TSourceTreesBlock::GetTotalInformation (const bool selected) const{	CHECK_ (!IsEmpty (selected));	CHECK_ (IsEqualLeafSets (selected));	CHECK_ (IsBinary (selected)); 	const TLeafSet* leafSet = NULL;   // JLT 010412 made const	GetIthTreeLeafSet (1, leafSet, selected);	return (calcCIC (GetNumberDifferentTrees (selected), calcB (leafSet->GetLeaves () - (IsRooted () ? 0 : 1))));}TLeafSet TSourceTreesBlock::GetTotalLeafSet (const bool intersection, const bool pruned) const {	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();		((TSourceTreesBlock*)this)->fLeafSet = (intersection ? fIntersectionAll : fUnionAll);		if (pruned && !fPruned.IsEmpty ())		((TSourceTreesBlock*)this)->fLeafSet -= fPruned;		return (fLeafSet);}double TSourceTreesBlock::GetWeight (const bool selected) const{	double weight = 0;	double item;	unsigned int i = 0;	while (GetIthTreeWeight (++i, item, selected))		weight += item;	CHECK_ (isfinite (weight));	return (weight);}void TSourceTreesBlock::GraftLeafAsOutgroup (const unsigned int leaf){	CHECK_ (IsRooted ());#if CONDCOMP_	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();	CHECK_ (!fUnionAll.IsLeaf (leaf) && 0 < leaf && leaf <= kMaxLeaves);#endif // CONDCOMP_	MonitorDialog = TheApp->CreateMonitor (dlgProgressBarNoStop);	MonitorDialog->SetItemText (4, "Grafting Leaf As Outgroup");	MonitorDialog->SetMeter (fTreeStore.GetItems ());	MonitorDialog->Show ();	TItemSet active;	TTree tree (IsRooted ());	unsigned int i = 0;	if (fPruned.IsEmpty ())	{		while (fTreeStore.GetIthTree (++i, tree))		{			tree.GraftLeafAsOutgroup (leaf);			fTreeStore.SetIthTree (i, tree);						if (3 < tree.GetLeaves () || (IsRooted () && tree.GetLeaves () == 3))				active += i;			if (!(i%10))			{				MonitorDialog->UpdateMeter (i);				MonitorDialog->ProcessExternal ();			}		}	}	else	{		unsigned int leaves;		while (fTreeStore.GetIthTree (++i, tree))		{			tree.GraftLeafAsOutgroup (leaf);				fTreeStore.SetIthTree (i, tree);						leaves = (tree.GetLeafSet () - fPruned).GetLeaves ();			if (3 < leaves || (IsRooted () && leaves == 3))				active += i;			if (!(i%10))			{				MonitorDialog->UpdateMeter (i);				MonitorDialog->ProcessExternal ();			}		}	}	TheApp->DestroyDialog ();			CHECK_ (fActive.IsSubset (active));		if (active != fActive)		setActive (active);	else if (IsFlag (kLeafSetsUpdated))	{		fIntersectionAll += leaf;		fIntersectionSelected += leaf;		fUnionAll += leaf;		fUnionSelected += leaf;		fIntersectionActive += leaf;		fUnionActive += leaf;	}	clearSets ();}bool TSourceTreesBlock::IsEqual (const TObject& obj) const{	CHECK_ (Class () == obj.Class ());	const TSourceTreesBlock& sourceTreesBlock = (const TSourceTreesBlock&)obj;	CHECK_ (0);	return (TTreesBlock::IsEqual (obj));}void TSourceTreesBlock::MapLeaves (const TLeafMap& leafMap){	TTreesBlock::MapLeaves (leafMap);	clearSets ();}bool TSourceTreesBlock::CanPruneLeaves (const TLeafSet& toPrune){	if (toPrune != fPruned)	{				const unsigned int limit = (IsRooted () ? 3 : 4);						const TLeafSet* leafSet; // JLT 010412 made const		unsigned int i = 0;				if (IsEqualTotalLeafSets (false))		{			fTreeStore.GetIthTreeLeafSet (1, leafSet);			return (limit <= (*leafSet - toPrune).GetLeaves ());		}						if (toPrune.IsEmpty ())		{			while (fTreeStore.GetIthTreeLeafSet (++i, leafSet) && !gAborted)				if (limit <= leafSet->GetLeaves ())					return (true);		}		else		{			while (fTreeStore.GetIthTreeLeafSet (++i, leafSet) && !gAborted)				if (limit <= (*leafSet - toPrune).GetLeaves ())					return (true);					}		return (false);	}	return (true);}void TSourceTreesBlock::PruneLeaves (const TLeafSet& toPrune){	if (toPrune != fPruned)	{		CHECK_ (CanPruneLeaves (toPrune));				const unsigned int limit = (IsRooted () ? 3 : 4);						TItemSet active;		const TLeafSet* leafSet; // JLT 010412 made const		unsigned int i = 0;				if (IsEqualTotalLeafSets (false))		{			fPruned = toPrune;					active.SetFull (fTreeStore.GetItems ());			if (active != fActive)				setActive (active);			clearSets ();		}		else		{			MonitorDialog = TheApp->CreateMonitor (dlgProgressBar);			MonitorDialog->SetItemText (4, "Pruning/Regrafting Leaves");			MonitorDialog->SetMeter (fTreeStore.GetItems ());			MonitorDialog->Show ();								if (toPrune.IsEmpty ())			{				while (fTreeStore.GetIthTreeLeafSet (++i, leafSet) && !gAborted)				{					if (limit <= leafSet->GetLeaves ())						active += i;					if (!(i%10))					{						MonitorDialog->UpdateMeter (i);						MonitorDialog->ProcessExternal ();						gAborted = MonitorDialog->HasAborted ();					}				}			}			else			{				while (fTreeStore.GetIthTreeLeafSet (++i, leafSet) && !gAborted)				{					if (limit <= (*leafSet - toPrune).GetLeaves ())						active += i;								if (!(i%10))					{						MonitorDialog->UpdateMeter (i);						MonitorDialog->ProcessExternal ();						gAborted = MonitorDialog->HasAborted ();					}				}			}			TheApp->DestroyDialog ();						fPruned = toPrune;					if (active != fActive)				setActive (active);			clearSets ();		}	}}void TSourceTreesBlock::ReRoot (const unsigned int leaf){#if CONDCOMP_	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();	CHECK_ (0 < leaf && !fPruned.IsLeaf (leaf) && fIntersectionAll.IsLeaf (leaf));#endif // CONDCOMP_		Root ();		if (!IsEmpty ())	{		MonitorDialog = TheApp->CreateMonitor (dlgProgressBarNoStop);		MonitorDialog->SetItemText (4, "Rerooting Trees");		MonitorDialog->SetMeter (fTreeStore.GetItems ());		MonitorDialog->Show ();		TTree tree (IsRooted ());		unsigned int i = 0;		while (fTreeStore.GetIthTree (++i, tree))		{			tree.ReRoot (leaf);			fTreeStore.SetIthTree (i, tree);			if (!(i%10))			{				MonitorDialog->UpdateMeter (i);				MonitorDialog->ProcessExternal ();			}		}		TheApp->DestroyDialog ();		clearSets ();	}}void TSourceTreesBlock::Root (void) {	if (!IsRooted ())	{		SetFlag (kRooted, true);				if (!IsEmpty ()) // not sure about this...		{			if (GetTotalLeaves (true, true) < 4)			{				TItemSet active = fActive;				const TLeafSet* leafSet; // JLT 010412 made const				unsigned int i = 0;				if (fPruned.IsEmpty ())				{					while (fTreeStore.GetIthTreeLeafSet (++i, leafSet))						if (2 < leafSet->GetLeaves ())							active += i;				}				else				{					while (fTreeStore.GetIthTreeLeafSet (++i, leafSet))						if (2 < (*leafSet - fPruned).GetLeaves ())							active += i;				}							CHECK_ (fActive.IsSubset (active));								if (active != fActive)					setActive (active);			}		}		clearSets ();	}}void TSourceTreesBlock::SelectSet (TItemSet itemSet, const bool select) { 	CHECK_ (itemSet.LastItem () <= GetTrees ());		if (select)		itemSet -= GetSelection ();	else		itemSet *= GetSelection ();			if (!itemSet.IsEmpty ())	{		TItemSet itemSetActive;		for (unsigned int i = itemSet.FirstItem (); i; i = itemSet.NextItem ())			itemSetActive += fActive.IthItem (i);							*Log << EOLN << EOLN << (int)itemSetActive.GetItems () << ' ' << "Source " << (itemSetActive.GetItems () == 1 ? "Tree " : "Trees ") << (select ? "Selected " : "Deselected ");		*Log << "(";		itemSetActive.WriteToLog ();		*Log << ")";				if (select)		{			fSelected += itemSet;			fSelectedActive += itemSetActive;			fSelectedAll += itemSetActive;		}		else		{			fSelected -= itemSet;			fSelectedActive -= itemSetActive;			fSelectedAll -= itemSetActive;		}		SetFlag (kLeafSetsUpdated, false);		clearSets ();		*Log << EOLN;//		writeSelection ();		}}void TSourceTreesBlock::setActive (const TItemSet& itemSet){	CHECK_ (!itemSet.IsEmpty () && itemSet.LastItem () <= fTreeStore.GetItems ());		if (itemSet != fActive)	{		fCurTreeNumber = fActive.IthItem (fCurTreeNumber);				CHECK_ (fCurTreeNumber);				TItemSet selectedActive = fSelectedActive;		TItemSet delta = itemSet - fActive;		if (!delta.IsEmpty ())		{			*Log << EOLN << (int)delta.GetItems () << ' ' << "Source " << (delta.GetItems () == 1 ? "Tree " : "Trees ") << "Activated ";			*Log << "(";			delta.WriteToLog ();			*Log << ")";			*Log << EOLN;						fActive += delta;			fSelectedActive += delta * fSelectedAll;		}		delta = fActive - itemSet;		if (!delta.IsEmpty ())		{			*Log << EOLN << (int)delta.GetItems () << ' ' << "Source " << (delta.GetItems () == 1 ? "Tree " : "Trees ") << "Deactivated ";			*Log << "(";			delta.WriteToLog ();			*Log << ")";			*Log << EOLN;						fActive -= delta;			fSelectedActive -= delta;		}		if (fActive.IsItem (fCurTreeNumber))			fCurTreeNumber = fActive.NumberOfItem (fCurTreeNumber);		else			fCurTreeNumber = 1;						SetFlag (kLeafSetsUpdated, false);		clearSets ();	//		writeActive ();					if (fSelectedActive != selectedActive)		{			delta = fSelectedActive - selectedActive;			if (!delta.IsEmpty ())			{				*Log << EOLN << (int)delta.GetItems () << ' ' << "Source " << (delta.GetItems () == 1 ? "Tree " : "Trees ") << "Selected ";				*Log << "(";				delta.WriteToLog ();				*Log << ")";				*Log << EOLN;							}			delta = selectedActive - fSelectedActive;			if (!delta.IsEmpty ())			{				*Log << EOLN << (int)delta.GetItems () << ' ' << "Source " << (delta.GetItems () == 1 ? "Tree " : "Trees ") << "Deselected ";				*Log << "(";				delta.WriteToLog ();				*Log << ")";				*Log << EOLN;			}//			writeSelection ();								}					fSelected.SetEmpty ();		for (unsigned int i = fSelectedActive.FirstItem (); i ; i = fSelectedActive.NextItem ())			fSelected += fActive.NumberOfItem (i);	}}void TSourceTreesBlock::SetSelection (const TItemSet& itemSet){	if (itemSet != GetSelection ())	{		TItemSet delta = itemSet - GetSelection ();			if (!delta.IsEmpty ())		{			TItemSet deltaActive;			for (unsigned int i = delta.FirstItem (); i; i = delta.NextItem ())				deltaActive += fActive.IthItem (i);								*Log << EOLN << EOLN << (int)deltaActive.GetItems () << ' ' << "Source " << (deltaActive.GetItems () == 1 ? "Tree " : "Trees ") << "Selected ";			*Log << "(";			deltaActive.WriteToLog ();			*Log << ")";			*Log << EOLN;			fSelected += delta;			fSelectedActive += deltaActive;			fSelectedAll += deltaActive;		}		delta = GetSelection () - itemSet;		if (!delta.IsEmpty ())		{			TItemSet deltaActive;			for (unsigned int i = delta.FirstItem (); i; i = delta.NextItem ())				deltaActive += fActive.IthItem (i);				*Log << EOLN << EOLN << (int)deltaActive.GetItems () << ' ' << "Source " << (deltaActive.GetItems () == 1 ? "Tree " : "Trees ") << "Deselected ";			*Log << "(";			deltaActive.WriteToLog ();			*Log << ")";			*Log << EOLN;			fSelected -= delta;			fSelectedActive -= deltaActive;			fSelectedAll -= deltaActive;		}		SetFlag (kLeafSetsUpdated, false);		clearSets ();//		writeSelection ();		}}void TSourceTreesBlock::setWeightsTrees (const unsigned int first, const unsigned int last, const double weight){	CHECK_ (weight);	CHECK_ (0 < first && first <= last && last <= fTreeStore.GetItems ());		unsigned int i = first - 1;	while (++i <= last)		fTreeStore.SetIthTreeWeight (i, weight);}void TSourceTreesBlock::SetWeightsTrees (const bool bootstrap, const double weight){	CHECK_ (weight);		if (!bootstrap)		setWeightsTrees (1, fTreeStore.GetItems (), weight);	else	{		CHECK_ (IsBootstrap ());		CHECK_ (GetTrees () == GetTotalTrees ());		unsigned int replicate = 0;		while (fReplicates.GetStartIthReplicate (++replicate))			setWeightsTreesIthReplicate (replicate, weight);	}	clearSets ();}void TSourceTreesBlock::setWeightsTreesIthReplicate (const unsigned int replicate, const double weight){	CHECK_ (weight);	CHECK_ (fReplicates.GetStartIthReplicate (replicate));	unsigned int first = fReplicates.GetStartIthReplicate (replicate);	unsigned int last = 0;	if (!fReplicates.GetStartIthReplicate (replicate + 1))		last = GetTotalTrees ();	else		last = (fReplicates.GetStartIthReplicate (replicate + 1) - 1);	const double w = (double)((double)weight / (double)((last + 1) - first));		setWeightsTrees (first, last, w);}TSourceTreesBlock::TSourceTreesBlock (const bool rooted) 	: TTreesBlock (rooted) { 	fClusterList = NULL;	fSplitSet = NULL;	SetFlag (kBootstrap, false);	SetFlag (kLeafSetsUpdated, false);}TSourceTreesBlock::TSourceTreesBlock (const TSourceTreesBlock& sourceTreesBlock)	:	TTreesBlock (sourceTreesBlock){	CHECK_ (0);}bool TSourceTreesBlock::CanUnRoot (void){	if (IsRooted ())	{		if (!IsEmpty ())		{			if (GetTotalLeaves (true, true) < 4)			{				const TLeafSet* leafSet; // JLT 010412 made const				unsigned int i = 0;				if (fPruned.IsEmpty ())				{					while (fTreeStore.GetIthTreeLeafSet (++i, leafSet))						if (3 < leafSet->GetLeaves ())							return (true);				}				else				{					while (fTreeStore.GetIthTreeLeafSet (++i, leafSet))						if (3 < (*leafSet - fPruned).GetLeaves ())							return (true);				}				return (false);			}		}	}	return (true);}void TSourceTreesBlock::UnRoot (void){	CHECK_ (CanUnRoot ());		if (IsRooted ())	{			if (!IsEmpty ())		{			if (GetTotalLeaves (true, true) < 4)			{				TItemSet active = fActive;				const TLeafSet* leafSet; // JLT 010412 made const				unsigned int i = 0;				if (fPruned.IsEmpty ())				{					while (fTreeStore.GetIthTreeLeafSet (++i, leafSet))						if (leafSet->GetLeaves () < 4)							active -= i;				}				else				{					while (fTreeStore.GetIthTreeLeafSet (++i, leafSet))						if ((*leafSet - fPruned).GetLeaves () < 4)							active -= i;				}				if (active != fActive)					setActive (active);			}		}		clearSets ();		SetFlag (kRooted, false);	}}void TSourceTreesBlock::upDateLeafSets (void) const{	CHECK_ (!IsFlag (kLeafSetsUpdated));		((TSourceTreesBlock*)this)->fIntersectionAll.SetEmpty ();	((TSourceTreesBlock*)this)->fIntersectionActive.SetEmpty ();	((TSourceTreesBlock*)this)->fIntersectionSelected.SetEmpty ();	((TSourceTreesBlock*)this)->fUnionAll.SetEmpty ();	((TSourceTreesBlock*)this)->fUnionActive.SetEmpty ();	((TSourceTreesBlock*)this)->fUnionSelected.SetEmpty ();		unsigned int i = 1;	const TLeafSet* item;	fTreeStore.GetIthTreeLeafSet (i, item);	((TSourceTreesBlock*)this)->fUnionAll = ((TSourceTreesBlock*)this)->fIntersectionAll = *item;	if (!fActive.IsEmpty () && fTreeStore.GetIthTreeLeafSet (fActive.IthItem (i), item))		((TSourceTreesBlock*)this)->fUnionActive = ((TSourceTreesBlock*)this)->fIntersectionActive = *item;	if (!fSelectedActive.IsEmpty () && fTreeStore.GetIthTreeLeafSet (fSelectedActive.IthItem (i), item))		((TSourceTreesBlock*)this)->fUnionSelected = ((TSourceTreesBlock*)this)->fIntersectionSelected = *item;		while (fTreeStore.GetIthTreeLeafSet (++i, item))	{		((TSourceTreesBlock*)this)->fIntersectionAll *= *item;		((TSourceTreesBlock*)this)->fUnionAll += *item;		if (fActive.IsItem (i))		{			((TSourceTreesBlock*)this)->fIntersectionActive *= *item;			((TSourceTreesBlock*)this)->fUnionActive += *item;			if (fSelectedActive.IsItem (i))			{				((TSourceTreesBlock*)this)->fIntersectionSelected *= *item;				((TSourceTreesBlock*)this)->fUnionSelected += *item;			}		}	}			SetFlag (kLeafSetsUpdated, true);}void TSourceTreesBlock::writeActive (void) const{	*Log << EOLN << (int)fActive.GetItems () << ' ' << "Source " << (fActive.GetItems () == 1 ? "Tree is " : "Trees are ") << "Active ";	if (fActive.GetItems ()) 	{		*Log << "(";		fActive.WriteToLog ();		*Log << ")";	}	*Log << EOLN;}	 void TSourceTreesBlock::writeSelection (void) const{	*Log << EOLN << (int)fSelectedActive.GetItems () << ' ' << "Source " << (fSelectedActive.GetItems () == 1 ? "Tree is " : "Trees are ") << "Selected ";	if (fSelectedActive.GetItems ()) 	{		*Log << "(";		fSelectedActive.WriteToLog ();		*Log << ")";	}	*Log << EOLN;} TSourceTreesBlock::~TSourceTreesBlock (void) { 	if (fClusterList)		delete (fClusterList);	if (fSplitSet)		delete (fSplitSet);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif