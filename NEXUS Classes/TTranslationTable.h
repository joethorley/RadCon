#ifndef __TTRANSLATIONTABLE_H#define __TTRANSLATIONTABLE_H#include "TTaxaBlock.h"#include "TFlags.h"class TTranslationTable : protected TFlags{	public:		TTranslationTable (TTaxaBlock& taxaBlock);				virtual ~TTranslationTable (void);		virtual void							AddLeaf (const TString& leafName) { CHECK_ (!IsToken (leafName)); fTaxaBlock.AddLeaf (leafName); };		virtual void							AddToken (const TString& token, const TString& leafName);												virtual bool							IsLeaf (const TString& leafName) const { return (fTaxaBlock.IsLeaf (leafName)); };		virtual bool							IsToken (const TString& token) const;		virtual unsigned int						GetLeafNumber (const TString& leafName) const;		virtual const TLeafSet&					GetLeafSet (void) const { return (fTaxaBlock.GetLeafSet ()); }; 		virtual unsigned int						GetLeaves (void) const { return (fTaxaBlock.GetLeaves ()); }; 			protected:			class TTranslationToken : public TSortable		{			public:				TTranslationToken (const TString token, const TLeafName* leafName = NULL);				virtual ~TTranslationToken (void) { };												virtual ClassType				Class (void) const { return (kTTranslationTokenClass); };				virtual TObject*				Clone (void) const { return (new TTranslationToken (*this)); };						virtual int						Compare (const TSortable& sortable) const { CHECK_ (Class () == sortable.Class ()); return (fToken.Compare (((const TTranslationToken&)sortable).fToken)); };				virtual void					Copy (const TObject& obj);	    			    		virtual HashValue				Hash (void) const { return (fToken.Hash () + (HashValue)fLeafName); };							virtual bool					IsEqual (const TObject& obj) const { CHECK (Class () == obj.Class ()); return (fToken.IsEqual (((const TTranslationToken&)obj).fToken)); };												virtual const TString&			GetLeafName (void) const { return (*fLeafName); };				virtual unsigned int				GetLeafNumber (void) const { return (fLeafName->GetNumber ()); };				virtual TTranslationToken&		operator = (const TTranslationToken& token); 								virtual ostream&				Write (ostream &o) const { return (o << fToken << ' ' << *fLeafName); };				protected:				TString 						fToken;				const TLeafName* 				fLeafName;		};		TTaxaBlock&								fTaxaBlock;		TBTree									fTranslationTokens;};#endif // __TTRANSLATIONTABLE_H