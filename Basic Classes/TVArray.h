#ifndef __TVARRAY_H#define __TVARRAY_H#include "TChecks.h"#include "TArray.h"template<class T>class TVArrayIterator;template<class T>class TVArrayIteratorConst;template<class T>class TVArray{    	friend class TVArrayIterator<T>;	friend class TVArrayIteratorConst<T>;    public:    	TVArray (const unsigned int sz, const unsigned int delta = 100);        TVArray (const TVArray<T>& array);        virtual ~TVArray (void);				virtual void								AddItem (const T& item) { IthItemRef (Size () + 1) = item; };		virtual T*									Array (void) { return (fArray->Array ()); };		virtual const T*							Array (void) const { return (fArray->Array ()); };		virtual void								Compact (void) { ReSize (Size ()); };		virtual unsigned int							Delta (void) const { return (fDelta); };								virtual void 								Fill (const T&);		virtual TVArrayIterator<T>&					Iterator (void) { return (*(new TVArrayIterator<T> (*this))); };		virtual TVArrayIteratorConst<T>&			IteratorConst (void) const { return (*(new TVArrayIteratorConst<T> (*this))); };				virtual T&									IthItemRef (const unsigned int i);				virtual const T&							IthItemRef (const unsigned int i) const;			virtual TVArray<T>&							MemCpy (const TVArray<T>&, const unsigned int);		virtual TVArray<T>& 						operator  = (const TVArray<T>&);		virtual bool		 						operator  == (const TVArray<T>& vArray) const;		virtual bool		 						operator  != (const TVArray<T>& vArray) const { return (!operator == (vArray)); };    	friend ostream& 							operator << (ostream& o, const TVArray<T>& vArray) { return (vArray.Write (o)); };				        virtual T& 									operator [] (const unsigned int i) { return (IthItemRef (i+1)); };		virtual const T& 							operator [] (const unsigned int i) const { return (IthItemRef (i+1)); };				virtual unsigned int							GetItems (void) const { return Size (); };		virtual void								ReSize (const unsigned int i);				virtual unsigned int							Size (void) const { return (fApparentSize); };		virtual ostream&							Write (ostream& o) const;			 protected:		virtual unsigned int 							nextDelta (const unsigned int size, const unsigned int delta) const { return ((size % delta) ? (((size + delta) / delta) * delta) : (size)); };				virtual void 								reallocate (const unsigned int newSize) const;	 	 	unsigned int									fApparentSize;	 	unsigned int									fDelta;	 	TArray<T>*									fArray;};template<class T>class TVArrayIterator{	friend class TVArrayIteratorConst<T>;	public:	 		TVArrayIterator (TVArray<T>& array) : fVArray (array) { fCurItem = 1; };		TVArrayIterator (const TVArrayIterator<T>& iterator) : fVArray (iterator.fVArray) { fCurItem = iterator.fCurItem; };		virtual bool								CurItem (void) const { return (IthItem (fCurItem)); };		virtual bool								CurItem (T*& item) const { return (IthItem (fCurItem, item)); };						virtual bool								FirstItem (void) { return (IthItem (fCurItem = 1)); };		virtual bool								FirstItem (T*& item) { return (IthItem (fCurItem = 1, item)); };		bool										IsReversible (void) const { return (true); };		virtual bool								IthItem (const unsigned int i) const { return ((bool)(0 < i && i <= fVArray.Size ())); };		virtual bool								IthItem (const unsigned int i, T*& item) const;				virtual T&									IthItemRef (const unsigned int i) const { return (fVArray.IthItemRef (i)); };					virtual bool								LastItem (void) { return (IthItem (fCurItem = fVArray.Size ())); };		virtual bool								LastItem (T*& item) { return (IthItem (fCurItem = fVArray.Size (), item)); };				virtual bool								NextItem (void) { return (CurItem () ? IthItem (++fCurItem) : false); };		virtual bool								NextItem (T*& item) { return (CurItem () ? IthItem (++fCurItem, item) : false); };        virtual T& 									operator [] (const unsigned int i) const { return (IthItemRef (i+1)); }; 				virtual bool								PrevItem (void) { return (CurItem () ? IthItem (--fCurItem) : false); };		virtual bool								PrevItem (T*& item) { return (CurItem () ? IthItem (--fCurItem, item) : false); };	protected:		TVArray<T>&									fVArray;		unsigned int									fCurItem;};template<class T>class TVArrayIteratorConst{	public:	  		TVArrayIteratorConst (const TVArray<T>& array) : fVArray (array) { fCurItem = 1;  };		TVArrayIteratorConst (const TVArrayIterator<T>& iterator) : fVArray (iterator.fVArray) { fCurItem = iterator.fCurItem; };		TVArrayIteratorConst (const TVArrayIteratorConst<T>& iteratorConst) : fVArray (iteratorConst.fVArray) { fCurItem = iteratorConst.fCurItem; };				virtual bool								CurItem (void) const { return (IthItem (fCurItem)); };		virtual bool								CurItem (const T*& item) const { return (IthItem (fCurItem, item)); };						virtual bool								FirstItem (void) { return (IthItem (fCurItem = 1)); };		virtual bool								FirstItem (const T*& item) { return (IthItem (fCurItem = 1, item)); };		bool										IsReversible (void) const { return (true); };		virtual bool								IthItem (const unsigned int i) const { return ((bool)(0 < i && i <= fVArray.Size ())); };		virtual bool								IthItem (const unsigned int i, const T*& item) const;				virtual const T&							IthItemRef (const unsigned int i) const { return (fVArray.IthItemRef (i)); };					virtual bool								LastItem (void) { return (IthItem (fCurItem = fVArray.Size ())); };		virtual bool								LastItem (const T*& item) { return (IthItem (fCurItem = fVArray.Size (), item)); };				virtual bool								NextItem (void) { return (CurItem () ? IthItem (++fCurItem) : false); };		virtual bool								NextItem (const T*& item) { return (CurItem () ? IthItem (++fCurItem, item) : false); };        virtual const T&							operator [] (const unsigned int i) const { return (IthItemRef (i+1)); }; 				virtual bool								PrevItem (void) { return (CurItem () ? IthItem (--fCurItem) : false); };		virtual bool								PrevItem (const T*& item) { return (CurItem () ? IthItem (--fCurItem, item) : false); };	protected:		const TVArray<T>&							fVArray;		unsigned int									fCurItem;};template<class T>void TVArray<T>::Fill (const T& t){	for (unsigned int i = 0; i < Size (); ++i)		fArray->IthItemRef (i+1) = t;}template<class T>T& TVArray<T>::IthItemRef (const unsigned int i){		if (fArray->Size () < i)		reallocate (i);			if (Size () < i)		fApparentSize = i;		return (fArray->IthItemRef (i));}template<class T>	const T& TVArray<T>::IthItemRef (const unsigned int i) const{		if (fArray->Size () < i)		reallocate (i);			if (Size () < i)		((TVArray<T>*)this)->fApparentSize = i;		return (fArray->IthItemRef (i));}template<class T>TVArray<T>&	TVArray<T>::MemCpy (const TVArray<T>& array, const unsigned int i){		CHECK (i <= array.Size ());	if (fArray->Size () < i)		reallocate (i);		if (Size () < i)		fApparentSize = i;		memcpy (fArray, array.fArray, i * sizeof(fArray[0]));	return (*this);}template<class T>TVArray<T>&	TVArray<T>::operator = (const TVArray<T>& vArray){	CHECK (this != vArray.this);		fApparentSize = vArray.fApparentSize; 	fDelta = vArray.fDelta; 	delete fArray; 	fArray = new TArray<T> (*vArray.fArray);	return (*this);}template<class T>bool TVArray<T>::operator  == (const TVArray<T>& vArray) const{	if (Size () == vArray.Size ())	{		for (unsigned int i = 1; i <= Size (); ++i)			if (IthItemRef (i) != vArray.IthItemRef (i))				return (false);		return (true);	}		return (false);}template<class T>void TVArray<T>::reallocate (const unsigned int newSize) const{	const unsigned int adjustedSize = fArray->Size () + nextDelta (newSize - fArray->Size (), fDelta);	TArray<T>* newArray = new TArray<T> (adjustedSize);	newArray->MemCpy (*fArray, Size ());	delete fArray;	((TVArray<T>*)this)->fArray = newArray;}template<class T>void TVArray<T>::ReSize (const unsigned int sz){	TArray<T>* newArray = new TArray<T> (sz);	newArray->MemCpy (*fArray, sz);	delete fArray;	fArray = newArray;	fApparentSize = sz;}template<class T>TVArray<T>::TVArray (const unsigned int sz, const unsigned int delta){		CHECK (delta);	fArray = new TArray<T> (delta);	fApparentSize = sz;	fDelta = delta;}template<class T>TVArray<T>::TVArray (const TVArray<T>& array){	fArray = new TArray<T> (*array.fArray);	fApparentSize = array.fApparentSize;	fDelta = array.fDelta;}template<class T>ostream& TVArray<T>::Write (ostream& o) const{	for (unsigned int i = 1; i <= GetItems (); ++i)		o << IthItemRef (i) << EOLN;	return (o);}template<class T>TVArray<T>::~TVArray (void) { 	delete (fArray); }template<class T>bool TVArrayIterator<T>::IthItem (const unsigned int i, T*& item) const{	if (IthItem (i))	{		item = &(fVArray[i-1]);		return (true);	}	return (false);}		template<class T>bool TVArrayIteratorConst<T>::IthItem (const unsigned int i, const T*& item) const{	if (IthItem (i))	{		item = &(fVArray[i-1]);		return (true);	}	return (false);}		#endif // __TVARRAY_H