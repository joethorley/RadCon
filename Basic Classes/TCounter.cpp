#include "TCounter.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifunsigned short TCounter::Decr (const unsigned short count) { 	CHECK_ ((unsigned long)0 <= (unsigned long)((unsigned long)fCount - (unsigned long)count)); 	return (fCount -= count); }int TCounter::Compare (const TSortable& sortable) const{	CHECK_ (Class () == sortable.Class ());	const TCounter& counter = (const TCounter&)sortable;	if (fCount != counter.fCount)	{		if (fCount < counter.fCount)			return (-1);		return (1);	}	return (0);}void TCounter::Copy (const TObject& obj) { 	CHECK_ (Class () == obj.Class ()); 	const TCounter& counter = (const TCounter&)obj;	fCount = counter.fCount; 	fMaxCount = counter.fCount;}unsigned short TCounter::Incr (const unsigned short count) { 	CHECK_ ((long int)((long int)fCount + (long int)count) <= (long int)fMaxCount); 	return (fCount += count); }TCounter& TCounter::operator = (const TCounter& counter){	fCount = counter.fCount;	fMaxCount = counter.fMaxCount;	return (*this);}TCounter::TCounter (const unsigned short count, const unsigned short maxCount) 	:	fCount (count)	,	fMaxCount (maxCount){	CHECK_ (0 <= fCount && fCount <= fMaxCount); }TCounter::TCounter (const TCounter& counter) 	:	fCount (counter.fCount)	,	fMaxCount (counter.fMaxCount){ }TCounter::~TCounter (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif