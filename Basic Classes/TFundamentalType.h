#ifndef __TFUNDAMENTALTYPE_H#define __TFUNDAMENTALTYPE_H#include "TChecks.h"#include "TSortable.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TFundamentalType ___#endiftemplate<class T>class TFundamentalType : public TSortable{	public:		TFundamentalType (void);		TFundamentalType (const T object);		TFundamentalType (const TFundamentalType<T>& fundamentalType);		virtual ~TFundamentalType (void);				virtual ClassType			Class (void) const { return (kTSortableClass); };		virtual TObject*			Clone (void) const { return (new TFundamentalType<T> (*this)); };				virtual int					Compare (const TSortable& sortable) const { CHECK_ (Class () == sortable.Class ()); return (((const TFundamentalType<T>&)this).GetObject () == ((const TFundamentalType<T>&)sortable).GetObject () ? 0 : (((const TFundamentalType<T>&)this).GetObject () < ((const TFundamentalType<T>&)sortable).GetObject () ? -1 : 1)); };		virtual void				Copy (const TObject& obj) { CHECK_ (Class () == obj.Class ()); ((TFundamentalType<T>&)this).SetObject (((const TFundamentalType<T>&)obj).GetObject ()); };    	virtual HashValue			Hash (void) const { return (fObject); }		    	virtual bool 				IsEqual (const TObject& obj) const { CHECK_ (Class () == obj.Class ()); return (((const TFundamentalType<T>&)this).GetObject () == ((const TFundamentalType<T>&)obj).GetObject ()); };		virtual T					GetObject (void) { return (fObject); };		virtual T					GetObject (void) const { return (fObject); };				virtual void				SetObject (const T object) { fObject = object; };		operator T (void) { return (T); }; // conversion operator				TFundamentalType<T>&		operator = (const T object);				TFundamentalType<T>&		operator = (const TFundamentalType<T>& fundamentalType);				TFundamentalType<T>&		operator += (const T object);				TFundamentalType<T>&		operator += (const TFundamentalType<T>& fundamentalType);				TFundamentalType<T>&		operator -= (const T object);				TFundamentalType<T>&		operator -= (const TFundamentalType<T>& fundamentalType);						TFundamentalType<T>&		operator -- (void); // prefix		TFundamentalType<T>			operator -- (int); // postfix		TFundamentalType<T>&		operator ++ (void); // prefix		TFundamentalType<T>			operator ++ (int); // postfix				friend TFundamentalType<T>	operator+ (const TFundamentalType<T>& fundamentalType1, const TFundamentalType<T>& fundamentalType2);		friend TFundamentalType<T>	operator- (const TFundamentalType<T>& fundamentalType1, const TFundamentalType<T>& fundamentalType2);						virtual ostream&			Write (ostream& o) const { return (o << fObject); };		protected:		T							fObject;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#endiftemplate<class T>TFundamentalType<T>& TFundamentalType<T>::operator = (const T object){	fObject = object;	return (*this);}		template<class T>TFundamentalType<T>& TFundamentalType<T>::operator = (const TFundamentalType<T>& fundamentalType){	fObject = fundamentalType.fObject;	return (*this);}		template<class T>TFundamentalType<T>& TFundamentalType<T>::operator += (const T object){	fObject += object;	return (*this);}template<class T>TFundamentalType<T>& TFundamentalType<T>::operator += (const TFundamentalType<T>& fundamentalType){	fObject += fundamentalType.fObject;	return (*this);}template<class T>TFundamentalType<T>& TFundamentalType<T>::operator -= (const T object){	fObject -= object;	return (*this);}template<class T>TFundamentalType<T>& TFundamentalType<T>::operator -= (const TFundamentalType<T>& fundamentalType){	fObject -= fundamentalType.fObject;	return (*this);}template<class T>TFundamentalType<T>& TFundamentalType<T>::operator -- (void){	--fObject;	return (*this);}template<class T>TFundamentalType<T> TFundamentalType<T>::operator -- (int){	TFundamentalType<T> fundamentalType (*this);	--fObject;	return (fundamentalType);}template<class T>TFundamentalType<T>& TFundamentalType<T>::operator ++ (void){	++fObject;	return (*this);}template<class T>TFundamentalType<T> TFundamentalType<T>::operator ++ (int){	TFundamentalType<T> fundamentalType (*this);	++fObject;	return (fundamentalType);}template<class T>TFundamentalType<T>	operator+ (const TFundamentalType<T>& fundamentalType1, const TFundamentalType<T>& fundamentalType2){	TFundamentalType<T> fundamentalType (fundamentalType1);	fundamentalType += fundamentalType2;	return (fundamentalType);}template<class T>TFundamentalType<T>	operator- (const TFundamentalType<T>& fundamentalType1, const TFundamentalType<T>& fundamentalType2){	TFundamentalType<T> fundamentalType (fundamentalType1);	fundamentalType -= fundamentalType2;	return (fundamentalType);}template<class T>TFundamentalType<T>::TFundamentalType (void)	:	fObject (0){}template<class T>TFundamentalType<T>::TFundamentalType (const T object)	:	fObject (object){}template<class T>TFundamentalType<T>::TFundamentalType (const TFundamentalType<T>& fundamentalType)	:	fObject (fundamentalType.fObject){}template<class T>TFundamentalType<T>::~TFundamentalType (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#endif // __TFUNDAMENTALTYPE_H