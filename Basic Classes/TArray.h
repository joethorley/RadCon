#ifndef __TARRAY_H#define __TARRAY_Htemplate<class T>class TArrayIterator;template<class T>class TArrayIteratorConst;template<class T>class TArray{    	friend class TArrayIterator<T>;	friend class TArrayIteratorConst<T>;    public:    	TArray (const unsigned int i);    	TArray (const unsigned int i, const T& item);        TArray (const TArray<T>& array);        virtual ~TArray (void) { delete [] fArray; };				virtual T*									Array (void) { return (fArray); };		virtual const T*							Array (void) const { return (fArray); };								virtual void 								Fill (const T& item, unsigned int to = 0);		virtual TArrayIterator<T>&					Iterator (void) { return (*(new TArrayIterator<T> (*this))); };		virtual TArrayIteratorConst<T>&				IteratorConst (void) const { return (*(new TArrayIteratorConst<T>(*this))); };				virtual T&									IthItemRef (const unsigned int i) { CHECK (i <= fSize); return (fArray[i-1]); };			virtual const T&							IthItemRef (const unsigned int i) const { CHECK (i <= fSize); return (fArray[i-1]); };			virtual void								MemCpy (const TArray<T>&, const unsigned int);						virtual TArray<T>& 							operator  = (const TArray<T>&);		virtual bool		 						operator  == (const TArray<T>& array) const;		virtual bool		 						operator  != (const TArray<T>& array) const { return (!operator == (array)); };    	friend ostream& 							operator << (ostream& o, const TArray<T>& array) { return (array.Write (o)); };				        virtual T& 									operator [] (const unsigned int i) { return (IthItemRef (i+1)); }; 		virtual const T& 							operator [] (const unsigned int i) const { return (IthItemRef (i+1)); };		virtual unsigned int							Size (void) const { return (fSize); }; 		virtual ostream&							Write (ostream& o) const;			 protected:	 	 	const unsigned int							fSize;	 	T*											fArray;};template<class T>class TArrayIterator{	friend class TArrayIteratorConst<T>;	public:	 		TArrayIterator (TArray<T>& array) : fArray (array) { fCurItem = 1; };		TArrayIterator (const TArrayIterator<T>& iterator) : fArray (iterator.fArray) { fCurItem = iterator.fCurItem; };		~TArrayIterator (void) { }				virtual bool								CurItem (void) const { return (IthItem (fCurItem)); };		virtual bool								CurItem (T*& item) const { return (IthItem (fCurItem, item)); };						virtual bool								FirstItem (void) { return (IthItem (fCurItem = 1)); };		virtual bool								FirstItem (T*& item) { return (IthItem (fCurItem = 1, item)); };		bool										IsReversible (void) const { return (true); };		virtual bool								IthItem (const unsigned int i) const { return ((bool)(0 < i && i <= fArray.fSize)); };		virtual bool								IthItem (const unsigned int, T*& item) const;				virtual T&									IthItemRef (const unsigned int i) const { return (fArray.IthItemRef (i)); };					virtual bool								LastItem (void) { return (IthItem (fCurItem = fArray.Size ())); };		virtual bool								LastItem (T*& item) { return (IthItem (fCurItem = fArray.Size (), item)); };				virtual bool								NextItem (void) { return (CurItem () ? IthItem (++fCurItem) : false); };		virtual bool								NextItem (T*& item) { return (CurItem () ? IthItem (++fCurItem, item) : false); };        virtual T& 									operator [] (const unsigned int i) const { return (IthItemRef (i+1)); }; 				virtual bool								PrevItem (void) { return (CurItem () ? IthItem (--fCurItem) : false); };		virtual bool								PrevItem (T*& item) { return (CurItem () ? IthItem (--fCurItem, item) : false); };				protected:		TArray<T>&									fArray;		unsigned int									fCurItem;};template<class T>class TArrayIteratorConst{	public:	  		TArrayIteratorConst (const TArray<T>& array) : fArray (array) { fCurItem = 1; };		TArrayIteratorConst (const TArrayIterator<T>& iterator) : fArray (iterator.fArray) { fCurItem = iterator.fCurItem; };		TArrayIteratorConst (const TArrayIteratorConst<T>& iteratorConst) : fArray (iteratorConst.fArray) { fCurItem = iteratorConst.fCurItem; };		~TArrayIteratorConst (void) { };				virtual bool								CurItem (void) const { return (IthItem (fCurItem)); };		virtual bool								CurItem (const T*& item) const { return (IthItem (fCurItem, item)); };						virtual bool								FirstItem (void) { return (IthItem (fCurItem = 1)); };		virtual bool								FirstItem (const T*& item) { return (IthItem (fCurItem = 1, item)); };		bool										IsReversible (void) const { return (true); };		virtual bool								IthItem (const unsigned int i) const { return ((bool)(0 < i && i <= fArray.fSize)); };		virtual bool								IthItem (const unsigned int, const T*& item) const;				virtual const T&							IthItemRef (const unsigned int i) const { return (fArray.IthItemRef (i)); };					virtual bool								LastItem (void) { return (IthItem (fCurItem = fArray.Size ())); };		virtual bool								LastItem (const T*& item) { return (IthItem (fCurItem = fArray.Size (), item)); };				virtual bool								NextItem (void) { return (CurItem () ? IthItem (++fCurItem) : false); };		virtual bool								NextItem (const T*& item) { return (CurItem () ? IthItem (++fCurItem, item) : false); };        virtual const T&							operator [] (const unsigned int i) const { return (IthItemRef (i+1)); }; 				virtual bool								PrevItem (void) { return (CurItem () ? IthItem (--fCurItem) : false); };		virtual bool								PrevItem (const T*& item) { return (CurItem () ? IthItem (--fCurItem, item) : false); };	protected:		const TArray<T>&							fArray;		unsigned int									fCurItem;};template<class T>void TArray<T>::Fill (const T& item, unsigned int to){	if (!to) 		to = fSize;	CHECK (to <= fSize);			for (unsigned int i = 0; i < to; ++i)		fArray[i] = item;}template<class T>void TArray<T>::MemCpy (const TArray<T>& array, const unsigned int i){	CHECK (i <= array.Size ());		if (i > Size())		memcpy (fArray, array.fArray, Size() * sizeof(fArray[0]));	else		memcpy (fArray, array.fArray, i * sizeof(fArray[0]));}template<class T>TArray<T>&	TArray<T>::operator = (const TArray<T>& array){	MemCpy (array, array.Size ());	return (*this);}template<class T>bool TArray<T>::operator  == (const TArray<T>& array) const{	if (Size () == array.Size ())	{		for (unsigned int i = 1; i <= Size (); ++i)			if (IthItemRef (i) != array.IthItemRef (i))				return (false);		return (true);	}		return (false);}template<class T>TArray<T>::TArray (const unsigned int i)	: fSize (i){	CHECK (0 < fSize);	fArray = new T [fSize];}template<class T>TArray<T>::TArray (const unsigned int i, const T& item)	: fSize (i){	CHECK (0 < fSize);	fArray = new T [fSize];	for (unsigned int ii = 0; ii < fSize; ++ii)		fArray[ii] = item;}template<class T>TArray<T>::TArray (const TArray<T>& array)	: fSize (array.fSize){	fArray = new T [fSize];	memcpy (fArray, array.fArray, Size() * sizeof(fArray[0]));}template<class T>ostream& TArray<T>::Write (ostream& o) const{	for (unsigned int i = 0; i < fSize; ++i)	{		o << fArray[i];		o << EOLN;	}	return (o);}template<class T>bool TArrayIterator<T>::IthItem (const unsigned int i, T*& item) const{	if (IthItem (i))	{		item = &(fArray[i-1]);		return (true);	}	return (false);}		template<class T>bool TArrayIteratorConst<T>::IthItem (const unsigned int i, const T*& item) const{	if (IthItem (i))	{		item = &(fArray[i-1]);		return (true);	}	return (false);}		#endif // __TARRAY_H