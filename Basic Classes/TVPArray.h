/***************************************************************************	(c) 1998, Joseph L. Thorley		All rights reserved	File: TVPArray.h	Purpose: base array class	History: 24/4/98****************************************************************************/#ifndef _TVPARRAY_H#define _TVPARRAY_H#include "TVArray.h"// variable length array// needs defining// copy from TPArry.h (and eventually replace) and have AddItem functions although not container// just keep increasing length (and decrease if copy smaller one...)template<class T>class TVPArrayIterator;template<class T>class TVPArrayIteratorConst;template<class T>class TVPArray :  public TObject{    	friend class TVPArrayIterator<T>;	friend class TVPArrayIteratorConst<T>;	    public:    	TVPArray (const ArrayItemNumber);        TVPArray (const TArray<T>&);        TVPArray (const TVPArray<T>&);        virtual ~TVPArray (void);		virtual ClassType							Class (void) const;		virtual TObject*							Clone (void) const; 		virtual TObject&							Copy (const TObject&);								virtual void 								DeleteAll (void);		virtual void								DeleteIthItem (const ArrayItemNumber);		virtual void								DetachIthItem (const ArrayItemNumber);		virtual void 								Fill (const T&);		virtual bool								IsEqual (const TObject& pArray) const;		virtual bool								IsIthFilled (const ArrayItemNumber) const;		virtual T&									IthItem (const ArrayItemNumber);				virtual const T&							IthItem (const ArrayItemNumber) const;			virtual TVPArray<T>&						Memcpy (const TArray<T>&, const ArrayItemNumber);		virtual TVPArray<T>&						Memcpy (const TVPArray<T>&, const ArrayItemNumber);		virtual TVPArray<T>& 						operator  = (const TArray<T>&);		virtual TVPArray<T>& 						operator  = (const TVPArray<T>&);				        virtual T& 									operator [] (const ArrayItemNumber); 		virtual const T& 							operator [] (const ArrayItemNumber) const;		virtual void								SetIthItem (const ArrayItemNumber, T*);				virtual void								SetIthItem (const ArrayItemNumber, const T&);						virtual ArrayItemNumber						Size (void) const;		virtual ostream&							Write (ostream&) const;			 protected:	 	TArray<T*>*									fArrayP; };template<class T>class TVPArrayIterator{	public:	 		TVPArrayIterator (const TVPArray<T>&);		TVPArrayIterator (const TVPArrayIterator<T>&);				virtual bool							CurItem (void) const;		virtual bool							CurItem (T*& item) const;		virtual bool							FirstItem (void);		virtual bool							FirstItem (T*& item);				virtual bool							NextItem (void);		virtual bool							NextItem (T*& item);	protected:		TVPArray<T>&								fPArray;		ArrayItemNumber							fCurItem;};template<class T>class TVPArrayIteratorConst{	public:	  		TVPArrayIteratorConst (const TArray<T>&);		TVPArrayIteratorConst (const TArrayIterator<T>&);		TVPArrayIteratorConst (const TArrayIteratorConst<T>&);				virtual bool							CurItem (void) const;		virtual bool							CurItem (const T*& item) const;		virtual bool							FirstItem (void);		virtual bool							FirstItem (const T*& item);						virtual bool							NextItem (void);		virtual bool							NextItem (const T*& item);	protected:		const TVPArray<T>&						fPArray;		ArrayItemNumber							fCurItem;};template<class T>inlineClassType TVPArray<T>::Class (void) const{	return ((ClassType)kTVPArrayClass);}TObject* TVPArray<T>::Clone (void) const{	pArray = new TVPArray<T>;	pArray->Copy (*this);	return (pArray);}TObject& TVPArray<T>::Copy (const TObject&){	ArrayItemNumber i = (Size() < pArray.Size()) ? Size() : pArray.Size();	Memcpy (pArray,i);	return (*this);}template<class T>void TVPArray<T>::Fill (const T& item){	for(ArrayItemNumber i = 0; i < Size(); ++i)	{		delete fArrayP->IthItem(i+1);		fArrayP->IthItem(i+1) = new T(item);	}}template<class T>void TVPArray<T>::DeleteAll (void){	for(ArrayItemNumber i = 0; i < Size() ; ++i)		DeleteIthItem(i+1);}template<class T>void TVPArray<T>::DeleteIthItem (const ArrayItemNumber i){	if(fArrayP->IthItem(i))	{		delete fArrayP->IthItem(i);		fArrayP->IthItem(i) = NULL;	}}template<class T>inlinevoid TVPArray<T>::DetachIthItem (const ArrayItemNumber i){	fArrayP->IthItem(i) = NULL;}template<class T>bool TVPArray<T>::IsEqual (const TObject& pArray) const{	return (true);}template<class T>inlinebool TVPArray<T>::IsIthFilled (const ArrayItemNumber i) const{	return ((bool)(fArrayP->IthItem (i) != NULL));}template<class T>T& TVPArray<T>::IthItem (const ArrayItemNumber i){	if(!(fArrayP->IthItem(i)))		fArrayP->IthItem(i) = new T;	return (*(fArrayP->IthItem(i)));}template<class T>	const T& TVPArray<T>::IthItem (const ArrayItemNumber i) const{	if(!(fArrayP->IthItem(i)))		fArrayP->IthItem(i) = new T;	return (*(fArrayP->IthItem(i)));}template<class T>TVPArray<T>&	TVPArray<T>::Memcpy (const TArray<T>& array, const ArrayItemNumber ii){	for(ArrayItemNumber i = 0; i < ii && i < Size() && i < array.Size(); ++i)	{		if(!(fArrayP->IthItem(i+1)))			fArrayP->IthItem(i+1) = new T (array[i]);		else			*(fArrayP->IthItem(i+1)) = array[i];		}	return (*this);}template<class T>TVPArray<T>&	TVPArray<T>::Memcpy (const TVPArray<T>& pArray, const ArrayItemNumber ii){	for(ArrayItemNumber i = 0; i < ii && i < Size() && i < pArray.Size(); ++i)	{		if(!(fArrayP->IthItem(i+1)))			fArrayP->IthItem(i+1) = new T (pArray[i]);		else			*(fArrayP->IthItem(i+1)) = pArray[i];		}	return (*this);}template<class T>TVPArray<T>&	TVPArray<T>::operator = (const TArray<T>& array){	// set i to smaller of Size() and array.Size()	ArrayItemNumber i = (Size() < array.Size()) ? Size() : array.Size();	return (Memcpy (array,i));}template<class T>TVPArray<T>&	TVPArray<T>::operator = (const TVPArray<T>& pArray){	// set i to smaller of Size() and array.Size()	ArrayItemNumber i = (Size() < pArray.Size()) ? Size() : pArray.Size();	return (Memcpy (pArray,i));}template<class T>T& TVPArray<T>::operator [] (const ArrayItemNumber i){   	if(!(fArrayP->IthItem(i+1)))		fArrayP->IthItem(i+1) = new T();	return (*(fArrayP->IthItem(i+1)));}template<class T>const T& TVPArray<T>::operator [] (const ArrayItemNumber i) const{   	if(!(fArrayP->IthItem(i+1)))		fArrayP->IthItem(i+1) = new T();	return (*(fArrayP->IthItem(i+1)));}template<class T>void TVPArray<T>::SetIthItem (const ArrayItemNumber i, T* item){	PRECONDITION (item);	if(fArrayP->IthItem(i))		delete fArrayP->IthItem(i);	fArrayP->IthItem(i) = item;}template<class T>		void TVPArray<T>::SetIthItem (const ArrayItemNumber i, const T& item){	if(!(fArrayP->IthItem(i)))		fArrayP->IthItem(i) = new T (item);	else		*(fArrayP->IthItem(i)) = item;}template<class T>inlineArrayItemNumber TVPArray<T>::Size (void) const{	return (fArrayP->Size());}template<class T>inlineTVPArray<T>::TVPArray (const ArrayItemNumber size){	fArrayP = new TArray<T*> (size);	for(ArrayItemNumber i = 0; i < Size() ; ++i)		fArrayP->IthItem(i+1) = NULL;}template<class T>TVPArray<T>::TVPArray (const TArray<T>& array){	fArrayP = new TArray<T*> (array.Size());	Memcpy (array,Size());}template<class T>TVPArray<T>::TVPArray (const TVPArray<T>& pArray){	fArrayP = new TArray<T*> (pArray.Size());	Memcpy (pArray,Size());}template<class T>inlineTVPArray<T>::~TVPArray (void){	DeleteAll();	delete fArrayP;}template<class T>ostream& TVPArray<T>::Write (ostream& o) const{	for(ArrayItemNumber i = 0;i < Size(); ++i)		o << IthItem(i+1) << EOLN;	return (o);}	template<class T>	bool TVPArrayIterator::CurItem (void) const{	return ((bool)(fCurItem < fPArray.fSize));}template<class T>bool TVPArrayIterator::CurItem (T*& item) const;{	if (CurItem ())	{		PRECONDITION (fPArray.IsIthFilled (fCurItem + 1));		item = &(fPArray[fCurItem]);		return (true);	}	return (false);}template<class T>bool TVPArrayIterator::FirstItem (void){	fCurItem = 0;	return (NextItem ());}template<class T>bool TVPArrayIterator::FirstItem (T*& item){	fCurItem = 0;	return (NextItem (item));}template<class T>bool TVPArrayIterator::NextItem (void){	if (fCurItem < fPArray.fSize)		while (++fCurItem < fPArray.Size)			if (fPArray.IsIthFilled (fCurItem + 1))				return (true);	return (false);}template<class T>	bool TVPArrayIterator::NextItem (T*& item){	if (fCurItem < fPArray.fSize)	{		while (++fCurItem < fPArray.Size)		{			if (fPArray.IsIthFilled (fCurItem + 1))			{				item = &(fPArray[fCurItem]);				return (true);			}		}	}	return (false);}template<class T>	TVPArrayIterator (const TVPArray<T>& pArray)	: fPArray (pArray){	FirstItem ();}template<class T>	TVPArrayIterator (const TVPArrayIterator<T>& iterator)	: fPArray (iterator.fPArray){	fCurItem = iterator.fCurItem;}	template<class T>	bool TVPArrayIteratorConst::CurItem (void) const{	return ((bool)(fCurItem < fPArray.fSize));}template<class T>bool TVPArrayIteratorConst::CurItem (T*& item) const;{	if (CurItem ())	{		PRECONDITION (fPArray.IsIthFilled (fCurItem + 1));		item = &(fPArray[fCurItem]);		return (true);	}	return (false);}template<class T>bool TVPArrayIteratorConst::FirstItem (void){	fCurItem = 0;	return (NextItem ());}template<class T>bool TVPArrayIteratorConst::FirstItem (T*& item){	fCurItem = 0;	return (NextItem (item));}template<class T>bool TVPArrayIteratorConst::NextItem (void){	if (fCurItem < fPArray.fSize)		while (++fCurItem < fPArray.Size)			if (fPArray.IsIthFilled (fCurItem + 1))				return (true);	return (false);}template<class T>	bool TVPArrayIteratorConst::NextItem (T*& item){	if (fCurItem < fPArray.fSize)	{		while (++fCurItem < fPArray.Size)		{			if (fPArray.IsIthFilled (fCurItem + 1))			{				item = &(fPArray[fCurItem]);				return (true);			}		}	}	return (false);}template<class T>	TVPArrayIteratorConst (const TVPArray<T>& pArray)	: fPArray (pArray){	FirstItem ();}template<class T>	TVPArrayIteratorConst (const TVPArrayIterator<T>& iterator)	: fPArray (iterator.fPArray){	fCurItem = iterator.fCurItem;}template<class T>	TVPArrayIteratorConst (const TVPArrayIteratorConst<T>& iterator)	: fPArray (iterator.fPArray){	fCurItem = iterator.fCurItem;}#endif // _TVPARRAY_H