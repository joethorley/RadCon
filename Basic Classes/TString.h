/*String class which uses pointer representation to minimise copyingand allocates new memory in blocks of size fDelta to minimisetime spent allocating memory. The amount of memory used can beminimised using Resize(). This can also be achieved by declaringfDelta to be 1.Two important concepts are the size (amount of memory allocatedi.e. number of characters including the terminating '\0' which canfit into the TString) the length (current number of characters before terminating '\0') of a TString.TStrings with fDelta = 0 cannot have their size increased i.e. they are of fixed size but not fixed length (although length cannot exceed size-1).If a TString of const length (and character codings) is desired then it should be declared as const. Note the fDelta of a string (unless it is const)can be changed at any time.The size of a string will be decreased (unless fDelta = 0 because wantthe size of such TStrings to be fixed unless ReSize is applied) by various functions although not in multiples of fDelta but to fit thenew character array exactly. This is considered a desirable propertybecause their is no restriction on increasing the size of such TStringsand so the reduction is not permanent.There is no guarantee that the size of a TString will be in multiplesof fDelta- it is only used in deciding how much to increase the sizeof a TString by but not how much to decrease it by or what its initialsize is.Enjoy!*/#ifndef __TSTRING_H#define __TSTRING_H#include <string.h>#include <stdio.h>#include <iostream.h>#include <istream.h>#include <stdlib.h>#include <exception.h>#include <locale.h> // JLT 010412#include <ctype.h> // JLT 010412#include "TSortable.h"#include "TChecks.h"#include "TCounter.h"#include "TClassTypes.h"// TO DO// add MaxLength??// use unsigned lengths ??class TStringIteratorConst;class TString : public TSortable{	friend class TStringIteratorConst;		public:		TString (const char* ="", const long int incr = 100);			TString (const long int n, const long int incr = 100);				TString (const TString&);		virtual ~TString (void);		virtual void 				AddToThis (const char ch);	    virtual void 				AddToThis (const char* str);	    virtual void	 			AddToThis (const TString& string);		virtual void				AddToThis (const float fl, const unsigned int precision = 6);		virtual void				AddToThis (const int i);		virtual void				AddToThis (const unsigned int u);		virtual void				AddToThis (const unsigned long int ul);		virtual void				AddToThis (const long int li);				virtual char*				Array (void);		virtual const char*			Array (void) const { return (fSRepPtr->fStr); };		virtual ClassType			Class (void) const { return (kTStringClass); };		virtual TObject*			Clone (void) const { return (new TString (*this)); };	   	virtual int 				Compare (const TSortable&) const;		    virtual int 				Compare (const char* str) const { return (strcmp (fSRepPtr->fStr, str)); };		virtual void				Copy (const TObject& obj);		virtual long int		Delta (void) const { return (fDelta); };				// create new class maybe call TNumberString or maybe keep as part of string ??		virtual int					ToInteger (void) const;		virtual double				FractionToDouble (void) const;		virtual double				ToDouble (void) const;				virtual const char*			FindCharacter (const char ch) const { return (strchr (fSRepPtr->fStr, ch)); };		virtual const char*			FindCharacters (const TString& set) const { return (strpbrk (fSRepPtr->fStr, set.Array ())); };		virtual const char*			FindNotCharacter (const char ch) const;		virtual const char*			FindNotCharacters (const TString& set) const;		virtual bool				IsFindCharacter (const char ch) const { return ((bool)FindCharacter (ch)); };		virtual bool				IsFindCharacters (const TString& set) const { return ((bool)FindCharacters (set)); };		virtual bool				IsFindNotCharacter (const char ch) const { return ((bool)FindNotCharacter (ch)); };		virtual bool				IsFindNotCharacters (const TString& set) const { return ((bool)FindNotCharacters (set)); };			virtual bool				IsEqual (const TObject&) const;		virtual bool				IsEqual (const char* str) const { return ((bool)((strcmp (fSRepPtr->fStr, str)) == 0)); };				virtual bool				IsFixed (void) const { return (fDelta == 0); };		virtual bool				IsFull (void) const { return (fDelta == 0 && fSRepPtr->fLength == fSRepPtr->fSize-1); };		virtual bool				IsInteger (void) const;		virtual bool				IsFraction (void) const;		virtual bool				IsToken (const TString& set) const;		virtual bool				IsFloat (void) const;		virtual bool				IsNull (void) const { return ((bool) fSRepPtr->fLength==0); };		virtual TStringIteratorConst&		IteratorConst (void) const;		virtual char&				IthChar (const long int i);		virtual const char&			IthChar (const long int i) const;				virtual HashValue			Hash (void) const;	    virtual long int 		Length (void) const { return (fSRepPtr->fLength); };					    virtual char& 				operator [] (const long int i) { return (IthChar (i+1)); };	    virtual const char&			operator [] (const long int i) const { return (IthChar (i+1)); };   		// relational operators	    virtual int 				operator == (const TObject& obj) const { return (IsEqual (obj)); };	    virtual int 				operator != (const TObject& obj) const { return (!IsEqual (obj)); };	    virtual int 				operator <= (const TSortable& sortable) const { return (Compare (sortable) <= 0); };	    virtual int 				operator >= (const TSortable& sortable) const { return (Compare (sortable) >= 0); };	    virtual int 				operator < (const TSortable& sortable) const { return (Compare (sortable) < 0); };	    virtual int 				operator > (const TSortable& sortable) const { return (Compare (sortable) > 0); };	    virtual int 				operator == (const char* str) const { return (IsEqual (str)); };	    virtual int 				operator != (const char* str) const { return (!IsEqual (str)); };	    virtual int 				operator <= (const char* str) const { return (Compare (str) <= 0); };	    virtual int 				operator >= (const char* str) const { return (Compare (str) >= 0); };	    virtual int 				operator < (const char* str) const { return (Compare (str) < 0); };	    virtual int 				operator > (const char* str) const { return (Compare (str) > 0); };	    TString& 			operator = (const TString&);	    TString& 			operator = (const char*);	    TString& 			operator = (const char);	    TString& 			operator += (const TString&);	    TString& 			operator += (const char*);	    TString& 			operator += (const char);		virtual TString				operator + (const TString& string) const;						    friend istream& 			operator >> (istream& i, TString& string) { return (string.ReadLine (i)); };   				    virtual istream&			ReadLine (istream&, const long int =0, const char ='\n');							virtual istream& 			ReadToken (istream&, const long int =0, const TString& =" \n\t");		virtual void				Resize (void);				virtual void				SetDelta (const long int incr) { CHECK (0 <= incr); fDelta = incr; };		virtual void				SetLength (const long int len);				virtual void				SetNull (void) { (*this) = ""; };		long int 				Size (void) const { return (fSRepPtr->fSize); };		virtual TString&			ToLower (void);		virtual TString&			ToUpper (void);				virtual ostream&			Write (ostream& o) const { return (Write (o, Length ())); };		virtual ostream&			Write (ostream&, const long int) const;		virtual void				WriteToString (char *, const long int =0) const;			private:		void 						clone (void) { fSRepPtr = new TSRep(*fSRepPtr); };		long int 				nextDelta (long int, long int) const;		static char 				fStaticStr [];								class TSRep		{			public:  				TSRep (const char* ="");				TSRep (const TSRep&);				TSRep (const long int);				TSRep (const char);				~TSRep (void) { delete [] fStr; };							char*						fStr;				long int 				fLength;				long int				fSize;				TCounter					fCounter;		};		TSRep*								fSRepPtr;		long int						fDelta;		char*								fToken;							};class TStringIteratorConst{	friend class TString;	public:		TStringIteratorConst (const TString& string);		~TStringIteratorConst (void);				virtual const char*							CurChar (void) const { return (IthChar (fCurChar)); };		virtual const char&							CurCharRef (void) const { return (IthCharRef (fCurChar)); };		virtual const char*							FirstChar (void) { return (IthChar ((fCurChar = 1))); };		virtual const char&							FirstCharRef (void) { return (IthCharRef ((fCurChar = 1))); };		virtual const char*							IthChar (const long int i) const { return (ithChar (i) ? &fString.IthChar (i) : NULL); };		virtual const char&							IthCharRef (const long int i) const { CHECK_ (ithChar (i)); return (fString.IthChar (i)); };		virtual long int						GetCurCharNumber (void) const { return (ithChar (fCurChar) ? fCurChar : 0); };		virtual long int						GetStringLength (void) const { return (fString.Length ()); };				virtual const char*							LastChar (void) { return (IthChar (fCurChar = fString.Length ())); };		virtual const char&							LastCharRef (void) { return (IthCharRef (fCurChar = fString.Length ())); };		virtual const char*							NextChar (void)  { return (ithChar (fCurChar) ? IthChar (++fCurChar): NULL); };		virtual const char&							NextCharRef (void) { CHECK_ (ithChar (fCurChar)); return (IthCharRef (++fCurChar)); };		virtual const char*							PrevChar (void) { return (ithChar (fCurChar) ? IthChar (--fCurChar): NULL); };		virtual const char&							PrevCharRef (void) { CHECK_ (ithChar (fCurChar)); return (IthCharRef (--fCurChar)); };		protected:		virtual bool								ithChar (const long int i) const { return (0 < i && i <= fString.Length ()); };						const TString&								fString;		long int								fCurChar;};inlineTStringIteratorConst& TString::IteratorConst (void) const{	return (*(new TStringIteratorConst (*this)));}#endif // __TSTRING_H