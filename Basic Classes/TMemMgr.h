#ifndef _MEMMGR_H#define _MEMMGR_H#include <algorithm.h>#include "TChecks.h"class THeaderBlock{	public:    	void* operator new (size_t, size_t);    	void* operator new (size_t);};class TBlockList : public THeaderBlock{	friend class TBaseMemBlocks;	public:		    TBlockList (TBlockList*);		private:	    TBlockList* fNext;	};class TBaseMemBlocks{	public:		    TBaseMemBlocks (size_t = 8192);	    ~TBaseMemBlocks (void);		    char* 						Block (void) const; 	    unsigned int				Count(void) const; 	    int							AllocBlock (size_t);	    void 						FreeTo (unsigned);		protected:	    const size_t 				fBlockSize;		private:	    TBlockList* 				fCurBlock;	    unsigned int				fBlockCount;};class TMemStack : public TBaseMemBlocks{    friend class TMarker;	public:	    TMemStack (size_t = 8192);	    void* 						Allocate (size_t);		private:	    size_t 						fCurLoc;};class TMarker{	public:	    TMarker (TMemStack& ms);		    ~TMarker (void);	        		private:		    const unsigned int 			fBlk;	    const size_t 				fCurLoc;	    TMemStack& 					fMemStk;};class TMemBlocks{	friend class TBMarker;	public:	    TMemBlocks (size_t, unsigned int = 100);		    void* 						Allocate (size_t);	    void 						Free (void*);		private:	    void* 						fFreeList;	    TMemStack 					fMem;	    size_t 						fSize;};class TBMarker{	public:		    TBMarker (TMemBlocks&);	        	    ~TBMarker (void);	     	private:		    const unsigned int			fBlk;	    TMemStack& 					fMemStk;};inlinevoid* THeaderBlock::operator new (size_t sz, size_t extra){    return (::operator new (sz + extra));}inlinevoid* THeaderBlock::operator new (size_t){    CHECK_ (0);    return (0);}inlineTBlockList::TBlockList (TBlockList* next) 	:	fNext (next){}inlinechar* TBaseMemBlocks::Block (void) const{	return ((char*)fCurBlock); }inlineunsigned int TBaseMemBlocks::Count (void) const{	return (fBlockCount); }inlineTBaseMemBlocks::TBaseMemBlocks( size_t sz ) :    fCurBlock (0),    fBlockCount (0),    fBlockSize (sz){    CHECK_ (sz);}inlineTBaseMemBlocks::~TBaseMemBlocks (void){//#if !defined( WINDOWS_WEP_BUG )    FreeTo (0);//#endif}inlinevoid* operator new (size_t sz, TMemStack& m){    return m.Allocate (sz);}inlineTMemStack::TMemStack (size_t sz) 	:	TBaseMemBlocks (sz),    	fCurLoc (sz){}inlineTMarker::TMarker (TMemStack& ms) 	:	fMemStk (ms),    	fBlk (ms.Count ()),    	fCurLoc (ms.fCurLoc){}inlineTMemBlocks::TMemBlocks (size_t sz, unsigned int count) 	:	fMem (sz*count),    	fFreeList (0),    	fSize (max (sz , (size_t)(sizeof(void*)))){}inlinevoid* TMemBlocks::Allocate (size_t sz){    CHECK_ (fSize == max (sz, (size_t)(sizeof (void*))));    if (fFreeList == 0)        return (fMem.Allocate (fSize));    void* temp = fFreeList;    fFreeList = *(void**)temp;    return (temp);}        inline void TMemBlocks::Free (void* block){	*(void**)block = fFreeList;    fFreeList = block;}inlineTBMarker::TBMarker (TMemBlocks& mb) 	:		fMemStk (mb.fMem),	  	fBlk (mb.fMem.Count ()){}	        inline	TBMarker::~TBMarker (void){	        	CHECK_ (fBlk <= fMemStk.Count ());	fMemStk.FreeTo (fBlk);}#endif  // _TMEMMGR_H