#ifndef _TBITSET_H#define _TBITSET_H#include "TString.h"#include "TSortable.h"#include "TChecks.h"#include "TArray.h"#include "TFlags.h"#include <algorithm.h>// JLT 010412// to do use TContainerArray class// where allocated as blocktypedef int BitNumber;// the number of bits per intstatic const BitNumber kNumberBits = 16;							// the number of blocks (unsigned short ints) required to accomodate the maximum number of elementstypedef int BlockNumber;// the array of blocks into which the elements are stored//extern const unsigned short int gBits[kNumberBits];static const unsigned short int gBits[kNumberBits] =	{0x0001,0x0002,0x0004,0x0008,												 		0x0010,0x0020,0x0040,0x0080,							 					 		0x0100,0x0200,0x0400,0x0800,												 		0x1000,0x2000,0x4000,0x8000};#define 	TBITSET_FLAG_CARDINALITYUPDATED 		0x0001#define 	TBITSET_FLAG_LASTELEMENTUPDATED 		0x0002template<unsigned int N>class TBitSet : public TSortable, protected TFlags{	public:				TBitSet (const unsigned int = 0);				TBitSet (const TBitSet<N>&);				virtual ~TBitSet (void) { };				virtual void 						AddToThis (const TBitSet<N>& bitSet);		virtual void 						AddToThis (const unsigned int n);				virtual BlockNumber					Blocks (void) const { return (fSet.Size ()); };		virtual unsigned int				GetSize (void) const; 			virtual ClassType					Class (void) const { return (kTBitSetClass); };		virtual TObject*					Clone (void) const { return (new TBitSet<N> (*this)); };		virtual int 						Compare (const TSortable& obj) const;		virtual void						Complement (TBitSet<N>& bitSet, const unsigned int n = N) const;		virtual void	 					Copy (const TObject& bitSet);			virtual unsigned int				CurElement (void) const { return (fCurrentElement); };					virtual void 						SubtractFromThis (const TBitSet<N>& bitSet);		virtual void 						SubtractFromThis (const unsigned int n);		virtual void 						SetEmpty (void);		virtual unsigned int  				FirstElement (void) const;		virtual void 						SetFull (const unsigned int n = N);    	virtual HashValue					Hash (void) const;		virtual void 						Intersection (const TBitSet<N>& bitSet, TBitSet<N>& intersection) const;						virtual void						IntersectWithThis (const TBitSet<N>& bitSet);		virtual void						IntersectWithThis (const unsigned int element);				virtual bool 						IsSequential (void) const;		virtual bool 						IsDisjoint (const TBitSet<N>& bitSet) const;		virtual bool						IsElement (const unsigned int) const;		virtual bool						IsEmpty (void) const { return ((bool)(GetSize() == 0)); };		virtual bool						IsEqual (const TObject& obj) const;		virtual bool						IsSubset (const TBitSet<N>& bitSet) const;		virtual bool						IsSuperset (const TBitSet<N>& bitSet) const;				virtual unsigned int				NumberOfElement (const unsigned int n) const;			virtual unsigned int  				IthElement (const unsigned int n) const;		virtual unsigned int				LastElement (void) const;		virtual unsigned int  				NextElement (void) const;		virtual unsigned int  				NextElement (unsigned int n) const;		virtual TBitSet<N>& 				operator = (const TBitSet<N>& bitSet);		virtual TBitSet<N>&					operator += (const TBitSet<N>& bitSet);							virtual TBitSet<N>&					operator += (const unsigned int element);							virtual TBitSet<N>&					operator *= (const TBitSet<N>& bitSet);							virtual TBitSet<N>&					operator *= (const unsigned int element);							virtual TBitSet<N>&					operator -= (const TBitSet<N>& bitSet);							virtual TBitSet<N>&					operator -= (const unsigned int element);							virtual TBitSet<N>					operator + (const TBitSet<N>& bitSet) const;							virtual TBitSet<N>					operator * (const TBitSet<N>& bitSet) const;							virtual TBitSet<N>					operator - (const TBitSet<N>& bitSet) const;							virtual unsigned int  				PrevElement (void) const;		virtual unsigned int  				PrevElement (unsigned int n) const;		 		virtual SetRelations 				Relationship (const TBitSet<N>& bitSet) const;							virtual void 						SetDifference (const TBitSet<N>& bitSet, TBitSet<N>& setDifference) const;		virtual void 						Union (const TBitSet<N>& bitSet, TBitSet<N>& setUnion) const;		virtual ostream& 					Write (ostream& o) const;			protected:		virtual unsigned int				lastElement (void) const;		TArray<unsigned short> 				fSet;			unsigned int						fCurrentElement;		unsigned int						fSize;		unsigned int						fLastElement;		};//Add another set to the settemplate<unsigned int N>void TBitSet<N>::AddToThis (const TBitSet<N>& bitSet){	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);		for (BlockNumber i = 0; i < Blocks (); ++i)		fSet[i] = fSet[i] | bitSet.fSet[i];		if (IsFlag (TBITSET_FLAG_LASTELEMENTUPDATED))		fLastElement = max (fLastElement, bitSet.lastElement ());}//Add element i to the settemplate<unsigned int N>void TBitSet<N>::AddToThis (const unsigned int n){	CHECK_ (n);		SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);	BitNumber m = n % kNumberBits;	BlockNumber j = n / kNumberBits;		fSet[j] = fSet[j] | gBits[m];	fLastElement = max (fLastElement, n);}// Return the number of elements in the set// change so only has to calculate if certain opertations have been performed// this will massively increase efficiency......template<unsigned int N>unsigned int TBitSet<N>::GetSize (void) const{	if (!IsFlag (TBITSET_FLAG_CARDINALITYUPDATED))	{		((TBitSet<N>*)this)->fSize = 0;		for (BlockNumber i = 0; i < Blocks (); i++)			if (fSet[i] != 0)				for (BitNumber j = 0; j < kNumberBits; j++)					if ((fSet[i] & gBits[j]) == gBits[j])					 	((TBitSet<N>*)this)->fSize += 1;		SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);	}	return (fSize);}template<unsigned int N>void TBitSet<N>::Copy (const TObject& obj){	CHECK (Class () == obj.Class ());		const TBitSet<N>& bitSet = (const TBitSet<N>&) obj;	fSet = bitSet.fSet;	fCurrentElement = bitSet.fCurrentElement;	fSize = bitSet.GetSize ();	fLastElement = bitSet.lastElement ();	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);}// if *this is less than arg (*this < arg) then this->Compare (arg) should be less than 0 (return -1)// if greater then return 1 and if equal return 0// smallest cardinality < larger cardinality// if same cardinality then compare order of elements where disagree// element present < element absenttemplate<unsigned int N>int TBitSet<N>::Compare (const TSortable& sortable) const{	CHECK (Class () == sortable.Class ());	const TBitSet<N>& bitSet = (const TBitSet<N>&) sortable;		if (GetSize () != bitSet.GetSize ()) 	{		if (GetSize () < bitSet.GetSize ())			return (-1);		return (1);	}					BlockNumber i;	for (i=0; i < Blocks (); i++) 	{		if (fSet[i] != bitSet.fSet[i])		{			for ( BitNumber j = 0; j < kNumberBits; j++) 			{				if ((fSet[i] & gBits[j]) != (bitSet.fSet[i] & gBits[j]))				{					if (fSet[i] & gBits[j])						return (-1);					return (1);				}			}  		}  	}	return (0);}template<unsigned int N>void TBitSet<N>::Complement (TBitSet<N>& bitSet, const unsigned int n) const{		bitSet.SetFull (n);	bitSet.SubtractFromThis (*this);}template<unsigned int N>void TBitSet<N>::SubtractFromThis (const TBitSet<N>& bitSet){		for (BlockNumber i = 0; i < Blocks(); i++)		fSet[i] &= ~( bitSet.fSet[i]);	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, false);}template<unsigned int N>void TBitSet<N>::SubtractFromThis (const unsigned int n){	CHECK_ (n);		BitNumber m = n % kNumberBits;	BlockNumber j = n / kNumberBits;		fSet[j] = fSet[j] & (~gBits[m]); 	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, false);}template<unsigned int N>unsigned int TBitSet<N>::NumberOfElement (const unsigned int n) const{	if (IsElement (n))	{		unsigned int count = 0;		unsigned int i = 0;		while (i != n)			if (IsElement (++i))				++count;		return (count);			}	return (0);}template<unsigned int N>void TBitSet<N>::SetEmpty (void){	for (BlockNumber i = 0; i < Blocks (); i++)		fSet[i] = 0;	fSize = fLastElement = 0;	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);}template<unsigned int N>unsigned int TBitSet<N>::FirstElement (void) const{    ((TBitSet<N>*)this)->fCurrentElement = 0;      do 	{		if (N < (((TBitSet<N>*)this)->fCurrentElement += 1))			return (((TBitSet<N>*)this)->fCurrentElement = 0);	} while (!IsElement (fCurrentElement));	return (fCurrentElement);}template<unsigned int N>void TBitSet<N>::SetFull (const unsigned int n){	SetEmpty ();	for (unsigned int i = 1; i <= n; i++)		AddToThis (i);		fSize = fLastElement = n;	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);}template<unsigned int N>HashValue TBitSet<N>::Hash (void) const{	HashValue hcode = 0;	for (BlockNumber i = 0; i < Blocks (); i++)		hcode += (fSet[i]);	return (hcode);}template<unsigned int N>void TBitSet<N>::Intersection (const TBitSet<N>& bitSet, TBitSet<N>& intersection) const{	for (BlockNumber i = 0; i < Blocks (); i++)		intersection.fSet[i] = fSet[i] & bitSet.fSet[i];	intersection.SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);	intersection.SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, false);}template<unsigned int N>void TBitSet<N>::IntersectWithThis (const TBitSet<N>& bitSet){	for (BlockNumber i = 0; i < Blocks(); i++)		fSet[i] &= bitSet.fSet[i];	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, false);}template<unsigned int N>void TBitSet<N>::IntersectWithThis (const unsigned int element){	if (IsElement (element))	{		SetEmpty ();		AddToThis (element);		fSize = 1;		fLastElement = element;		}	else	{		SetEmpty ();		fSize = fLastElement = 0;	}	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);	}template<unsigned int N>inlinebool TBitSet<N>::IsSequential (void) const{	return ((bool)(GetSize () && LastElement () == GetSize ()));}template<unsigned int N>bool TBitSet<N>::IsDisjoint (const TBitSet<N>& bitSet) const{	TBitSet<N> i;	Intersection (bitSet, i);    return (i.IsEmpty ());}//True if i in settemplate<unsigned int N>bool TBitSet<N>::IsElement (const unsigned int n) const{	CHECK_ (n);		BitNumber m = n % kNumberBits;				// refers to bit within the integer corresponding to the element	BlockNumber j = n / kNumberBits;			// refers to integer in the set which contains bit corrresponding to the element		return ((bool)((fSet[j] & gBits[m]) == gBits[m]));}template<unsigned int N>bool TBitSet<N>::IsEqual (const TObject& obj) const{	CHECK (Class () == obj.Class ());	const TBitSet<N>& bitSet = (const TBitSet<N>&)obj;	BlockNumber i;	for (i = 0; i < Blocks () ; ++i)		if (fSet[i] != bitSet.fSet[i])			break;		return ((bool)(i == Blocks ()));}// True if set is subset of btemplate<unsigned int N>bool TBitSet<N>::IsSubset (const TBitSet<N>& bitSet) const{	TBitSet<N> u;	Union (bitSet, u);	return ((bool)(bitSet.GetSize () == u.GetSize ()));}// True if set is superset of btemplate<unsigned int N>bool TBitSet<N>::IsSuperset (const TBitSet<N>& bitSet) const{	TBitSet<N> u;	Union (bitSet, u);	return ((bool)(GetSize () == u.GetSize ()));}template<unsigned int N>unsigned int TBitSet<N>::IthElement (const unsigned int n) const{	CHECK_ (n);		unsigned int count = 0;	unsigned int i = 0;	while (count != n && i < N)	{		if (IsElement (++i)) 			++count;	}    if (count == n)     	return (i);	return (0);}template<unsigned int N>inlineunsigned int TBitSet<N>::LastElement (void) const{	return (((TBitSet<N>*)this)->fCurrentElement = lastElement ());}template<unsigned int N>unsigned int TBitSet<N>::lastElement (void) const{	if (!IsFlag (TBITSET_FLAG_LASTELEMENTUPDATED))	{		((TBitSet<N>*)this)->fLastElement = 0;		unsigned int cardinality = GetSize ();		while (cardinality)			if (IsElement (((TBitSet<N>*)this)->fLastElement += 1))				--cardinality;		SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);	}	return (fLastElement);}template<unsigned int N>unsigned int TBitSet<N>::NextElement (void) const{	if (CurElement ())	{		do		{			if (N < (((TBitSet<N>*)this)->fCurrentElement += 1))				return (((TBitSet<N>*)this)->fCurrentElement = 0);		} while (!IsElement (fCurrentElement));		return (fCurrentElement);	}	return (0);}template<unsigned int N>unsigned int TBitSet<N>::NextElement (unsigned int n) const{		do 	{		if (N < ++n)			return (0);	} while (!IsElement (n));	return (n);}template<unsigned int N>unsigned int TBitSet<N>::PrevElement (void) const{		if (CurElement ())	{		do 		{			if (!(((TBitSet<N>*)this)->fCurrentElement -= 1))				return (((TBitSet<N>*)this)->fCurrentElement = 0);		} while (!IsElement (fCurrentElement));		return (fCurrentElement);	}	return (0);}template<unsigned int N>unsigned int TBitSet<N>::PrevElement (unsigned int n) const{	CHECK_ (n);	do 	{		if (!(--n))			return (0);	} while (!IsElement (n));	return (n);}template<unsigned int N>TBitSet<N>& TBitSet<N>::operator  = (const TBitSet<N>& bitSet){	fSet = bitSet.fSet;	fCurrentElement = bitSet.fCurrentElement;	fSize = bitSet.GetSize ();	fLastElement = bitSet.lastElement ();	SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);		SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);		return (*this);}template<unsigned int N>TBitSet<N>& TBitSet<N>::operator += (const TBitSet<N>& bitSet){	AddToThis (bitSet);	return (*this);}					template<unsigned int N>TBitSet<N>& TBitSet<N>::operator += (const unsigned int element){	AddToThis (element);	return (*this);}template<unsigned int N>TBitSet<N>& TBitSet<N>::operator *= (const TBitSet<N>& bitSet){	IntersectWithThis (bitSet);	return (*this);}template<unsigned int N>TBitSet<N>& TBitSet<N>::operator *= (const unsigned int element){	IntersectWithThis (element);	return (*this);}					template<unsigned int N>TBitSet<N>& TBitSet<N>::operator -= (const TBitSet<N>& bitSet){	SubtractFromThis (bitSet);	return (*this);}template<unsigned int N>TBitSet<N>& TBitSet<N>::operator -= (const unsigned int element){	SubtractFromThis (element);	return (*this);}template<unsigned int N>TBitSet<N> TBitSet<N>::operator+ (const TBitSet<N>& bitSet) const{	TBitSet<N> s;    Union (bitSet, s);	return (s);}template<unsigned int N>TBitSet<N> TBitSet<N>::operator* (const TBitSet<N>& bitSet) const{	TBitSet<N> s;    Intersection (bitSet, s);	return (s);}template<unsigned int N>TBitSet<N> TBitSet<N>::operator- (const TBitSet<N>& bitSet) const{	TBitSet<N> s;	SetDifference (bitSet, s);	return (s);}/*template<unsigned int N>void TBitSet<N>::ReadFromString (const char*) {	char *q, *r;    unsigned int i, j, k;	SetEmpty(); // Clear the set	q = strtok (s(), " ");	while (q)	{		r = strchr (q, '-');		if (r)		{			r++;			i = atoi (q);			j = atoi (r);			for (k=i;k<=j;k++)			{				AddToThis(k);            }		}		else		{          AddToThis(atoi(q));		}		q = strtok (NULL, " ");     }}*/// Relationship of set relative to btemplate<unsigned int N>SetRelations TBitSet<N>::Relationship (const TBitSet<N>& bitSet) const{	if (IsEqual (bitSet)) 		return (identity);												//identity	if (IsDisjoint (bitSet)) 		return (disjoint);											// sets are disjoint	if (IsSubset (bitSet)) 		return (subset);												// a subset of b	if (IsSuperset (bitSet)) 		return (superset);											// a superset of b	return (overlapping);															// sets overlap}template<unsigned int N>void TBitSet<N>::SetDifference (const TBitSet<N>& bitSet, TBitSet<N>& setDifference) const{	for (BlockNumber i = 0; i < Blocks(); i++)		setDifference.fSet[i] = fSet[i] & ~( bitSet.fSet[i]);	setDifference.SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);		setDifference.SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, false);	}template<unsigned int N>TBitSet<N>::TBitSet (const unsigned int n)	: fSet ((N/kNumberBits) + 1){		for (BlockNumber i = 0; i < Blocks (); i++)		fSet[i] = 0;	for (unsigned int i = 1; i <= n; i++)	{		BitNumber m = i % kNumberBits;		BlockNumber j = i / kNumberBits;		fSet[j] = fSet[j] | gBits[m];	}		fCurrentElement = 0;				fSize = fLastElement = n;			SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);}template<unsigned int N>TBitSet<N>::TBitSet (const TBitSet<N>& bitSet)	: fSet (bitSet.fSet){	fCurrentElement = bitSet.fCurrentElement;		fSize = bitSet.GetSize ();		fLastElement = bitSet.lastElement ();		SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, true);	SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, true);}template<unsigned int N>void TBitSet<N>::Union (const TBitSet<N>& bitSet, TBitSet<N>& setUnion) const{	for (BlockNumber i = 0; i < Blocks(); i++)		setUnion.fSet[i] = fSet[i] | bitSet.fSet[i];	setUnion.SetFlag (TBITSET_FLAG_CARDINALITYUPDATED, false);	setUnion.SetFlag (TBITSET_FLAG_LASTELEMENTUPDATED, false);}template<unsigned int N>ostream& TBitSet<N>::Write (ostream& o) const{	unsigned int count = 0;	unsigned int start = FirstElement ();	bool bol = true;		while (count < GetSize ())	{		while (!IsElement (start))			++start;		unsigned int end = start + 1;				unsigned int k = 1;		while (IsElement (end))		{			end++;			k++;		}		if (bol)		{			o << start;			bol = false;		}		else			o << ' ' << start;		if (k == 2)			o << ' ' << end - 1;		else if (k > 2)			o << '-' << end - 1;				start = end;				count += k; 	}	return (o);}#endif  // _TBITSET_H