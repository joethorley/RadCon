#ifndef __TCOUNTER_H#define __TCOUNTER_H#include "TSortable.h"#include "TChecks.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TCounter ___#endifclass TCounter : public TSortable{	public:		TCounter (const unsigned short count = 0, const unsigned short maxCount = USHRT_MAX);		TCounter (const TCounter& counter);		virtual ~TCounter (void);				virtual ClassType			Class (void) const { return (kTCounterClass); };		virtual TObject*			Clone (void) const { return (new TCounter (*this)); };		virtual int					Compare (const TSortable& sortable) const;		virtual void				Copy (const TObject& obj);		virtual unsigned short			Decr (void) { CHECK_ (fCount != 0); return (--fCount); };		virtual unsigned short			Decr (const unsigned short count);		virtual unsigned short			GetCount (void) const { return (fCount); };		virtual unsigned short			GetMaxCount (void) { return (fMaxCount); };    	virtual HashValue			Hash (void) const { return (fCount); };				virtual unsigned short			Incr (void) { CHECK_ (fCount != fMaxCount); return (++fCount); };		virtual unsigned short			Incr (const unsigned short count);    	virtual bool 				IsEqual (const TObject& obj) const { CHECK_ (Class () == obj.Class ()); return (fCount == ((const TCounter&)obj).fCount); };		virtual bool				IsZero (void) const { return (!fCount); };		virtual TCounter&			operator = (const TCounter& counter);		virtual void				Reset (void) { fCount = 0; };				virtual void				SetCount (const unsigned short count) { CHECK_ (0 <= count && count <= fMaxCount); fCount = count; };		virtual void				SetMaxCount (const unsigned short count) { CHECK_ (fCount <= count); fMaxCount = count; };		  		virtual ostream&			Write (ostream& o) const { return (o << fCount); };		protected:		unsigned short					fCount;		unsigned short					fMaxCount;	};#endif // __TCOUNTER_H#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif