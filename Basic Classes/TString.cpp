#include "TString.h"char TString::fStaticStr [kMaxStringLength+1];TString::TSRep::TSRep (const char* str){	CHECK (str);	fCounter.Incr ();	fLength = strlen (str);                         			fSize = fLength + 1;  	fStr = new char [fSize];                       	strcpy (fStr, str);                        }TString::TSRep::TSRep (const TSRep& tSRep){	fCounter.Incr ();	fLength = tSRep.fLength;	fSize = tSRep.fSize;	fStr = new char [fSize];	strcpy (fStr, tSRep.fStr);}TString::TSRep::TSRep (const long int n){	fCounter.Incr ();  	fLength = 0;                         		  	fSize = n + 1;  	fStr = new char [fSize];                       	fStr[fLength] = '\0';                               	}TString::TSRep::TSRep (const char ch){	fCounter.Incr ();	fLength = 1;                         		  	fSize = fLength + 1;  	fStr = new char [fSize];                       	fStr[0] = ch; 	fStr[fLength] = '\0';                               }void TString::AddToThis (const TString& string){	const long int newLength = fSRepPtr->fLength + string.fSRepPtr->fLength;	if(fSRepPtr->fCounter.GetCount () > 1)	{							//disconnect self		fSRepPtr->fCounter.Decr ();		if(fDelta != 0)		{			TSRep* p = fSRepPtr;			fSRepPtr = new TSRep (newLength);			strcpy(fSRepPtr->fStr,p->fStr);			fSRepPtr->fLength = p->fLength;		}		else			clone();	}	const long int nextdelta = nextDelta((newLength - (fSRepPtr->fSize -1)),fDelta);	if(nextdelta != 0)	{	// increase length and copy original string		fSRepPtr->fSize += nextdelta;		char* newArray = new char [fSRepPtr->fSize];		strcpy(newArray,fSRepPtr->fStr);		delete [] fSRepPtr->fStr;		fSRepPtr->fStr = newArray;	}	if(newLength < fSRepPtr->fSize)	{		strcat(fSRepPtr->fStr,string.fSRepPtr->fStr);		fSRepPtr->fLength = newLength;		return;	}	strncat(fSRepPtr->fStr,string.fSRepPtr->fStr,newLength - fSRepPtr->fLength);	fSRepPtr->fLength = fSRepPtr->fSize-1;	fSRepPtr->fStr[fSRepPtr->fLength] = '\0';}void TString::AddToThis (const char* str){	const long int newLength = fSRepPtr->fLength + strlen(str);	if(fSRepPtr->fCounter.GetCount () > 1)	{							//disconnect self		fSRepPtr->fCounter.Decr ();		if(fDelta != 0)		{			TSRep* p = fSRepPtr;			fSRepPtr = new TSRep (newLength);			strcpy(fSRepPtr->fStr,p->fStr);			fSRepPtr->fLength = p->fLength;		}		else			clone();	}	const long int nextdelta = nextDelta((newLength - (fSRepPtr->fSize -1)),fDelta);	if(nextdelta != 0)	{	// increase length and copy original string		fSRepPtr->fSize += nextdelta;		char* newArray = new char [fSRepPtr->fSize];		strcpy(newArray,fSRepPtr->fStr);		delete [] fSRepPtr->fStr;		fSRepPtr->fStr = newArray;	}	if(newLength < fSRepPtr->fSize)	{		strcat(fSRepPtr->fStr,str);		fSRepPtr->fLength = newLength;		return;	}	strncat(fSRepPtr->fStr,str,newLength - fSRepPtr->fLength);	fSRepPtr->fLength = fSRepPtr->fSize-1;	fSRepPtr->fStr[fSRepPtr->fLength] = '\0';}void TString::AddToThis (const char ch){	const long int newLength = fSRepPtr->fLength + 1;	if(fSRepPtr->fCounter.GetCount () > 1)	{							//disconnect self		fSRepPtr->fCounter.Decr ();		if(fDelta != 0)		{			TSRep* p = fSRepPtr;			fSRepPtr = new TSRep (newLength);			strcpy(fSRepPtr->fStr,p->fStr);			fSRepPtr->fLength = p->fLength;		}		else			clone();	}	const long int nextdelta = nextDelta((newLength - (fSRepPtr->fSize -1)),fDelta);	if(nextdelta != 0)	{			fSRepPtr->fSize += nextdelta;		char* newArray = new char [fSRepPtr->fSize];		strcpy(newArray,fSRepPtr->fStr);		delete [] fSRepPtr->fStr;		fSRepPtr->fStr = newArray;	}	if(newLength < fSRepPtr->fSize)	{		fSRepPtr->fLength = newLength;		fSRepPtr->fStr[fSRepPtr->fLength-1] = ch;		fSRepPtr->fStr[fSRepPtr->fLength] = '\0';	}}// probably need to add options for controlling...void TString::AddToThis (const float fl, const unsigned int precision){	switch (precision)	{		case 0:			sprintf (fStaticStr, "%.0f", fl);			break;		case 1:			sprintf (fStaticStr, "%.1f", fl);			break;		case 2:			sprintf (fStaticStr, "%.2f", fl);			break;		case 3:			sprintf (fStaticStr, "%.3f", fl);			break;		case 4:			sprintf (fStaticStr, "%.4f", fl);			break;		case 5:			sprintf (fStaticStr, "%.5f", fl);			break;		case 6:			sprintf (fStaticStr, "%.6f", fl);			break;		default:			sprintf (fStaticStr, "%f", fl);			break;	}	AddToThis (fStaticStr);}void TString::AddToThis (const long int li){	sprintf (fStaticStr, "%li", li);	AddToThis (fStaticStr);}void TString::AddToThis (const int i){	sprintf (fStaticStr, "%d", i);	AddToThis (fStaticStr);}void TString::AddToThis (const unsigned int u){	sprintf (fStaticStr, "%u", u);	AddToThis (fStaticStr);}void TString::AddToThis (const unsigned long int ul){	sprintf (fStaticStr, "%u",ul);	AddToThis (fStaticStr);}int TString::Compare (const TSortable& sortable) const{	CHECK (Class () == sortable.Class ());	const TString& string = (const TString&) sortable;	return (strcmp (fSRepPtr->fStr, string.fSRepPtr->fStr));}void TString::Copy (const TObject& obj){	CHECK (Class () == obj.Class ());		const TString& string = (const TString&)obj;		if(fSRepPtr != string.fSRepPtr)	{		if(fDelta!=0 || fSRepPtr->fSize == string.fSRepPtr->fSize)		{			if(fSRepPtr->fCounter.Decr () == 0)				delete fSRepPtr;			fSRepPtr = string.fSRepPtr;			fSRepPtr->fCounter.Incr ();			return;		}		if (fSRepPtr->fCounter.GetCount () > 1)		{			fSRepPtr->fCounter.Decr ();			clone();		}					if (string.fSRepPtr->fLength < fSRepPtr->fSize)		{ 					strcpy (fSRepPtr->fStr, string.fSRepPtr->fStr);			fSRepPtr->fLength = string.fSRepPtr->fLength;			return;		}		strncpy(fSRepPtr->fStr, string.fSRepPtr->fStr, fSRepPtr->fSize-1);		fSRepPtr->fLength = fSRepPtr->fSize-1;		fSRepPtr->fStr[fSRepPtr->fLength] = '\0';			}}HashValue TString::Hash (void) const{	CHECK_ (0);	return (0);}// this function needs improving...bool TString::IsInteger (void) const{	const bool sign = (bool) (fSRepPtr->fStr[0] == '-' || fSRepPtr->fStr[0] == '+');	if (sign && (fSRepPtr->fLength == 1 || fSRepPtr->fLength > 6))		return (false);	else if (!sign && fSRepPtr->fLength > 5)		return (false);		int i = 0;	if (sign)		++i;	while (i < fSRepPtr->fLength)	{		if (!(isdigit (fSRepPtr->fStr[i++])))			return (false);	}	return (true);}bool TString::IsToken (const TString& set) const{	CHECK_ (!IsNull ());	return (!IsFindCharacters (set));}bool TString::IsEqual (const TObject& obj) const{	CHECK (Class () == obj.Class ());	const TString& string = (const TString&)obj;	return ((bool)((strcmp (fSRepPtr->fStr, string.fSRepPtr->fStr)) == 0));}bool TString::IsFloat (void) const{	bool b = false;	int i = 0;	while (IthChar (++i))	{		if (!isdigit (IthChar (i)))		{			if (b && IthChar (i) == '.')			{				b = false;				while (IthChar (++i))				{					if (!isdigit (IthChar (i)))						return (false);					b = true;				}				return (b);			}			return (b);		}		b = true;	}	return (b);}bool TString::IsFraction (void) const{	int i = 0;	for (; i < fSRepPtr->fLength; ++i)	{		if (!isdigit (fSRepPtr->fStr[i]))		{			if (fSRepPtr->fStr[i] == '/')				break;			else				return (false);		}	}	if (5 < i)		return (false);	int ii = ++i;	for (;ii < fSRepPtr->fLength; ++ii)	{		if (!isdigit (fSRepPtr->fStr[ii]))			return (false);	}	if (5 < (ii-i))		return (false);	return (true);}char& TString::IthChar (const long int i){	if(fSRepPtr->fCounter.GetCount () > 1)	{		fSRepPtr->fCounter.Decr ();		clone();	}	return (fSRepPtr->fStr[i-1]);}const char& TString::IthChar (const long int i) const{	CHECK (0 < i && i <= fSRepPtr->fLength + 1);	return (fSRepPtr->fStr[i-1]);}// converts string of "int/int" or "int" to floatdouble TString::FractionToDouble (void) const{	CHECK (IsFraction ());	char* slash = strchr (fSRepPtr->fStr,'/');	if (slash != NULL)		*slash = '\0';	const int numerator = atoi (fSRepPtr->fStr);	int denominator = 1;	if (slash != NULL)	{		*slash = '/';		denominator = atoi (slash + 1);	}	return ((double)numerator / (double)denominator);}		const char* TString::FindNotCharacter (const char ch) const{	for (long int n = 0; n < fSRepPtr->fLength; ++n)		if (fSRepPtr->fStr[n] != ch)			return (&fSRepPtr->fStr[n]);	return (NULL);}const char* TString::FindNotCharacters (const TString& set) const{	for (long int n = 0; n < fSRepPtr->fLength; ++n)		if (!set.FindCharacter (fSRepPtr->fStr[n]))			return (&fSRepPtr->fStr[n]);	return (NULL);}// where the first argument is the difference between the new length// and the maximum length of the TString i.e. fSize-1 long int TString::nextDelta (long int n, long int delta) const{	if(n <= 0 || delta == 0)		return (0);	return (n%delta) ? ((n+delta)/delta)*delta : n;}char* TString::Array (void){	if(fSRepPtr->fCounter.GetCount () > 1)	{		fSRepPtr->fCounter.Decr ();		clone();	}	return (fSRepPtr->fStr);}TString& TString::operator = (const TString& string){	Copy (string); //change so that separate...	return (*this);}TString& TString::operator = (const char* str){	const long int newLength = strlen(str);	if(fSRepPtr->fCounter.GetCount () > 1)	{							//disconnect self		fSRepPtr->fCounter.Decr ();		if(fDelta != 0)		{			fSRepPtr = new TSRep (str);			return (*this);		}		clone();	}	const long int nextdelta = nextDelta((newLength - (fSRepPtr->fSize -1)),fDelta);	if(nextdelta != 0)	{		fSRepPtr->fSize += nextdelta;		delete [] fSRepPtr->fStr;		fSRepPtr->fStr = new char [fSRepPtr->fSize];	}	if(newLength < fSRepPtr->fSize)	{		strcpy(fSRepPtr->fStr,str); 				fSRepPtr->fLength = newLength;		return (*this);	}	strncpy(fSRepPtr->fStr,str,fSRepPtr->fSize-1);	fSRepPtr->fLength = fSRepPtr->fSize-1;	fSRepPtr->fStr[fSRepPtr->fLength] = '\0';	return (*this);}TString& TString::operator = (const char ch){	if(fSRepPtr->fCounter.GetCount () > 1)	{							//disconnect self		fSRepPtr->fCounter.Decr ();		if(fDelta != 0)		{			fSRepPtr = new TSRep(ch);			return (*this);		}		clone();	}	const long int nextdelta = nextDelta((1 - (fSRepPtr->fSize -1)),fDelta);	if(nextdelta != 0)	{   // increase length		fSRepPtr->fSize += nextdelta;		delete [] fSRepPtr->fStr;		fSRepPtr->fStr = new char [fSRepPtr->fSize];	}	if(1 < fSRepPtr->fSize)	{		fSRepPtr->fLength = 1;		fSRepPtr->fStr[0] = ch;		fSRepPtr->fStr[fSRepPtr->fLength] = '\0';	}	return (*this);}TString& TString::operator += (const TString& string){	AddToThis (string);	return (*this);}TString& TString::operator += (const char* str){	AddToThis (str);	return (*this);}TString& TString::operator += (const char ch){	AddToThis (ch);	return (*this);}TString TString::operator  + (const TString& string) const{	 TString s (*this);	 s.AddToThis (string);	 return (s);}					//reads tokens up to max length seperated by characters in setistream& TString::ReadToken (istream &i, const long int n, const TString& set){	CHECK (!set.IsNull());	CHECK (n<kMaxStringLength);	char ch;			while(i.get (ch))		if (strchr (set.Array (), ch) == NULL)			break;		long int length;	for(length=0;!i.eof() && length < n;i.get(ch),++length)	{		if (strchr (set.Array (), ch))			break;		fStaticStr[length] = ch;	} 	fStaticStr[length] = '\0';	(*this) = fStaticStr;	return(i);}istream& TString::ReadLine (istream &i, const long int n, const char ch){		CHECK (n < kMaxStringLength);		if(!n)		i.getline(fStaticStr,kMaxStringLength + 1,ch);	else		i.getline(fStaticStr,n + 1,ch);	(*this) = fStaticStr;		return (i);}		void TString::Resize (void){	if(fSRepPtr->fLength < fSRepPtr->fSize -1)	{		if(fSRepPtr->fCounter.GetCount () > 1)		{				fSRepPtr->fCounter.Decr ();			TSRep* p = fSRepPtr;			fSRepPtr = new TSRep (p->fLength);			strcpy(fSRepPtr->fStr,p->fStr);			fSRepPtr->fLength = p->fLength;			return;		}		char* newArray = new char [fSRepPtr->fLength];		strcpy(newArray,fSRepPtr->fStr);		delete[] fSRepPtr->fStr;		fSRepPtr->fStr = newArray;		fSRepPtr->fSize = fSRepPtr->fLength +1;	}}void TString::SetLength (const long int len){	CHECK_ (len);	if (len != Length ())	{		if(fSRepPtr->fCounter.GetCount () > 1)		{			fSRepPtr->fCounter.Decr ();			clone();		}		if (len < Length ())		{			fSRepPtr->fStr[len] = '\0';			fSRepPtr->fLength = len;		}		else // Length () < length		{			long int diff = len - Length (); 			TString string (diff);			while (diff--)				string.AddToThis (' '); // could be better to use fill function...			AddToThis (string);		}	}}		// not sure how safe this function is ??int TString::ToInteger (void) const{	CHECK (IsInteger ());	return ((int) strtol (fSRepPtr->fStr, (char**) NULL,10));}TString& TString::ToLower (void){	if(fSRepPtr->fCounter.GetCount () > 1)	{				fSRepPtr->fCounter.Decr ();		clone();	}	for(long int n = 0;n < fSRepPtr->fLength;++n)		fSRepPtr->fStr[n] = tolower(fSRepPtr->fStr[n]);	return (*this);}double TString::ToDouble (void) const{	CHECK (IsFloat ());	return (strtod (fSRepPtr->fStr, (char**) NULL));}TString& TString::ToUpper (void){	if(fSRepPtr->fCounter.GetCount () > 1)	{						fSRepPtr->fCounter.Decr ();		clone();	}	for(long int n = 0;n < fSRepPtr->fLength;++n)		fSRepPtr->fStr[n] = toupper(fSRepPtr->fStr[n]);	return (*this);}TString::TString (const char *str, const long int incr){	CHECK (0 <= incr);  	fSRepPtr = new TSRep (str);	fDelta = incr;}TString::TString (const long int n, const long int incr)		{	CHECK (0 <= incr); 	fSRepPtr = new TSRep (n);	fDelta = incr;}TString::TString (const TString& string){	string.fSRepPtr->fCounter.Incr ();	fSRepPtr = string.fSRepPtr;	fDelta = string.fDelta;}ostream& TString::Write (ostream &o, const long int n) const{	CHECK_ (0 <= n);	if (n)	{			if (n < fSRepPtr->fLength)		{			char ch = fSRepPtr->fStr[n];			((TString*)this)->fSRepPtr->fStr[n] = '\0';			o << fSRepPtr->fStr;			((TString*)this)->fSRepPtr->fStr[n] = ch;		}		else			o << fSRepPtr->fStr;	}	return (o);}// writes into character array until reaches '\0' or length exceed long intvoid TString::WriteToString (char *str, const long int n) const{	const char* fstr = &(fSRepPtr->fStr[0]);		if(n)	{		long int i = 0;		while((*str++ = *fstr++)!='\0'  && i++< n)			;	}	else		while((*str++ = *fstr++)!='\0')			;}TString::~TString (void){	if (!fSRepPtr->fCounter.Decr ())		delete fSRepPtr;}TStringIteratorConst::TStringIteratorConst (const TString& string)	:	fString (string){	fCurChar = 1;}TStringIteratorConst::~TStringIteratorConst (void){}