// $Log: RadCon.cpp,v $// Revision 1.75  2001/11/29 19:24:12  jthorley// updated version numbers for version 1.1.5 for release//// Revision 1.74  2001/11/28 17:25:09  jthorley// changed expiry date for RadCon release 1.1.4//// Revision 1.73  2001/04/18 20:08:18  jthorley// commented out delete VListBox and changes to expiry date for// release//// Revision 1.72  2001/04/12 20:59:36  jthorley// changes for cw6//// Revision 1.71  2001/04/11 19:02:19  jthorley// changed log window opening message//// Revision 1.70  2001/03/15 20:29:19  jthorley// sorted out deleting consensus objects if aborting anmd got ready to release beta version 1.1.0 with DDA and LS(DI)//// Revision 1.69  2001/03/12 09:51:39  jthorley// debugged DDA//// Revision 1.68  2001/03/10 13:46:11  jthorley// added decay analysis//// Revision 1.67  2001/02/17 19:16:49  jthorley// sorted out bug reported by Rich Grenyer. RadCon now gives proper error messgae if tree with not// enough leaves is read in//// Revision 1.66  2001/02/11 16:30:48  jthorley// big changes for DDA//// Revision 1.65  2000/10/28 16:19:02  jthorley// ?? consensus efficiency and more??//// Revision 1.64  2000/03/05 19:20:24  jthorley// ??//// Revision 1.63  2000/01/22 10:21:07  jthorley// ??//// Revision 1.62  2000/01/16 20:41:27  jthorley// VWindow:Size overridden in TTreesWindow so that i can// control the minimum size of the trees window//// Revision 1.61  2000/01/09 21:16:42  jthorley// got rid of typedefs and used naked primitive types// and loads of other shite//// Revision 1.60  1999/12/09 16:53:27  rdmp1c// Changes to ::Execute method.//// Revision 1.59  1999/12/09 15:29:46  jthorley// ??//// Revision 1.58  1999/12/06 12:43:44  jthorley// ??//// Revision 1.57  1999/11/22 20:53:51  jthorley// new TLeafName and TTreeName in TNexusName//// Revision 1.56  1999/11/14 16:50:28  jthorley// ??//// Revision 1.55  1999/11/11 14:52:25  jthorley// ??//// Revision 1.54  1999/11/08 17:45:59  jthorley// changed to menus and addition of new button to toolbar and// moved TTreeStyle to TTreesBlock//// Revision 1.53  1999/10/20 19:37:40  jthorley// changes rectangular trees and labels internal nodes//// Revision 1.52  1999/10/20 09:25:20  jthorley// Add Trees... and lots of other minor changes/debugs//// Revision 1.51  1999/10/19 10:52:44  jthorley// start of framework for Add Trees... also// changes to saving trees//// Revision 1.50  1999/10/10 16:35:05  jthorley// changes//// Revision 1.49  1999/09/27 14:55:40  jthorley// shed loads of changes//// Revision 1.48  1999/09/16 07:36:36  jthorley// changes to do with reading Phylip files and multiple trees blocks//// Revision 1.47  1999/09/09 16:02:27  jthorley// ??//// Revision 1.46  1999/09/08 16:22:00  jthorley// ??//// Revision 1.45  1999/09/07 11:21:05  jthorley// replaced StoredTreeNumber with ItemNumber// changes to doMRP//// Revision 1.44  1999/09/03 17:30:32  jthorley// changes to do with not changing selection when ShowTrees ()//// Revision 1.43  1999/09/02 12:53:42  jthorley// changes to doPruneLeaves//// Revision 1.42  1999/09/01 15:52:48  jthorley// streamlining - too many changes to document//// Revision 1.41  1999/08/31 12:06:57  jthorley// now handles aborting of LeafStability//// Revision 1.40  1999/08/28 17:33:46  jthorley// changes to do with TQuartetPartition//// Revision 1.39  1999/08/28 13:06:02  jthorley// changes to do with Majority Rule Minority Compatible Component Consensus!//// Revision 1.38  1999/08/19 15:04:08  jthorley// added semi strict component consensus and framework for// minority compatible components//// Revision 1.37  1999/08/15 10:42:19  jthorley// Split stability//// Revision 1.36  1999/08/03 15:21:23  jthorley// replaced operator += with AddToThis ()//// Revision 1.35  1999/08/01 17:14:01  jthorley// implementing Calculating Source Profile CIC//// Revision 1.34  1999/07/26 10:40:29  jthorley// ??//// Revision 1.33  1999/07/21 18:27:29  jthorley// shitloads of changes involving outputting to log file//// Revision 1.32  1999/07/20 15:07:11  jthorley// loads getting ready for release of version 0.7 on the net!//// Revision 1.31  1999/07/18 18:04:05  jthorley// loads to do with dialog boxes and removing tree// selection for consensus methods also tidying up output//// Revision 1.30  1999/07/16 15:31:58  jthorley// saving to preference file of MRP options//// Revision 1.29  1999/07/13 17:15:13  jthorley// MRP changes//// Revision 1.28  1999/06/30 21:40:53  jthorley// RadCon.cpp//// Revision 1.27  1999/06/26 12:46:59  jthorley// Reduced Consensus framework added//// Revision 1.26  1999/06/25 08:57:48  jthorley// RadCon.cpp//// Revision 1.25  1999/06/21 13:04:31  jthorley// changes TTree::GraftLeaf TTree::PruneLeaf//// Revision 1.24  1999/06/17 16:58:22  jthorley// calculates CICs through TTreeCIC//// Revision 1.23  1999/06/16 16:33:58  jthorley// big changes in updating of TTree and new typedefs in TClassTypes.h//// Revision 1.22  1999/06/09 20:50:34  jthorley// Saving Triplet diffs to file//// Revision 1.21  1999/06/02 11:48:36  jthorley// New version 0.6.6//// Revision 1.20  1999/05/28 16:22:26  rdmp1c// Skeleton of comamnd to list other tree windows added//// Revision 1.19  1999/05/25 18:44:20  jthorley// Changes to Component and Adams dialog boxes//// Revision 1.18  1999/05/25 11:25:42  jthorley// Changed function being profiled. When profiling on//// Revision 1.17  1999/05/25 10:30:27  rdmp1c// Added edit control to toolabr to enable selecting trees by number//// Revision 1.16  1999/05/24 17:39:13  jthorley// Loads of changes. Including lay out of strict component consensus//// Revision 1.15  1999/05/21 15:22:24  rdmp1c// Custom File Open dialog now adds name of file to list of recently opened files//// Revision 1.14  1999/05/19 16:35:54  jthorley// doAho () and doIntersectionConsensus () functions defined//// Revision 1.13  1999/05/17 08:27:16  jthorley// minor changes//// Revision 1.12  1999/05/14 18:14:26  jthorley// Changes involving CHECK and CHECK_// And also new COMMAND messages//// Revision 1.11  1999/05/13 15:32:37  rdmp1c// Consensus tree window now listed on Windows menu.//// Revision 1.10  1999/05/12 10:58:02  jthorley// Lots of changes: CHECK () missing ; and DistanceMatrix//// Revision 1.9  1999/05/09 15:15:04  jthorley// Changes involving tree handling and progress dialogs//// Revision 1.8  1999/05/07 08:42:59  jthorley// RadCon.cpp//// Revision 1.7  1999/05/05 21:40:19  jthorley// too many changes to describe!!!//// Revision 1.6  1999/04/29 17:55:54  jthorley// Sorted out bug with controlling rooting//// Revision 1.5  1999/04/28 17:31:42  rdmp1c// Added comment at top to include CVS log messages.////// VClass#include "VApp.h"#include "VAppID.h"#include "VMsg.h"#include "VText.h"#include "VEdit.h"#include "VIconBtn.h"#include "wstream.h" // Log stream class#include "VUtils.h"#include "TTreeCIC.h"// RDMP#define USE_COMMANDLINE		1#if USE_COMMANDLINE	#include "VCmdLine.h"#endif// COMPONENT#include "CPLog.h"#include "RadPrint.h"// Joe#include "TTreesFile.h"#include "TTime.h"#include "TChecks.h"#include "TComponentConsensus.h"#include "TMRPConsensus.h"#include "TAdamsConsensus.h"#include "TReducedConsensus.h"#include "TWrapString.h"#include "TTabString.h"#include "TLeafStability.h"#include "TReadTreesFile.h"#include "TPositionalCongruence.h"#include "TDecayAnalysis.h"#include "TQuartetConstraints.h"#include "VMultiFile.h"//#include "TInputConstraints.h"#include "TDebug.h"#include "TOpenFile.h"#include "TTwoListDialog.h"#include <Profiler.h>#include <exception.h>#include <new.h> // JLT 010412#include "DialogIDs.h"#include "MenuIDs.h"// JLT 000303 from#include "wstream.h"ostream *logStream;// JLT 000303 to///////////////Then you need to define the start and end dates for the program (FROM_DAY, etc.).// Code for making test versions expire. Based closely on Dave Swofford's PAUP* code// for Macintosh//// To use this code define a range of dates over which the program will run (e.g., from the// release date to, say, three months from then). When a new version is released be sure to// update the version information ('vers' resource on the Mac, VERSIONINFO resource under// Windows). Expired versions alter the application preference file (MacOS) or Registry// (Windows) and will prevent more recent copies running unless the more recent program is// also a more recent version (as indicated by its version resource).//#define HAS_EXPIRATION_DATE	// check for expiration date if defined (set date range below)#define SELF_DESTRUCT		// program self-destructs to prevent user just resetting system date if TRUE#if defined(SELF_DESTRUCT) || defined(HAS_EXPIRATION_DATE)#include <DateTimeUtils.h>#if defined(HAS_EXPIRATION_DATE)#	define FROM_DAY		1#	define FROM_MONTH	11#	define FROM_YEAR	2003#	define TO_DAY		5#	define TO_MONTH		1#	define TO_YEAR		2028#endifextern char* GetVersionString (void);extern int KillSplash (void); // JLT 010412long VersionNumber (void);void SelfDestruct (int expiredCode);void DoExpTest (void);extern VTextWindow* Log;VStopWatch gTheTimer;// purely to pass as dummy argument to functionswidgetbuf buf (Log, 100); 	ostream dummy (&buf);		VMonitor* MonitorDialog = NULL;BOOL gAborted = FALSE;#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class CPEditWindow ___#endifclass CPEditWindow : public VEditWindow{public:#ifdef Macintosh	CPEditWindow () { bClosesDocument = TRUE; };	virtual void SetClosesDocument (BOOL on) { bClosesDocument = on; };#endif		virtual BOOL OnMenuCommand (CmdTool cmd);	virtual void OnActivate (BOOL becomingActive);#ifdef Macintosh	virtual BOOL ClosesDocument () { return bClosesDocument; };protected:	BOOL bClosesDocument;#endif};typedef CPEditWindow *CPEditWindowPtr;#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TPruneTreesDialog ___#endif// Dialog that allows user to enter taxa to pruneclass TPruneTreesDialog : public TTwoListDialog{public:	TPruneTreesDialog (const unsigned int minInLeftList);	virtual ~TPruneTreesDialog (void);		virtual void 				Setup (const TSourceTreesFile* sourceTreesFile);	virtual void			 	GetToPrune (TLeafSet& leafSet);		virtual int 				GetNumItemsLeftList (void) { return (fLeftList->GetNumItems ()); };	virtual int 				GetNumItemsRightList (void) { return (fRightList->GetNumItems ()); };protected:	TSourceTreesFile* 			fTreesFile;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class VTreesWindow ___#endif// rename and have class VTreesWindow : public VViewWindow{	public:		VTreesWindow (TTreesFile* treesFile);		virtual ~VTreesWindow (void);				virtual void 						Create (char *title);		virtual void 						Draw (VRect &r);		virtual bool						IsRooted (void) const { return (fTreesFile->IsRooted ()); };						virtual bool						IsSourceTrees (void) const = 0;		virtual const char*					Name (void) const { return (fTreesFile->GetName ()); };		virtual void 						OnActivate (BOOL becomingActive);	#ifdef Macintosh		virtual void 						OnEvent (VEvent &event);	#endif		virtual BOOL						OnMenuCommand (CmdTool cmd);		virtual void 						Size (Point pt);			#ifdef Macintosh		#if USE_COMMANDLINE		virtual void 						MaintainCursor ();		virtual void 						OnPaint () { VViewWindow::OnPaint(); if (CommandLine) CommandLine->Update ();  };		virtual void 						OnIdle () { if (CommandLine) CommandLine->OnIdle ();  };		virtual void 						OnChar (char c, int flags);		#endif	#endif		virtual void 						printBigTree (void);	protected:		virtual void						doTreeDrawing (void);		virtual void						doTreeMeasuresOthers (void);		virtual void						doTreeMeasuresImbalance (void);		virtual void						doInformationTrees (void);		virtual void						doInformationLeaves (void);		virtual void						doSaveTrees (void);		virtual void						doShowTrees (void);		virtual void 						doPrintTrees (void);		virtual void 						doSelectTreesSubset (void);		virtual void						doSelectTreesAll (void);		virtual void						doSelectTreesNone (void);		virtual void						doNextTree (void);		virtual void 						doPreviousTree (void);		virtual void 						doPreviousSelectedTree (void);		virtual void 						doNextSelectedTree (void);		virtual void 						doSelectTree (void);		virtual TItemSet 					getListBoxSelection (VListBox* list) const;				virtual void 						setListBoxTreeNames (const TItemSet& itemSet, VListBox* list, const bool selected = false) const;		virtual void 						setListBoxSelection (const TItemSet& itemSet, VListBox* list) const;		virtual void 						showTreeName (void);									virtual void 						upDate (void);		VIconButton* 						fNextTreeButton;		VIconButton*						fPreviousTreeButton;		VIconButton*						fNextSelectedTreeButton;		VIconButton*						fPreviousSelectedTreeButton;		VIconButton*						fSelectTreeButton;		VIconButton*						fTreeDrawingButton;				TTreePlot							fTreePlot;		TTree								fTree;				VStopWatch 							fTheTimer;				TTreesFile*							fTreesFile;		const TItemSet&						fItemSet;			#if USE_COMMANDLINE		VCmdLine*							CommandLine;		virtual void						doSetTreeFromCommandLine ();	#endif};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class VSourceTreesWindow ___#endifclass VSourceTreesWindow : public VTreesWindow{	public:		VSourceTreesWindow (TSourceTreesFile* treesFile);		virtual ~VSourceTreesWindow (void) { };		virtual bool						IsSourceTrees (void) const { return (true); };		virtual void 						OnActivate (BOOL becomingActive);		virtual BOOL						OnMenuCommand (CmdTool cmd);		protected:		virtual void						doAddTrees (void);		virtual void						doAddOutGroup (void);		virtual void 						doCompareProfiles (void); // RDMP		virtual void 						doComponentConsensus (void);		virtual void 						doDecayInput (const bool fuse);		virtual void 						doDecayOutput (const bool fuse);		virtual void 						doMRP (void);		virtual void 						doLeafStabilityBootstrap (void);		virtual void 						doPruneLeaves (void);		virtual void 						doPositionalCongruence (void);		virtual void 						doReducedConsensus (void);		virtual void						doCondenseTrees (void);		virtual void						doRootTrees (void);		virtual void 						doUnRootTrees (void);		virtual void 						doAdamsConsensus (void);				virtual void 						doReRoot (void);		virtual void						doWeightEqually (void);		virtual void 						doShowWeights (void);		virtual void						doWeightBootstrap (void);		virtual void 						doTotalInformation (void);};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class VConsensusTreesWindow ___#endifclass VConsensusTreesWindow : public VTreesWindow{	public:		VConsensusTreesWindow (TConsensusTreesFile* consensusTreesFile);		virtual ~VConsensusTreesWindow (void) { };		virtual bool						IsSourceTrees (void) const { return (false); };		virtual void 						OnActivate (BOOL becomingActive);		virtual BOOL						OnMenuCommand (CmdTool cmd);};#define id_tree 10#define id_text 11#define id_tree_fig 12#define id_text_fig 13pascal short myDialogHook (short item, DialogPtr theDialog, void *yourDataPtr);#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class VMultipagePreview ___#endifclass VMultipagePreview : public VPreviewWindow{	public:		VMultipagePreview (void) { };		virtual ~VMultipagePreview (void) { delete PagesMenu; };		virtual void CreateWindow (char *title); 		virtual void OnEvent (VEvent &event);		virtual BOOL OnMenuCommand (CmdTool cmd);		virtual void Print ();	protected:		VPopupMenu* PagesMenu;		virtual void DrawImage ();};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TTreesDoc ___#endifclass TTreesDoc : public VDocument{	public:		TTreesDoc (void);		virtual ~TTreesDoc (void);		virtual VPreviewWindow* 			CreatePreviewWindow (void) { return (new VMultipagePreview); };		virtual BOOL 						Execute (VEditWindow* win);		virtual void 						New (void);		virtual void 						New (TConsensusTreesFile* consensusTreesFile);		virtual void 						New (TSourceTreesFile* sourceTreesFile);		virtual int 						Open (void);		virtual int 						Open (char* filename, char* buf);		virtual BOOL 						Write (ostream& o);	protected:		virtual void						makeOtherTreesDocs (TSourceTreesFileList& sourceTreesFileList);				TTreesFile*		 					fTreesFile; 		int 								fAction;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class RadConFrame ___#endifclass RadConFrame : public VFrameWindow{	public:		virtual BOOL 						OnMenuCommand (CmdTool cmd);		virtual VDocument* 					GetNewDoc (void) { return (new TTreesDoc); };		virtual bool 						IncludeViewInList (VWindowPtr win); // RDMP	protected:		virtual void						doPreferences (void);};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class RadConApp ___#endifclass RadConApp : public VApp{	public:		virtual ~RadConApp (void) { };		virtual void 						Create (void);						virtual VFrameWindow* 				CreateFrameWindow (void) { return (new RadConFrame); };	#if defined (SELF_DESTRUCT) || defined (HAS_EXPIRATION_DATE)		virtual void 						OnInit (void);	#endif			//		virtual bool 						HasDialogBox (void); // something I have added...ask Rod???	protected:		widgetbuf*							widbuf;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TMemoryException ___#endifclass TMemoryException : public TXception{	public:		TMemoryException (void);};#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifTMemoryException::TMemoryException (void)	: TXception (){}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifchar* gSpareBlock = NULL;void radcon_new_handler (void);void radcon_terminate (void);void radcon_unexpected (void);void radcon_new_handler (void){	if (gSpareBlock) // in case memory allocation of spare block failed	{		delete gSpareBlock;		gSpareBlock = NULL;	}		throw TMemoryException ();}void radcon_unexpected (void){	Message (MSG_ERROR, "Unexpected Exception");	abort ();}void radcon_terminate (void){	Message (MSG_ERROR, "Uncaught Exception");		abort ();	}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif// Convert program version into a long of form major * 1000, minor * 10, maintainence * 1// modified by JLT 000624#define HiByte(x)  ((Byte)((short)(x) >> 8))#define LoByte(x) ((Byte)(short)(x))long VersionNumber (void){	long version = 1; // default ?? JLT 000624		Handle hVers = ::GetResource ('vers', 1);	short major_version, minor_version, incremental_version;	major_version = minor_version = incremental_version = 0;	if (hVers != NULL)	{		version = **(long **)hVers;		ReleaseResource (hVers);				short versionNum = HiWord (version);		// Version is major_version.minor_version.incremental_version			major_version = HiByte(versionNum);		Byte t = LoByte (versionNum);		minor_version = t >> 4;		incremental_version = t & 0x0F;	}	long result = major_version * 1000;	result += 10 * minor_version;	result += incremental_version;	return (result);}void SelfDestruct (int expiredCode){	if (expiredCode != 3)	{ // Set registry key saying this version has expired		TheApp->Preferences.SetIntPreference ("Startup", "Version",VersionNumber(), TRUE);	}#ifdef Macintosh	if (expiredCode != 2)	{ // Add the 'expired' resource to the application file		Handle h = ::NewHandle(0);		::AddResource(h, 'PEXP', 256, "\p");		::WriteResource(h);	}#endif}void DoExpTest (void){#ifdef Windows	SYSTEMTIME sysTime;#else	DateTimeRec 	date;	unsigned long	secs;#endif    static int expiredCode = 0;    // Check for registry key indicating this installation has expired. On self    // destruct program writes its version number to the registry. The current    // version will see that this key has been written and will exit. A newer    // version will see that the key is out of date and continue.    long key = TheApp->Preferences.GetIntPreference ("Startup", "Version", 0);    if ((key != 0) && (key >= VersionNumber()))    	expiredCode = 3;    if (expiredCode == 0)    {	// Check executable hasn't expired. This is a check against the        // possibility that user has copied expired program to another machine        // in an attempt to run it.#ifdef Windows        // Can't figure out how to do this yet for Windows...#else		// Check for special resource that marks file as expired		if (::CountResources('PEXP') != 0)			expiredCode = 2;#endif    }    if (expiredCode == 0)    {#ifdef Windows        ::GetLocalTime (&sysTime);        if ((sysTime.wYear < FROM_YEAR) || (sysTime.wYear > TO_YEAR))            expiredCode = 4;        else if ((sysTime.wYear == FROM_YEAR) && ((sysTime.wMonth < FROM_MONTH) || ((sysTime.wMonth == FROM_MONTH) && (sysTime.wDay < FROM_DAY))))            expiredCode = 4;        else if ((sysTime.wYear == TO_YEAR) && ((sysTime.wMonth > TO_MONTH) || ((sysTime.wMonth == TO_MONTH) && (sysTime.wDay > TO_DAY))))            expiredCode = 4;#else		::GetDateTime (&secs);		::SecondsToDate (secs, &date);		if ((date.year < FROM_YEAR) || (date.year > TO_YEAR))			expiredCode = 4;		else if ((date.year == FROM_YEAR) && ((date.month < FROM_MONTH) || ((date.month == FROM_MONTH) && (date.day < FROM_DAY))))			expiredCode = 4;		else if ((date.year == TO_YEAR) && ((date.month > TO_MONTH) || ((date.month == TO_MONTH) && (date.day > TO_DAY))))			expiredCode = 4;#endif    }	if (expiredCode != 0)    {#ifdef Windows    	KillSplash ();#endif    	TString string ("Sorry folks! This version has expired!");    	string.AddToThis (EOLN);    	   // 	string.AddToThis (VersionNumber ()); // JLT 000623    //	string.AddToThis (EOLN);    //	string.AddToThis (EOLN);        Message (MSG_INFO, string.Array ());        SelfDestruct (expiredCode);        TheApp->SavePreferences ();        exit (EXIT_SUCCESS);    }}#endif#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TPruneTreesDialog::Setup (const TSourceTreesFile* sourceTreesFile){	fTreesFile = (TSourceTreesFile*)sourceTreesFile; // JLT 010412#ifdef Macintosh	fLeftList = new VListBox (this, kIDLeftList, TRUE, TRUE);#else	fLeftList = new VListBox;   this->Associate (fLeftList, kIDLeftList);#endif		#ifdef Macintosh	fRightList = new VListBox (this, kIDRightList, TRUE, TRUE);#else	fRightList = new VListBox;   this->Associate (fRightList, kIDRightList);#endif#ifdef Macintosh	WatchCursor ();	fLeftList->DoDraw (FALSE);#endif		TLeafSet leafSet = fTreesFile->GetTotalLeafSet (false, true);	for (unsigned int leaf = leafSet.FirstLeaf ();leaf; leaf = leafSet.NextLeaf ())		fLeftList->Append ((char*)fTreesFile->GetLeafName (leaf)); // JLT 010412#ifdef Macintosh	fLeftList->DoDraw (TRUE);	ArrowCursor ();#endif#ifdef Macintosh	WatchCursor ();	fRightList->DoDraw (FALSE);#endif		TLeafSet pruned = fTreesFile->GetPrunedLeafSet ();	for (unsigned int leaf = pruned.FirstLeaf ();leaf; leaf = pruned.NextLeaf ())		fRightList->Append ((char*)fTreesFile->GetLeafName (leaf)); // JLT 010412	#ifdef Macintosh	fRightList->DoDraw (TRUE);	ArrowCursor ();#endif		// Enable buttons	EnableItem (kIDLeftToRight, (BOOL) (fLeftList->GetNumSelections () > 0));		EnableItem (kIDRightToLeft, (BOOL) (fRightList->GetNumSelections () > 0));		EnableItem (kIDAllLeft, (BOOL) (fLeftList->GetNumItems () > 0));		EnableItem (kIDAllRight, (BOOL) (fRightList->GetNumItems () > 0));	}void TPruneTreesDialog::GetToPrune (TLeafSet& leafSet) {	leafSet = fTreesFile->GetTotalLeafSet (false, false);	for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())		if (fLeftList->FindString ((char*)fTreesFile->GetLeafName (leaf)) > -1) // JLT 010412			leafSet -= leaf;}TPruneTreesDialog::TPruneTreesDialog (const unsigned int minInLeftList) 	:	TTwoListDialog (minInLeftList){ }TPruneTreesDialog::~TPruneTreesDialog (void){}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#define EDIT_WIDTH 60void VTreesWindow::Create (char *title){ 	VViewWindow::Create (title);#ifdef Macintosh	ToolbarHeight = 30;	VRect cr (2, 2, 26, 26);	fPreviousTreeButton = new VIconButton (this, cr, "Back", 131, VS_BUTTON);	#if USE_COMMANDLINE	// Edit control	VRect er (2 + 26 + 2, 8, EDIT_WIDTH, 22);	CommandLine = new VNumberCmdLine (this, er);	cr.Offset (EDIT_WIDTH - 22, 0);#endif	cr.Offset (26, 0);		fNextTreeButton = new VIconButton (this, cr, "Forward", 132, VS_BUTTON);	cr.Offset (28, 0);	fSelectTreeButton = new VIconButton (this, cr, "Select", 134, VS_BUTTON);	cr.Offset (28, 0);	fPreviousSelectedTreeButton = new VIconButton (this, cr, "Fast_Back", 130, VS_BUTTON);	cr.Offset (26, 0);	fNextSelectedTreeButton = new VIconButton (this, cr, "Fast_Forward", 133, VS_BUTTON);	cr.Offset (26, 0);	fTreeDrawingButton = new VIconButton (this, cr, "Tree_Drawing", 135, VS_BUTTON);			CHECK_ (fTreesFile->GetCurTreeNumber ());	fPreviousSelectedTreeButton->Enable (true);	fPreviousTreeButton->Enable (true);	fNextTreeButton->Enable (true);	fNextSelectedTreeButton->Enable (true);	fSelectTreeButton->Enable (true);	fTreeDrawingButton->Enable (true);#endif	CreateStatusLine ();	showTreeName ();	upDate();}void VTreesWindow::Draw (VRect &rect){	rect.Inset (20, 20);		if (fItemSet.IsItem (fTreesFile->GetCurTreeNumber ()))	{		Port.Black ();		Port.WidePen (2);	}	else	{		Port.Black ();		Port.WidePen (1);	}		Port.SelectAFont (viewFont);	//	fTreePlot.SetTreePlot (rect, viewFont, fTreesFile->GetTreeStyle (), NULL);//	fTree.Draw (fTreePlot); 	fTree.Draw (rect, viewFont, fTreesFile->GetTreeStyle (), NULL);}void VTreesWindow::OnActivate (BOOL becomingActive){	VViewWindow::OnActivate (becomingActive);	#if USE_COMMANDLINE	if (CommandLine)		CommandLine->OnActivate (becomingActive && (fTreesFile->GetTrees () > 1));#endif	if (becomingActive)	{		VEnableMenuItem (cmdInformation, true);		VEnableMenuItem (cmdTreeMeasures, true);		VEnableMenuItem (cmdTreeMeasuresImbalance, fTreesFile->IsRooted ());		VEnableMenuItem (cmdSelectTrees, true);		VEnableMenuItem (cmdShowTrees, true);		VEnableMenuItem (cmdPrintTrees, fTreesFile->GetTrees (true));		VEnableMenuItem (cmdSaveTrees, fTreesFile->GetTrees (true));		VEnableMenuItem (cmdSaveAs, fTreesFile->GetTrees (true));				VEnableMenuItem (cmdPrintPreview, fTreesFile->GetTrees (true));			}	else	{		VEnableMenuItem (cmdInformation, false);		VEnableMenuItem (cmdTreeMeasures, false);		VEnableMenuItem (cmdTreeMeasuresImbalance, false);		VEnableMenuItem (cmdSelectTrees, false);		VEnableMenuItem (cmdShowTrees, false);		VEnableMenuItem (cmdPrintTrees, false);		VEnableMenuItem (cmdSaveTrees, false);//		VEnableMenuItem (cmdSaveAs, false);			}}#ifdef Macintoshvoid VTreesWindow::OnEvent (VEvent &event){	PoinT pt;	event.GetPosition (pt);		ControlHandle control;	Point p;	p.h = pt.x;	p.v = pt.y;		#if USE_COMMANDLINE	if (CommandLine)	{		if (CommandLine->MouseOn (p, (Boolean) event.ShiftKeyDown ()))		{			return;		}	}#endif	if (::FindControl (p, window, &control))	{		::TrackControl (control, p, nil);				if (fPreviousTreeButton->IsControl (control)) 			doPreviousTree ();		else if (fNextTreeButton->IsControl (control)) 			doNextTree ();		else if (fSelectTreeButton->IsControl (control)) 			doSelectTree ();		else if (fPreviousSelectedTreeButton->IsControl (control)) 			doPreviousSelectedTree ();		else if (fNextSelectedTreeButton->IsControl (control)) 			doNextSelectedTree ();		else if (fTreeDrawingButton->IsControl (control))			doTreeDrawing ();	}	OnActivate (TRUE);}#endifBOOL VTreesWindow::OnMenuCommand (CmdTool cmd){	BOOL processed = FALSE;		switch (cmd)	{									case cmdTreeMeasuresOthers:			doTreeMeasuresOthers ();			break;					case cmdTreeMeasuresImbalance:			doTreeMeasuresImbalance ();			break;					case cmdInformationLeaves:			doInformationLeaves ();			break;		case cmdInformationTrees:			doInformationTrees ();			break;		case cmdShowTrees:			doShowTrees ();			break;		case cmdSaveTrees:			doSaveTrees ();			break;		case cmdSelectTreesSubset:			doSelectTreesSubset ();			break;		case cmdSelectTreesAll:			doSelectTreesAll ();			break;		case cmdSelectTreesNone:			doSelectTreesNone ();			break;		case cmdPrintTrees:			doPrintTrees (); 			break;			#if USE_COMMANDLINE				case cmdCmdLine:			doSetTreeFromCommandLine ();			break;#endif												default:			processed = VViewWindow::OnMenuCommand (cmd);	}	return processed;}void VTreesWindow::doTreeDrawing (void){	TTreeStyle treeStyle = fTreesFile->GetTreeStyle ();	treeStyle.SetRectangular (!treeStyle.IsRectangular ());	fTreesFile->SetTreeStyle (treeStyle);	upDate ();}void VTreesWindow::doTreeMeasuresImbalance (void){	CHECK_ (IsRooted ());		VDialog* dialog = TheApp->CreateDialog (dlgImbalance, TRUE, FALSE);	VListBox* List = new VListBox (dialog, 4, TRUE); 		setListBoxTreeNames (fTreesFile->GetTrees (), List);	TItemSet itemSet;	itemSet += 	fTreesFile->GetCurTreeNumber ();	setListBoxSelection (itemSet, List);		bool ib = (bool)(TheApp->Preferences.GetIntPreference ("IMBALANCE", "IB", 1));	bool ibmax = (bool)(TheApp->Preferences.GetIntPreference ("IMBALANCE", "IBMAX", 1));	bool ibmin = (bool)(TheApp->Preferences.GetIntPreference ("IMBALANCE", "IBMIN", 1));	bool ib_ibmax = (bool)(TheApp->Preferences.GetIntPreference ("IMBALANCE", "IB_IBMAX", 1));	bool ib_ibmin_ibmax_ibmin = (bool)(TheApp->Preferences.GetIntPreference ("IMBALANCE", "IB_IBMIN_IBMAX_IBMIN", 1));					dialog->SetItemState (6, ib);	dialog->SetItemState (7, ibmax);	dialog->SetItemState (8, ibmin);	dialog->SetItemState (9, ib_ibmax);	dialog->SetItemState (10, ib_ibmin_ibmax_ibmin);	dialog->SetItemState (1, dialog->GetItemState (6) || dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9) || dialog->GetItemState (10));		dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit ();		switch (item)		{			case 3:					break;			case 5:				List->SelectAll ();				break;							case 6:				dialog->ToggleDlgItem (6, NULL);				break;			case 7:				dialog->ToggleDlgItem (7, NULL);				break;			case 8:				dialog->ToggleDlgItem (8, NULL);				break;			case 9:				dialog->ToggleDlgItem (9, NULL);				break;			case 10:				dialog->ToggleDlgItem (10, NULL);				break;			default:				break;		}		dialog->EnableItem (1, (BOOL)(dialog->GetItemState (6) || dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9) || dialog->GetItemState (10)));	} while (item > 2);		itemSet = getListBoxSelection (List);		if (item == 1)	{		ib = dialog->GetItemState (6);		ibmax = dialog->GetItemState (7);		ibmin = dialog->GetItemState (8);		ib_ibmax = dialog->GetItemState (9);		ib_ibmin_ibmax_ibmin = dialog->GetItemState (10);	}	TheApp->DestroyDialog ();	// delete List; JLT 010417 	// could maybe do through medium of itemset.....	if (item == 1)	{		WatchCursor ();				fTheTimer.StartTiming ();							*Log << EOLN << EOLN << "COMMAND: Imbalance '" << Name () << "'" << EOLN;				TTabString tabString (kFileWidth);		tabString.SetNextTabLength (6);		tabString.SetNextTabLength (10);		tabString.SetNextTabLength (10);		tabString.SetNextTabLength (10);		tabString.SetNextTabLength (12);		tabString.SetNextTabLength (26);				tabString.SetNewLine ();		tabString.AddToThis ("Tree");		if (ib)			tabString.AddToThis ("IB");		if (ibmax)			tabString.AddToThis ("IB_max");		if (ibmin)			tabString.AddToThis ("IB_min");		if (ib_ibmax)			tabString.AddToThis ("IB/IB_max");		if (ib_ibmin_ibmax_ibmin)			tabString.AddToThis ("IB-IB_min/IB_max-IB_min");		tabString.SetNewLine ();		*Log << tabString.GetString ().Array ();		tabString.SetNull ();				TTree tree;		TString string;		CHECK_ (itemSet.LastItem () <= fTreesFile->GetTrees ());		for (itemSet.FirstItem (); itemSet.CurItem (); itemSet.NextItem ())		{						CHECK_ (fTreesFile->GetIthTree (itemSet.CurItem (), tree, false, false));			fTreesFile->GetIthTree (itemSet.CurItem (), tree, false, false);			string.AddToThis (itemSet.CurItem ());			tabString.AddToThis (string);			string.SetNull ();							unsigned long imbalance = tree.IsBinary () ? tree.GetImbalance () : 0;			unsigned long imbalancemax = tree.IsBinary () ? tree.GetMaxImbalance () : 0;			unsigned long imbalancemin = tree.IsBinary () ? tree.GetMinImbalance () : 0;				if (ib)			{				if (tree.IsBinary ())				{					string.AddToThis (imbalance);					tabString.AddToThis (string);					string.SetNull ();				}				else					tabString.AddToThis ("N/A");			}			if (ibmax)			{				if (tree.IsBinary ())				{					string.AddToThis (imbalancemax);					tabString.AddToThis (string);					string.SetNull ();				}				else					tabString.AddToThis ("N/A");			}			if (ibmin)			{				if (tree.IsBinary ())				{					string.AddToThis (imbalancemin);					tabString.AddToThis (string);					string.SetNull ();				}				else					tabString.AddToThis ("N/A");			}			if (ib_ibmax)			{				if (tree.IsBinary ())				{					string.AddToThis ((float)((double)imbalance / (double)imbalancemax));					tabString.AddToThis (string);					string.SetNull ();				}				else					tabString.AddToThis ("N/A");			}			if (ib_ibmin_ibmax_ibmin)			{				if (tree.IsBinary ())				{					if (!(imbalance - imbalancemin))						string.AddToThis ((float)0);					else						string.AddToThis ((float)((double)(imbalance - imbalancemin) / (double)(imbalancemax - imbalancemin)));					tabString.AddToThis (string);					string.SetNull ();				}				else					tabString.AddToThis ("N/A");			}			tabString.SetNewLine ();			*Log << tabString.GetString ().Array ();			tabString.SetNull ();		}		TheApp->Preferences.SetIntPreference ("IMBALANCE", "IB", (ib ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("IMBALANCE", "IBMAX", (ibmax ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("IMBALANCE", "IBMIN", (ibmin ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("IMBALANCE", "IB_IBMAX", (ib_ibmax ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("IMBALANCE", "IB_IBMIN_IBMAX_IBMIN", (ib_ibmin_ibmax_ibmin ? 1 : 0), TRUE);					fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VTreesWindow::doTreeMeasuresOthers (void){	VDialog* dialog = TheApp->CreateDialog (dlgTreeMeasuresOthers, TRUE, FALSE);	VListBox* List = new VListBox (dialog, 4, TRUE); 		setListBoxTreeNames (fTreesFile->GetTrees (), List);	TItemSet itemSet;	itemSet += 	fTreesFile->GetCurTreeNumber ();	setListBoxSelection (itemSet, List);	//	bool weight = (bool)(TheApp->Preferences.GetIntPreference ("DESCRIBE_TREES", "WEIGHT", 1));		bool leaves = (bool)(TheApp->Preferences.GetIntPreference ("DESCRIBE_TREES", "LEAVES", 1));	bool branches = (bool)(TheApp->Preferences.GetIntPreference ("DESCRIBE_TREES", "BRANCHES", 1));	bool cic = (bool)(TheApp->Preferences.GetIntPreference ("DESCRIBE_TREES", "CIC", 1));//	bool balance = (bool)(TheApp->Preferences.GetIntPreference ("DESCRIBE_TREES", "BALANCE", 1));	bool normalise = (bool)(TheApp->Preferences.GetIntPreference ("DESCRIBE_TREES", "NORMALISE", 1));	//	if (IsSourceTrees ())	//		dialog->SetItemState (6, weight);//	else//		dialog->EnableItem (6, false);						dialog->SetItemState (7, leaves);	dialog->SetItemState (8, branches);	dialog->SetItemState (9, cic);//	if (IsRooted ())//		dialog->SetItemState (10, balance);//	else//		dialog->EnableItem (10, false);		dialog->SetItemState (11, normalise);//	dialog->SetItemState (1, (BOOL)(dialog->GetItemState (6) || dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9) || dialog->GetItemState (10)));//	dialog->SetItemState (1, (BOOL)(dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9) || dialog->GetItemState (10)));	dialog->SetItemState (1, (BOOL)(dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9)));		dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit ();		switch (item)		{			case 3:					break;			case 5:				List->SelectAll ();				break;				//			case 6://				dialog->ToggleDlgItem (6, NULL);//				break;			case 7:				dialog->ToggleDlgItem (7, NULL);				break;			case 8:				dialog->ToggleDlgItem (8, NULL);				break;			case 9:				dialog->ToggleDlgItem (9, NULL);				break;//			case 10://				dialog->ToggleDlgItem (10, NULL);//				break;			case 11:				dialog->ToggleDlgItem (11, NULL);				break;			default:				break;		}//		dialog->EnableItem (1, (BOOL)(dialog->GetItemState (6) || dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9) || dialog->GetItemState (10)));//		dialog->EnableItem (1, (BOOL)(dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9) || dialog->GetItemState (10)));		dialog->EnableItem (1, (BOOL)(dialog->GetItemState (7) || dialog->GetItemState (8) || dialog->GetItemState (9)));	} while (item > 2);		itemSet = getListBoxSelection (List);		if (item == 1)	{//		if (IsSourceTrees ())//			weight = dialog->GetItemState (6);		leaves = dialog->GetItemState (7);		branches = dialog->GetItemState (8);		cic = dialog->GetItemState (9);		normalise = dialog->GetItemState (11);	}	TheApp->DestroyDialog ();	// delete List; JLT 010417 	// could maybe do through medium of itemset.....	if (item == 1)	{		WatchCursor ();				fTheTimer.StartTiming ();					//want way to control setting and not changing...				*Log << EOLN << EOLN << "COMMAND: Tree Measures '" << Name () << "'" << EOLN;				TTabString tabString (kFileWidth);		tabString.SetNextTabLength (6);		tabString.SetNextTabLength (15);		tabString.SetNextTabLength (15);		tabString.SetNextTabLength (15);				tabString.SetNewLine ();		tabString.AddToThis ("Tree");//		if (IsSourceTrees () && weight)//			tabString.AddToThis ("Weight");		if (leaves)			tabString.AddToThis ("Size");		if (branches)			tabString.AddToThis ("Resolution");//		if (IsRooted () && balance)//			tabString.AddToThis ("Balance");		if (cic)			tabString.AddToThis ("Information");		tabString.SetNewLine ();		tabString.AddToken (" ");//		if (IsSourceTrees () && weight)//			tabString.AddToThis ("Weight");		if (leaves)			tabString.AddToThis ("(Leaves)");		if (branches)			tabString.AddToThis ("(Internals)");//		if (IsRooted () && balance)//			tabString.AddToThis ("(Colless's)");		if (cic)			tabString.AddToThis ("(CIC)");		tabString.SetNewLine ();		*Log << tabString.GetString ().Array ();		tabString.SetNull ();				TTree tree;		TString string;		CHECK_ (itemSet.LastItem () <= fTreesFile->GetTrees ());		for (itemSet.FirstItem (); itemSet.CurItem (); itemSet.NextItem ())		{						CHECK_ (fTreesFile->GetIthTree (itemSet.CurItem (), tree, false, false));			fTreesFile->GetIthTree (itemSet.CurItem (), tree, false, false);//			string.AddToThis (fTreesFile->GetItemSet ().IthItem (itemSet.CurItem ()));			string.AddToThis (itemSet.CurItem ());			tabString.AddToThis (string);			string.SetNull ();//			if (IsSourceTrees () && weight)//			{//				string.AddToThis (tree.GetWeight (), 4);//				tabString.AddToThis (string);//				string.SetNull ();//			}			if (leaves)			{				string.AddToThis (tree.GetLeaves ());				tabString.AddToThis (string);				string.SetNull ();			}			if (branches)			{				if (!normalise)					string.AddToThis (tree.GetResolution ());				else					string.AddToThis (tree.GetNormalisedResolution (), 4);				tabString.AddToThis (string);				string.SetNull ();			}//			if (IsRooted () && balance)//			{//				CHECK_ (tree.IsRooted ());//				if (tree.IsBinary () && 3 < tree.GetLeaves ())//				{//					if (!normalise)//						string.AddToThis (tree.GetBalance ());//					else//						string.AddToThis (tree.GetNormalisedBalance (), 4);//				}//				else//					string.AddToThis ("N/A");//				tabString.AddToThis (string);//				string.SetNull ();//			}			if (cic)			{	// sets upper limit 150 leaves				if (150 < tree.GetLeaves () || (tree.GetTreeType () != kStrictCladistic && tree.GetTreeType () != kDecayIndex && tree.GetTreeType () != kStrictNestings))					tabString.AddToThis ("N/A");							else if (tree.GetTreeType () == kStrictCladistic || tree.GetTreeType () == kDecayIndex)				{					if (!normalise)					{						string.AddToThis (tree.GetCIC (), 4);						string.AddToThis (" bits");					}					else						string.AddToThis (tree.GetNormalisedCIC (), 4);					tabString.AddToken (string);					string.SetNull ();				}				else 				{ // if (tree.GetTreeType () == kStrictNestings)					TTreeCIC treeCIC (tree.IsRooted ());					treeCIC.AddTree (tree); // switching to Adams!!! needs debugging					treeCIC.CalcCICs ();					if (gAborted)					{						string.AddToThis ("N/A");						gAborted = false;					}					else					{						if (!normalise)						{							string.AddToThis (treeCIC.IthTreeCIC (1), 4);							string.AddToThis (" bits");						}						else							string.AddToThis (treeCIC.IthTreeCIC (1) / tree.GetMaxCIC (), 4);					}					tabString.AddToken (string);					string.SetNull ();				}			}			tabString.SetNewLine ();			*Log << tabString.GetString ().Array ();			tabString.SetNull ();		}//		if (weight)//			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "WEIGHT", 1, TRUE);//		else//			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "WEIGHT", 0, TRUE);		if (leaves)			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "LEAVES", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "LEAVES", 0, TRUE);		if (branches)			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "BRANCHES", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "BRANCHES", 0, TRUE);		if (cic)			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "CIC", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "CIC", 0, TRUE);//		if (balance)//			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "BALANCE", 1, TRUE);//		else//			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "BALANCE", 0, TRUE);		if (normalise)			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "NORMALISE", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("DESCRIBE_TREES", "NORMALISE", 0, TRUE);				fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VTreesWindow::doInformationTrees (void){	WatchCursor ();	fTheTimer.StartTiming ();						*Log << EOLN << EOLN << "COMMAND: About Trees '" << Name () << "'" << EOLN;		*Log << EOLN;		fTreesFile->WriteInfoTrees (dummy);			fTheTimer.StopTiming ();	*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;	ArrowCursor ();	upDate ();}void VTreesWindow::doInformationLeaves (void){	WatchCursor ();	fTheTimer.StartTiming ();						*Log << EOLN << EOLN << "COMMAND: About Leaves '" << Name () << "'" << EOLN;		*Log << EOLN;		fTreesFile->WriteInfoLeaves (dummy);			fTheTimer.StopTiming ();	*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;	ArrowCursor ();	upDate ();}void VTreesWindow::doNextSelectedTree (void){	if (fTreesFile->GetCurTreeNumber () < fItemSet.LastItem ())	{		fTreesFile->SetCurTreeNumber (fItemSet.NextItem (fTreesFile->GetCurTreeNumber ()));		#if USE_COMMANDLINE		CommandLine->SetNumber (fTreesFile->GetCurTreeNumber ());		#endif		upDate ();	}}void VTreesWindow::doPrintTrees (void){	VPrintTreeDialog* dialog = new VPrintTreeDialog;#ifdef Windows	TheApp->Create_Dialog (dialog, dlg_PrintTrees);	dialog->Setup (fTreesFile);	dialog->Show ();	dialog->GetPreviewPicture ();#else	TheApp->CreateDialog (dialog, id_preview_dialog, TRUE);	dialog->Setup (fTreesFile, fTreesFile->GetTreeStyle ());	PictureTool pic;	dialog->GetPicture (pic);	dialog->SetPicture (pic);	dialog->Show ();#endif	short item;	do	{		BOOL redraw = FALSE;		item = TheApp->DialogItemHit();		switch (item)		{/*			case id_internals:#ifdef Macintosh				state =  dialog->GetItemState (item);				dialog->SetItemState (item, !state);#endif									redraw = dialog->DoInternals ();				break;			case id_order:				redraw = dialog->DoOrder ();				break;*/			case id_leaf_font:				redraw = dialog->DoFont (id_leaf_font);				break;/*			case id_edge_font:				redraw = dialog->DoFont (id_edge_font);*/				break;			case id_preview_copy:				dialog->Copy ();				break;								case id_preview_picture:				dialog->SaveAsPicture ();				break;								case id_preview_next:				dialog->NextPage ();				redraw = TRUE;				break;								case id_preview_last:				dialog->LastPage ();				redraw = TRUE;				break;			case id_preview_trees_per_page:				redraw = dialog->DoTreesPerPage ();				break;/*			case id_radialtree:			case id_cladogram:			case id_rectangle:			case id_phylogram:				redraw = dialog->DoTreeStyle (item);			break;			case id_1pt:			case id_2pt:			case id_3pt:				redraw = dialog->DoLineStyle (item);			break;*/#ifdef Windows			case id_print:				dialog->Print ();				break;#else			case 2:				dialog->Print ();				item = 3;				break;#endif			default:				break;		}		if (redraw)		{#ifdef Windows			dialog->GetPreviewPicture ();#else			dialog->GetPicture (pic);			dialog->SetPicture (pic);#endif		}	} while (item > 2);	TheApp->DestroyDialog();}void VTreesWindow::doPreviousSelectedTree (void){	if (fItemSet.FirstItem () < fTreesFile->GetCurTreeNumber ())	{		fTreesFile->SetCurTreeNumber (fItemSet.PrevItem (fTreesFile->GetCurTreeNumber ()));		#if USE_COMMANDLINE		CommandLine->SetNumber (fTreesFile->GetCurTreeNumber ());		#endif		upDate ();	}}void VTreesWindow::doPreviousTree (void){	if (1 < fTreesFile->GetCurTreeNumber ())	{		fTreesFile->SetCurTreeNumber (fTreesFile->GetCurTreeNumber () - 1);		#if USE_COMMANDLINE		CommandLine->SetNumber (fTreesFile->GetCurTreeNumber ());		#endif		upDate ();	}}void VTreesWindow::doNextTree (void){	if (fTreesFile->GetCurTreeNumber () < fTreesFile->GetTrees ())	{		fTreesFile->SetCurTreeNumber (fTreesFile->GetCurTreeNumber () + 1);		#if USE_COMMANDLINE		CommandLine->SetNumber (fTreesFile->GetCurTreeNumber ());		#endif		upDate();	}}void VTreesWindow::doSaveTrees (void){	CHECK (fTreesFile->GetTrees (true));	VFile TreeFile;#ifdef Macintosh	TreeFile.SetCreator ('RadC');#else	TreeFile.SetCreator (".tre");#endif	if (TreeFile.GetOutputFileName ("Save trees as:", "Untitled"))	{		WatchCursor();		*Log << EOLN << EOLN << "COMMAND: Save Trees '" << Name () << "'" << EOLN;		fTheTimer.StartTiming ();						ostream *s = TreeFile.GetOutputStream ();		const unsigned int treesSaved = fTreesFile->SaveTrees (*s, TheApp->Preferences.GetIntPreference ("SAVE_TREES", "CHARACTERS", 0), true);				TreeFile.Close ();				if (gAborted)		{			*Log << EOLN << "Save Trees Aborted: By User" << EOLN;			gAborted = FALSE;		}			*Log << EOLN << (int)treesSaved << ' '  << ((IsRooted ()) ? "Rooted " : "Unrooted ") << ((treesSaved == 1) ? "Tree " : "Trees ") << "Saved to '" << TreeFile.GetShortName () << "'" << EOLN; 				fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor();	}	upDate ();}void VTreesWindow::doSelectTree (void){	fTreesFile->SelectIth (fTreesFile->GetCurTreeNumber (), !fItemSet.IsItem (fTreesFile->GetCurTreeNumber ()));	upDate();}void VTreesWindow::doSelectTreesSubset (void){	int item = 1;		VDialog* dialog = TheApp->CreateDialog (dlgSelectTreesSubset, TRUE, FALSE);	VListBox* List = new VListBox (dialog, 4, TRUE); 		setListBoxTreeNames (fTreesFile->GetTrees (), List);	setListBoxSelection (fTreesFile->GetItemSet (), List);			dialog->Show();	do	{		item = TheApp->DialogItemHit();			switch (item)			{				case 3:						break;				case 5:					List->SelectAll ();					break;								default:					break;			}	} while (item > 2);		if (item == 1)		fTreesFile->SetItemSet (getListBoxSelection (List));	TheApp->DestroyDialog ();	// delete List; JLT 010417 	upDate ();}void VTreesWindow::doSelectTreesAll (void){	TItemSet itemSet (fTreesFile->GetTrees (false));	fTreesFile->SetItemSet (itemSet);	upDate ();}void VTreesWindow::doSelectTreesNone (void){	TItemSet itemSet;	fTreesFile->SetItemSet (itemSet);	upDate ();}void VTreesWindow::doShowTrees (void){	VDialog* dialog = TheApp->CreateDialog (dlgShowTrees, TRUE, FALSE);	VListBox* List = new VListBox (dialog, 4, TRUE); 	setListBoxTreeNames (fTreesFile->GetTrees (), List);	TItemSet itemSet;	itemSet += 	fTreesFile->GetCurTreeNumber ();	setListBoxSelection (itemSet, List);				dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit ();		switch (item)		{			case 3:					break;			case 5:				List->SelectAll ();				break;							default:				break;		}	} while (item > 2);		itemSet = getListBoxSelection (List);		TheApp->DestroyDialog ();	// delete List; JLT 010417 	if (item == 1)	{		CHECK_ (!itemSet.IsEmpty ());		WatchCursor ();		fTheTimer.StartTiming ();		*Log << EOLN << EOLN << "COMMAND: Show Trees '" << Name () << "'" << EOLN;				*Log << EOLN;				fTreesFile->ShowTrees (dummy, itemSet, true);				fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;						ArrowCursor ();	}	upDate ();}void VTreesWindow::printBigTree (void){	GrafPtr oldPort;	::GetPort (&oldPort);			// We have a picture than spans several pages	// Get page dimensions	VRect page;	Port.PrintingRect (page);	page.Inset (10, 10);		int image_height = page.GetHeight () * NumberOfPages;			if (Port.StartDoc ())	{		GrafPtr printerPort;		::GetPort (&printerPort);		for (int i = 0; i < NumberOfPages; i++)		{			Port.StartPage();			// Draw the picture for the whole image			VRect PictureRect;			PictureRect.Load (page.GetLeft(), page.GetTop(), page.GetRight(), image_height);			Rect sr = PictureRect.GetRectTool();				// Clip the picture to get just the band we want				// Save current clip region and clip the picture			RgnHandle saveClipRgn = ::NewRgn();				::GetClip( saveClipRgn );							// The clip area is one page's worth of the complete image			Rect clipRect;			int y_offset = i * page.GetHeight();			SetRect (&clipRect, 				page.GetLeft(), 				page.GetTop() + y_offset, 				page.GetRight(),  				page.GetTop() + y_offset + page.GetHeight()); 			::ClipRect (&clipRect); 				// Move origin of drawing so that top of the band of interest is at top of picture			::SetOrigin (page.GetLeft(), page.GetTop() + y_offset); 				// Draw (complete) picture here...			Draw (PictureRect);				// Restore previous clipping area			::SetClip( saveClipRgn );							::DisposeRgn( saveClipRgn );						// Restore origin and port			SetOrigin (0, 0);					Port.EndPage();					}		Port.EndDoc();	}	::SetPort (oldPort);}void VTreesWindow::Size (Point pt){	Rect growRect;	// maybe put so that can set min sizes	// also question of what if no space for names??	// set min sizes of trees window	growRect.top = 150 + 46; // sets vertical i.e. height 	growRect.left = 150; // sets horizontal i.e. width	// add 46 to height to compensate for toolbar	growRect.bottom = SHRT_MAX;	growRect.right  = SHRT_MAX;				long windSize = ::GrowWindow (window, pt, &growRect);			if (window != 0)	{			GrafPtr oldPort;		::GetPort (&oldPort);		::SetPort (window);		::EraseRect (&window->portRect);//		::SizeWindow (window, LoWord (windSize), HiWord (windSize), kNormalUpdates); kNormalUpdates = true			::SizeWindow (window, LoWord (windSize), HiWord (windSize), true);						::InvalRect (&window->portRect);		::SetPort (oldPort);		OnSize ();		OnActivate (TRUE);	}}void VTreesWindow::setListBoxTreeNames (const TItemSet& itemSet, VListBox* list, const bool selected) const{	CHECK_ (!itemSet.IsEmpty () && itemSet.LastItem () <= fTreesFile->GetTrees (selected));		#ifdef Macintosh		WatchCursor ();		list->DoDraw (FALSE);	#endif			for (unsigned int i = 1; i <= itemSet.GetItems (); ++i)		{			const TTreeName* name = NULL; // JLT 010412 made const			fTreesFile->GetIthTreeName (itemSet.IthItem (i), name, selected);			list->Append ((char*)name->Array ()); // JLT 010412 added cast		}			#ifdef Macintosh		list->DoDraw (TRUE);		ArrowCursor ();	#endif}void VTreesWindow::setListBoxSelection (const TItemSet& itemSet, VListBox* list) const{	CHECK_ (itemSet.LastItem () <= list->GetNumItems ());		for (unsigned int i = 1; i <= itemSet.GetItems (); ++i)		list->SetSelection ((itemSet.IthItem (i) - 1), TRUE);}TItemSet VTreesWindow::getListBoxSelection (VListBox* list) const{	int* p;	list->GetSelections (&p);	int ii,i = list->GetNumSelections ();	TItemSet itemSet;	for (ii = 0; ii < i; ++ii )		itemSet.AddToThis (p[ii] + 1);	return (itemSet);}void VTreesWindow::showTreeName (void){	char buf[128];	fTreesFile->GetIthTree (fTreesFile->GetCurTreeNumber (), fTree, true);//	unsigned int curTree = fTreesFile->IsIthSelected (fTreesFile->GetCurTreeNumber ()) ? fTreesFile->GetItemSet ().NumberOfItem (fTreesFile->GetCurTreeNumber ()) : 0;//	sprintf (buf, "%s  (%d/%d) (%d/%d)", fTree.GetName ().Array (), curTree, fTreesFile->GetTrees (true), fTreesFile->GetCurTreeNumber (), fTreesFile->GetTrees ());	sprintf (buf, "%s  (%d/%d)", fTree.GetName ().Array (), fTreesFile->GetCurTreeNumber (), fTreesFile->GetTrees ());	SetStatusText (buf);}void VTreesWindow::upDate (void){		CHECK_ (!(fTreesFile->GetTrees () < fTreesFile->GetCurTreeNumber ()));	fSelectTreeButton->Enable (true);	fPreviousTreeButton->Enable ((BOOL)(fTreesFile->GetCurTreeNumber () != 1));	fNextTreeButton->Enable ((BOOL)(fTreesFile->GetCurTreeNumber () < fTreesFile->GetTrees ()));	fPreviousSelectedTreeButton->Enable ((BOOL)(fItemSet.GetItems () && fItemSet.FirstItem () < fTreesFile->GetCurTreeNumber ()));	fNextSelectedTreeButton->Enable ((BOOL)(fItemSet.GetItems () && fTreesFile->GetCurTreeNumber () < fItemSet.LastItem ()));	fTreeDrawingButton->Enable (true);	#if USE_COMMANDLINE	CommandLine->SetNumber (fTreesFile->GetCurTreeNumber ());		#endif			showTreeName ();	Invalidate ();}VTreesWindow::VTreesWindow (TTreesFile* treesFile)	: fTreesFile (treesFile)	, fItemSet (treesFile->GetItemSet ()){	fTreesFile->SelectAll ();#if USE_COMMANDLINE	CommandLine = NULL;#endif}VTreesWindow::~VTreesWindow (void){	delete fPreviousTreeButton;	delete fNextTreeButton;	delete fSelectTreeButton;	delete fPreviousSelectedTreeButton;	delete fNextSelectedTreeButton;	delete fTreeDrawingButton;#if USE_COMMANDLINE	delete CommandLine;#endif}#if USE_COMMANDLINEvoid VTreesWindow::MaintainCursor (){	GrafPtr		savePort;	Point		pt;	::GetPort(&savePort);	::SetPort((GrafPtr)window);	::GetMouse(&pt);		if (!CommandLine->MouseOver (pt))		::SetCursor(&qd.arrow);	::SetPort(savePort);}void VTreesWindow::OnChar (char c, int flags){	if (CommandLine)	{		CommandLine->OnChar (c, flags);	}}void VTreesWindow::doSetTreeFromCommandLine (){	if (CommandLine)	{		int n = CommandLine->GetNumber();				if (n != -1)		{			if ((n >= 1) && (n <= fTreesFile->GetTrees ()))			{				fTreesFile->SetCurTreeNumber (n);				upDate ();			}				else			{				Beep();				CommandLine->SetNumber (fTreesFile->GetCurTreeNumber ());			}		}	}}#endif#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid VConsensusTreesWindow::OnActivate (BOOL becomingActive){	VTreesWindow::OnActivate (becomingActive);	if (becomingActive)	{	}	else	{ 	}}BOOL VConsensusTreesWindow::OnMenuCommand (CmdTool cmd){	BOOL processed = FALSE;		switch (cmd)	{//		case cmdConsensusCIC://			doConsensusCIC ();//			Invalidate ();					break;						default:			processed = VTreesWindow::OnMenuCommand (cmd);	}	OnActivate(TRUE);	return processed;}VConsensusTreesWindow::VConsensusTreesWindow (TConsensusTreesFile* consensusTreesFile) 	: 	VTreesWindow (consensusTreesFile) {	consensusTreesFile->SelectAll (); }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid VSourceTreesWindow::doAddTrees (void){	if (GetMultipleFiles ())	{				if (GetNumFiles ())		{			*Log << EOLN << EOLN << "COMMAND: Add Trees '" << Name () << "'" << EOLN;			WatchCursor ();			fTheTimer.StartTiming ();						unsigned int trees = ((TSourceTreesFile*)fTreesFile)->GetTotalTrees ();						// Output list of files			int i = 0;			int error = 0;			// error checking not being used...			while ((i <  GetNumFiles ()) && (error == 0))			{				char fbuf[64];				strcpy (fbuf, (char*)GetIthFile (i).sfFile.name);				p2cstr ((unsigned char *)fbuf);								OSErr	myErr;				short	fileNum;								myErr = ::FSpOpenDF (&GetIthFile(i).sfFile, fsRdPerm, &fileNum);				if (myErr != noErr) 				{					Message (MSG_ERROR, "Can't open file...");					error = 1;				}								// Get length of file				long myLength;				myErr = ::GetEOF (fileNum, &myLength);				if (myErr != noErr) 				{					Message (MSG_ERROR, "Error returned by GetEOFF");					error = 1;				}				// Create buffer for C++ stream, and read file's contents				char *buf = new char[myLength + 1];				myErr = ::FSRead (fileNum, &myLength, buf);						if (myErr != noErr) 				{					Message (MSG_ERROR, "Error reading file...");					error = 1;				}				buf[myLength] = '\0'; 				::FSClose (fileNum); 				// Call document's Open (...) method with filename and stream				char fileName[64];				strcpy (fileName, (char *)GetIthFile(i).sfFile.name);				p2cstr ((unsigned char *)fileName);								istringstream *s;				s = new istringstream (buf);								TSourceTreesFile* sourceTreesFile = NULL;						  	try			  	{			  		TSourceTreesFileList treesFiles;			  		// multiplesetsoftrees is set false as trees being added together anyway...			  		TReadTreesFile readFile (*s, fileName, treesFiles, !TheApp->Preferences.GetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", 1), false);			  		*Log << EOLN << "Reading File '" << fileName << "'" << EOLN;			  		readFile.ReadFile ();			  		CHECK_ (!treesFiles.IsEmpty ());			  		treesFiles.DetachItem (sourceTreesFile);			  	}			  	catch (EInputError e) 			  	{			  		Message (MSG_ERROR, (char*)e.what ()); // JLT 010412 			  		*Log << EOLN << EOLN << "Reading File '" << fileName << "' Aborted: " << e.what () << EOLN;					error = 1;			  	}			  	// trees are successfully readin.....			  	if (error == 0)			  	{			  		if (IsRooted () && !sourceTreesFile->IsRooted ())			  		{						*Log << EOLN << "Rooting Trees" << EOLN;						sourceTreesFile->Root ();			  						  		}			  		else if (!IsRooted () && sourceTreesFile->IsRooted ())			  		{						*Log << EOLN << "Unrooting Trees" << EOLN;														if (!sourceTreesFile->CanUnRoot ())						{							*Log << EOLN << "Unrooting Renders All Trees Inactive" << EOLN;							*Log << EOLN << "Adding Trees Skipped" << EOLN;						}						else							sourceTreesFile->UnRoot ();									  		}			  		// need to check space for trees and leaves....// maybe do as part of addtrees function...			  		// note may not actually need all the leaves.....I guess prune from 										// need to permanently prune leaves from trees.....					// need to check that space to add etc etc...			  		if (IsRooted () ? sourceTreesFile->IsRooted () : !sourceTreesFile->IsRooted ())			  		{			  			if (kMaxLeaves < ((TSourceTreesFile*)fTreesFile)->GetUnionLeaves (*sourceTreesFile))			  			{			  				*Log << EOLN << "The trees have too many leaves" << EOLN;			  				*Log << EOLN << "Adding Trees Skipped" << EOLN;			  			}			  			else			  			{				  			unsigned int trees2 = ((TSourceTreesFile*)fTreesFile)->GetTotalTrees ();				  			((TSourceTreesFile*)fTreesFile)->AddTrees (*sourceTreesFile);				  			trees2 = ((TSourceTreesFile*)fTreesFile)->GetTotalTrees () - trees2;				  			*Log << EOLN << "Adding " << (int)trees2 << ' ' << ((trees2 == 1) ? "Tree " : "Trees ") << EOLN;			  			}			  		}			  	}			  												// Clean up				if (sourceTreesFile)					delete (sourceTreesFile);				delete s;				delete buf;								i++;			}						trees = ((TSourceTreesFile*)fTreesFile)->GetTotalTrees () - trees;						*Log << EOLN << (int)trees << ' ' << ((trees == 1) ? "Tree " : "Trees ") << "Added In Total" << EOLN;			fTheTimer.StopTiming ();			*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;							ArrowCursor ();		}	}				upDate ();	}void VSourceTreesWindow::doAddOutGroup (void){	CHECK_ (IsRooted () && ((const TSourceTreesFile*)fTreesFile)->GetTotalLeaves (false, false) < kMaxLeaves);		WatchCursor ();	fTheTimer.StartTiming ();	*Log << EOLN << EOLN << "COMMAND: Graft Leaf As Outgroup '" << Name () << "'" << EOLN;		// ideally get from user	unsigned int i = 0;	TString name;	do	{		name = "Outgroup";		if (1 < ++i)			name.AddToThis (i);				} while (fTreesFile->IsLeaf (name));		*Log << EOLN << "Leaf " << name.Array () << ' ' << "Grafted To " << (int)((TSourceTreesFile*)fTreesFile)->GetTotalTrees () << ' ' << "Rooted " << (((TSourceTreesFile*)fTreesFile)->GetTotalTrees () == 1 ? "Tree " : "Trees ") << "As Outgroup" << EOLN;		((TSourceTreesFile*)fTreesFile)->GraftLeafAsOutgroup (name);			fTheTimer.StopTiming ();	*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;					ArrowCursor ();	upDate ();}// RDMPvoid VSourceTreesWindow::doCompareProfiles (){	VDialogPtr dialog = TheApp->Create_Dialog (152, FALSE, FALSE);	VListBoxPtr List = new VListBox (dialog, 5);		TheApp->ListAllViews (List); 		dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit ();		switch (item)		{			default:				break;							}	} while (item > 2); // loop until user clicks 'Cancel' or 'OK' buttons		if (item == 1)	{		// User pressed OK, so get any info we want here	}		TheApp->DestroyDialog();	// delete List; JLT 010417 }void VSourceTreesWindow::doComponentConsensus (void){	VDialog* dialog = TheApp->CreateDialog (dlgComponentConsensus, TRUE, FALSE);			bool strict = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "STRICT", 0));		bool semistrict = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "SEMI_STRICT", 0));	bool majorityrule = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "MAJORITY_RULE", 0));	bool minoritycompatible = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "MINORITY_COMPATIBLE", 0));	bool showComponents = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "SHOW_COMPONENTS", 0));	bool showDifferences = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "SHOW_DIFFERENCES", 0));	bool sourceInfo = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "SOURCE_INFO", 0));	bool consensusInfo = (bool)(TheApp->Preferences.GetIntPreference ("COMPONENT_CONSENSUS", "CONSENSUS_INFO", 0));		double sourceInformationInBits = 0;	double consensusInformationInBits = 0;		dialog->SetItemState (4, strict);	dialog->SetItemState (5, semistrict);	dialog->SetItemState (6, majorityrule);	dialog->SetItemState (7, minoritycompatible);	dialog->SetItemState (8, showComponents);	dialog->SetItemState (9, showDifferences);		dialog->SetItemState (12, sourceInfo);	dialog->SetItemState (13, consensusInfo);		dialog->EnableItem (1, dialog->GetItemState (4) || dialog->GetItemState (5) || dialog->GetItemState (6) || dialog->GetItemState (8));	dialog->EnableItem (7, dialog->GetItemState (6));//	dialog->EnableItem (9, dialog->GetItemState (6) || dialog->GetItemState (8));	dialog->EnableItem (9, dialog->GetItemState (8));		bool isSourceInfo = (bool)((const TSourceTreesFile*)fTreesFile)->IsTotalInformation ();	dialog->EnableItem (12, isSourceInfo);	dialog->EnableItem (13, dialog->GetItemState (4)); 		dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit();		switch (item)		{			case 4:				dialog->ToggleDlgItem (4, NULL);				break;			case 5:				dialog->ToggleDlgItem (5, NULL);				break;			case 6:				dialog->ToggleDlgItem (6, NULL);				break;			case 7:				dialog->ToggleDlgItem (7, NULL);				break;			case 8:				dialog->ToggleDlgItem (8, NULL);				break;			case 9:				dialog->ToggleDlgItem (9, NULL);				break;			case 12:				dialog->ToggleDlgItem (12, NULL);				break;			case 13:				dialog->ToggleDlgItem (13, NULL);				break;			default:				break;		}		dialog->EnableItem (1, (BOOL)(dialog->GetItemState (4) || dialog->GetItemState (5) || dialog->GetItemState (6) || dialog->GetItemState (8)));		dialog->EnableItem (7, dialog->GetItemState (6));//		dialog->EnableItem (9, dialog->GetItemState (6) || dialog->GetItemState (8));		dialog->EnableItem (9, dialog->GetItemState (8));		dialog->EnableItem (13, dialog->GetItemState (4)); 			} while (item > 2);	if (item == 1)	{		strict = dialog->GetItemState (4);		semistrict = dialog->GetItemState (5);		majorityrule = dialog->GetItemState (6);		minoritycompatible = dialog->GetItemState (7);		showComponents = dialog->GetItemState (8);		showDifferences = dialog->GetItemState (9);				sourceInfo = dialog->GetItemState (12);		consensusInfo = dialog->GetItemState (13);		}		TheApp->DestroyDialog ();		if (item == 1)	{		WatchCursor ();		TMajorityRuleComponentConsensus componentConsensus ((TSourceTreesFile*)fTreesFile);//		if (!((TSourceTreesFile*)fTreesFile)->IsClusterList ())//		{		*Log << EOLN << EOLN << "COMMAND: Component Consensus '" << Name () << "'" << EOLN;		fTheTimer.StartTiming ();					componentConsensus.Consensus ();		if (gAborted)		{			*Log << EOLN << "Component Consensus Aborted: By User" << EOLN;		}		else		{			*Log << EOLN << "Component Consensus of " << (int)componentConsensus.GetTreesDone () << ' ' << (IsRooted () ? "Rooted " : "Unrooted ") << ((componentConsensus.GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;			if (sourceInfo && isSourceInfo)			{				sourceInformationInBits = ((TSourceTreesFile*)fTreesFile)->GetTotalInformation (true);				*Log << EOLN << "Source Information (CIC): " << sourceInformationInBits << " bits" << EOLN;			}		}						fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;						if (!gAborted)		{			if (strict)			{						*Log << EOLN << EOLN << "COMMAND: Strict Component Consensus '" << Name () << "'" << EOLN;				fTheTimer.StartTiming ();													TStrictComponentConsensus* strictConsensus  = new TStrictComponentConsensus ((TSourceTreesFile*)fTreesFile);				strictConsensus->Consensus ();				CHECK_ (!gAborted);				TTreesDoc* treeDoc = new TTreesDoc;				treeDoc->New (strictConsensus);									TheApp->AppendDocument (treeDoc);				*Log << EOLN << "Strict Component Consensus Tree of " << (int)strictConsensus->GetTreesDone () << ' ' << (IsRooted () ? "Rooted " : "Unrooted ") << ((strictConsensus->GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;				*Log << EOLN;				strictConsensus->ShowTrees (dummy, 1, false);				if (consensusInfo)				{					TTree tree;					strictConsensus->GetTreesBlock ().GetIthTree (1, tree);					consensusInformationInBits = tree.GetCIC ();					*Log << EOLN << "Consensus Information (CIC): " << consensusInformationInBits << " bits" << EOLN;					if (sourceInfo && isSourceInfo)					{						double consensusEfficiencyInBits = 1.0;						if (consensusInformationInBits != 0 || sourceInformationInBits != 0)							consensusEfficiencyInBits = consensusInformationInBits / sourceInformationInBits;						*Log << EOLN << "Consensus Efficiency: " << consensusEfficiencyInBits << EOLN ;						}				}				fTheTimer.StopTiming ();				*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;					}			if (semistrict)			{						*Log << EOLN << EOLN << "COMMAND: Semi Strict Component Consensus '" << Name () << "'" << EOLN;				fTheTimer.StartTiming ();													TSemiStrictComponentConsensus* semiStrictConsensus  = new TSemiStrictComponentConsensus ((TSourceTreesFile*)fTreesFile);				semiStrictConsensus->Consensus ();								CHECK_ (!gAborted);				TTreesDoc* treeDoc = new TTreesDoc;				treeDoc->New (semiStrictConsensus);									TheApp->AppendDocument (treeDoc);				*Log << EOLN << "Semi Strict Component Consensus Tree of " << (int)semiStrictConsensus->GetTreesDone () << ' ' << (IsRooted () ? "Rooted " : "Unrooted ") << ((semiStrictConsensus->GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;				*Log << EOLN;				semiStrictConsensus->ShowTrees (dummy, 1, false);								fTheTimer.StopTiming ();				*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;					}			if (majorityrule)			{				*Log << EOLN << EOLN << "COMMAND: Majority Rule " << (minoritycompatible ? "(and Minority Compatible) " : "") << "Component Consensus '" << Name () << "'" << EOLN;				fTheTimer.StartTiming ();							TMajorityRuleComponentConsensus* majorityRuleConsensus = new TMajorityRuleComponentConsensus ((TSourceTreesFile*)fTreesFile, minoritycompatible, showDifferences);				majorityRuleConsensus->Consensus ();				CHECK_ (!gAborted);				TTreesDoc* treeDoc = new TTreesDoc;							treeDoc->New (majorityRuleConsensus);					TheApp->AppendDocument (treeDoc);				*Log << EOLN << "Majority Rule " << (minoritycompatible ? "(and Minority Compatible) " : "") << "Component Consensus Tree of " << (int)majorityRuleConsensus->GetTreesDone () << ' ' << (IsRooted () ? "Rooted " : "Unrooted ") << ((majorityRuleConsensus->GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;				*Log << EOLN;				majorityRuleConsensus->ShowTrees (dummy, 1, false);								fTheTimer.StopTiming ();				*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;					}			if (showComponents)			{				*Log << EOLN << EOLN << "COMMAND: Show All Components '" << Name () << "'" << EOLN;				fTheTimer.StartTiming ();											*Log << EOLN << "All Components from " << (int)componentConsensus.GetTreesDone () << ' ' << (IsRooted () ? "Rooted " : "Unrooted ") << ((componentConsensus.GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;				*Log << EOLN;				((TSourceTreesFile*)fTreesFile)->WriteClustersToLog (true, showDifferences);								fTheTimer.StopTiming ();				*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;					}		}		else			gAborted = FALSE;				if (strict)			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "STRICT", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "STRICT", 0, TRUE);		if (semistrict)			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "SEMI_STRICT", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "SEMI_STRICT", 0, TRUE);		if (majorityrule)			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "MAJORITY_RULE", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "MAJORITY_RULE", 0, TRUE);		if (minoritycompatible)			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "MINORITY_COMPATIBLE", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "MINORITY_COMPATIBLE", 0, TRUE);		if (showComponents)			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "SHOW_COMPONENTS", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "SHOW_COMPONENTS", 0, TRUE);		if (showDifferences)			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "SHOW_DIFFERENCES", 1, TRUE);		else			TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "SHOW_DIFFERENCES", 0, TRUE);				TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "SOURCE_INFO", (sourceInfo ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("COMPONENT_CONSENSUS", "CONSENSUS_INFO", (consensusInfo ? 1 : 0), TRUE);			ArrowCursor ();		}			upDate ();}void VSourceTreesWindow::doDecayInput (const bool fuse){			bool continu = true;;	if (((const TSourceTreesFile*)fTreesFile)->IsBootstrap ())		continu = (bool)(ANS_YES == Message (MSG_YN, "The active source trees are bootstrap trees. It only really makes sense to decay a set of MPTs.            Continue?"));	if (continu && !((const TSourceTreesFile*)fTreesFile)->IsEqualLeafSets (true))		continu = (bool)(ANS_YES == Message (MSG_YN, "The active source trees do not have identical leaf sets. It only really makes sense to decay a set of MPTs.      	      Continue?"));	TString leafName;	unsigned int leafNumber = 0;		if (continu)	{		if (IsRooted ())		{				VDialog* dialog = TheApp->CreateDialog (dlgChooseOutgroup, TRUE, FALSE);			VListBox* List = new VListBox (dialog, 4, FALSE, TRUE); 						WatchCursor ();			List->DoDraw (FALSE);						const TLeafSet intersectionLeafSets = ((const TSourceTreesFile*)fTreesFile)->GetTotalLeafSet (true, true);			TTreeName name;			for (intersectionLeafSets.FirstLeaf (); intersectionLeafSets.CurLeaf (); intersectionLeafSets.NextLeaf ())				List->Append ((char*)fTreesFile->GetLeafName (intersectionLeafSets.CurLeaf ())); // JLT 010412			List->SetStringSelection ((char*)((const TSourceTreesFile*)fTreesFile)->GetLeafName (intersectionLeafSets.FirstLeaf ())); // JLT 010412 			List->DoDraw (TRUE);			ArrowCursor ();			dialog->Show();			int item;			do			{				item = TheApp->DialogItemHit ();				switch (item)				{					default:						break;				}			} while (item > 2);			leafName = List->String (List->GetSelection ());			leafNumber = fTreesFile->GetLeafNumber (leafName.Array ());							TheApp->DestroyDialog ();			// delete List; JLT 010417 						if (item == 1)			{											WatchCursor ();										((TSourceTreesFile*)fTreesFile)->ReRoot (leafNumber);								upDate ();								TLeafSet leafSet = ((TSourceTreesFile*)fTreesFile)->GetPrunedLeafSet ();				leafSet += leafNumber;				((TSourceTreesFile*)fTreesFile)->PruneLeaves (leafSet);								ArrowCursor ();			}			else				continu = false;		}	}			if (continu)	{		VDialog* dialog = TheApp->CreateDialog (dlgLengthMPTs, TRUE, FALSE);							dialog->EnableItem (1, false);				dialog->Show ();		int item;		TString length;		do		{			item = TheApp->DialogItemHit ();			switch (item)			{				case 4:					length = dialog->GetItemText (4);					if (!length.IsInteger ())					{						Message (MSG_ERROR, "Length of MPTs must be an integer");						length.SetNull ();						dialog->SetItemText (4, length.Array ());					}					break;									default:					break;			}			dialog->EnableItem (1, !length.IsNull ());		} while (item > 2 || (item == 1 && length.IsNull ()));				TheApp->DestroyDialog ();		if (item == 1)		{			unsigned int lengthMPTs = length.ToInteger ();			 							TString inFileName;			char* bufin = OpenFile (401, inFileName);			if (bufin != NULL)			{				istringstream sin (bufin);				TString logFileName;				char* buflog = OpenFile (402, logFileName);				if (buflog != NULL)				{					istringstream slog (buflog);										WatchCursor ();					fTheTimer.StartTiming ();										*Log << EOLN << EOLN << "COMMAND: " << (fuse ? "Double Decay Analysis Input '" : "Leaf Stability (Decay) Input '") << Name () << "'" << EOLN;										TDecayAnalysis* decayAnalysis = new  TDecayAnalysis ((TSourceTreesFile*)fTreesFile);										decayAnalysis->Input (sin, slog, leafName, inFileName, logFileName, lengthMPTs, fuse);					decayAnalysis->Consensus ();										if (!gAborted)					{						*Log << EOLN << "Leaf Stabilities for " << (IsRooted () ? "Rooted " : "Unrooted ") << ((decayAnalysis->GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;						decayAnalysis->WriteLeafStabilities (dummy);						*Log << EOLN;												if (fuse)						{							decayAnalysis->Fuse (); // makes basic trees in here...what about abort and reader update														if (gAborted)							{								*Log << EOLN << EOLN << "Double Decay Analysis Fusion Aborted before Completion" << EOLN;								if (decayAnalysis->IsSplits ())								{									*Log << EOLN << "**Splits in table are correct**" << EOLN;								}								gAborted = false;							}							else								*Log << EOLN << EOLN << "Double Decay Analysis for " << (IsRooted () ? "Rooted " : "Unrooted ") << ((decayAnalysis->GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;														if (decayAnalysis->IsSplits ())							{								decayAnalysis->WriteAsTable (dummy);								*Log << EOLN;																TTreesDoc* treeDoc = new TTreesDoc;								treeDoc->New (decayAnalysis);									TheApp->AppendDocument (treeDoc);							}							else								delete (decayAnalysis);						}					}					else					{						*Log << EOLN << (fuse ? "Double Decay Analysis " : "Leaf Stability (Decay) ") << "Aborted" << EOLN;						gAborted = false;						delete (decayAnalysis);					}					fTheTimer.StopTiming ();					*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;					ArrowCursor ();										delete buflog;				}				delete bufin;			}		}	}	CHECK_ (leafNumber ? IsRooted () : !IsRooted ());		if (leafNumber)	{			TLeafSet leafSet = ((TSourceTreesFile*)fTreesFile)->GetPrunedLeafSet ();			leafSet -= leafNumber;			((TSourceTreesFile*)fTreesFile)->PruneLeaves (leafSet);		}	upDate ();}void VSourceTreesWindow::doDecayOutput (const bool fuse){		bool continu = true;;	if (((const TSourceTreesFile*)fTreesFile)->IsBootstrap ())		continu = (bool)(ANS_YES == Message (MSG_YN, "The active source trees are bootstrap trees. It only really makes sense to decay a set of MPTs.            Continue?"));	if (continu && !((const TSourceTreesFile*)fTreesFile)->IsEqualLeafSets (true))		continu = (bool)(ANS_YES == Message (MSG_YN, "The active source trees do not have identical leaf sets. It only really makes sense to decay a set of MPTs.      	      Continue?"));	TString leafName;	unsigned int leafNumber = 0;		if (continu)	{		if (IsRooted ())		{			VDialog* dialog = TheApp->CreateDialog (dlgChooseOutgroup, TRUE, FALSE);			VListBox* List = new VListBox (dialog, 4, FALSE, TRUE); 						WatchCursor ();			List->DoDraw (FALSE);						const TLeafSet intersectionLeafSets = ((const TSourceTreesFile*)fTreesFile)->GetTotalLeafSet (true, true);			TTreeName name;			for (intersectionLeafSets.FirstLeaf (); intersectionLeafSets.CurLeaf (); intersectionLeafSets.NextLeaf ())				List->Append ((char*)fTreesFile->GetLeafName (intersectionLeafSets.CurLeaf ())); // JLT 01041							List->SetStringSelection ((char*)((const TSourceTreesFile*)fTreesFile)->GetLeafName (intersectionLeafSets.FirstLeaf ())); // JLT 010412			List->DoDraw (TRUE);			ArrowCursor ();			dialog->Show();			int item;			do			{				item = TheApp->DialogItemHit ();				switch (item)				{					default:						break;				}			} while (item > 2);						leafName = List->String (List->GetSelection ());			leafNumber = fTreesFile->GetLeafNumber (leafName.Array ());							TheApp->DestroyDialog ();			// delete List; JLT 010417 						if (item == 1)			{											WatchCursor ();										((TSourceTreesFile*)fTreesFile)->ReRoot (leafNumber);								upDate ();				TLeafSet leafSet = ((TSourceTreesFile*)fTreesFile)->GetPrunedLeafSet ();				leafSet += leafNumber;				((TSourceTreesFile*)fTreesFile)->PruneLeaves (leafSet);								ArrowCursor ();			}			else				continu = false;		}	}			if (continu)	{		VDialog* dialog = TheApp->CreateDialog (dlgSearchOptions, TRUE, FALSE);					bool heuristic = (bool)(TheApp->Preferences.GetIntPreference ("DECAY_ANALYSIS", "HEURISTIC", 1));				TString search;					dialog->SetItemState (4, !heuristic);		dialog->SetItemState (5, heuristic);		search = dialog->GetItemState (4) ? "addseq=simple" : "addseq=random nreps=10 rseed=1";			dialog->SetItemText (6, search.Array ());				dialog->Show ();		int item;		do		{			item = TheApp->DialogItemHit();			switch (item)			{				case 4:					dialog->ToggleDlgItem (4, NULL);					dialog->ToggleDlgItem (5, NULL);					search = dialog->GetItemState (4) ? "addseq=simple" : "addseq=random nreps=10 rseed=1";						dialog->SetItemText (6, search.Array ());					break;				case 5:					dialog->ToggleDlgItem (5, NULL);					dialog->ToggleDlgItem (4, NULL);					search = dialog->GetItemState (4) ? "addseq=simple" : "addseq=random nreps=10 rseed=1";						dialog->SetItemText (6, search.Array ());					break;									case 6:					search = dialog->GetItemText (6);					break;				default:					break;			}			dialog->EnableItem (1, !search.IsNull ());				} while (item > 2 || (item == 1 && search.IsNull ()));		if (item == 1)		{				heuristic = dialog->GetItemState (5);		}				TheApp->DestroyDialog ();		if (item == 1)		{			VFile TreeFile;			TreeFile.SetCreator ('PAUP');						if (TreeFile.GetOutputFileName ((char*)(fTreesFile->IsRooted () ? "Save triplets as:" : "Save quartets as:"), "Untitled")) // JLT 010412			{				WatchCursor ();				fTheTimer.StartTiming ();							*Log << EOLN << EOLN << "COMMAND: " << (fuse ? "Double Decay Analysis Output '" : "Leaf Stability (Decay) Output '") << Name () << "'" << EOLN;				ostream *s = TreeFile.GetOutputStream ();				if (!gAborted)				{						TDecayAnalysis decayAnalysis ((TSourceTreesFile*)fTreesFile);										TString fileName = TreeFile.GetShortName ();					decayAnalysis.Output (*s, leafName, fileName, heuristic, search);					decayAnalysis.Consensus ();					CHECK_ (decayAnalysis.GetTreesDone ());				}								TreeFile.Close ();				if (gAborted)				{					*Log << EOLN << (fuse ? "Double Decay Analysis Output Aborted" : "Leaf Stability (Decay) Output Aborted") << EOLN;					gAborted = false;				}				else				{					*Log << EOLN << (IsRooted () ? "Triplet " : "Quartet ") << "Constraints saved to '" << TreeFile.GetShortName () << "'" << EOLN;				}													fTheTimer.StopTiming ();				*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;				ArrowCursor ();								TheApp->Preferences.SetIntPreference ("DECAY_ANALYSIS", "HEURISTIC", (heuristic ? 1 : 0), TRUE);			}		}	}	CHECK_ (leafNumber ? IsRooted () : !IsRooted ());		if (leafNumber)	{			TLeafSet leafSet = ((TSourceTreesFile*)fTreesFile)->GetPrunedLeafSet ();			leafSet -= leafNumber;			((TSourceTreesFile*)fTreesFile)->PruneLeaves (leafSet);		}	upDate ();}void VSourceTreesWindow::doReducedConsensus (void){		VDialog* dialog = TheApp->CreateDialog (dlgReducedConsensus, TRUE, FALSE);			bool sourceInfo = (bool)(TheApp->Preferences.GetIntPreference ("REDUCED_CONSENSUS", "SOURCE_INFO", 0));	bool consensusInfo = (bool)(TheApp->Preferences.GetIntPreference ("REDUCED_CONSENSUS", "CONSENSUS_INFO", 0));		double sourceInformationInBits = 0;	double consensusInformationInBits = 0;			dialog->SetItemState (5, sourceInfo);	dialog->SetItemState (6, consensusInfo);			bool isSourceInfo = (bool)((const TSourceTreesFile*)fTreesFile)->IsTotalInformation ();	dialog->EnableItem (5, isSourceInfo);		dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit();		switch (item)		{			case 5:				dialog->ToggleDlgItem (5, NULL);				break;			case 6:				dialog->ToggleDlgItem (6, NULL);				break;			default:				break;		}			} while (item > 2);	if (item == 1)	{				sourceInfo = dialog->GetItemState (5);		consensusInfo = dialog->GetItemState (6);	}		TheApp->DestroyDialog ();	if (item == 1)	{		WatchCursor ();		fTheTimer.StartTiming ();					*Log << EOLN << EOLN << "COMMAND: Strict Reduced Consensus '" << Name () << "'" << EOLN;					TStrictReducedConsensus* strictConsensus  = new TStrictReducedConsensus ((TSourceTreesFile*)fTreesFile);		strictConsensus->Consensus ();		CHECK_ (strictConsensus->GetTreesDone ());		if (!gAborted)		{			if (!strictConsensus->IsProfileEmpty ())			{							if (sourceInfo && isSourceInfo)				{					sourceInformationInBits = ((TSourceTreesFile*)fTreesFile)->GetTotalInformation (true);					*Log << EOLN << "Source Information (CIC): " << sourceInformationInBits << " bits" << EOLN;				}				TTreesDoc* treeDoc = new TTreesDoc;				treeDoc->New (strictConsensus);					TheApp->AppendDocument (treeDoc);								*Log << EOLN << "Strict Partial Splits of " << (int)strictConsensus->GetTreesDone () << ' ' << ((IsRooted ()) ? "Rooted " : "Unrooted ") << ((strictConsensus->GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;						*Log << EOLN;				((const TSourceTreesFile*)fTreesFile)->WriteSplitsToLog (false);												if (consensusInfo)				{					TTree tree;					for (unsigned int i = 1; strictConsensus->GetTreesBlock ().GetIthTree (i, tree); ++i)					{						consensusInformationInBits = tree.GetCIC ();						*Log << EOLN << "Strict Reduced CT " << (int)i << ":" << EOLN;						*Log << EOLN << "Consensus Information (CIC): " << consensusInformationInBits << " bits" << EOLN;						if (sourceInfo && isSourceInfo)						{							double consensusEfficiencyInBits = 1;							if (consensusInformationInBits != 0 || sourceInformationInBits != 0)								consensusEfficiencyInBits = consensusInformationInBits / sourceInformationInBits;							*Log << EOLN << "Consensus Efficiency: " << consensusEfficiencyInBits << EOLN ;							}					}				}			}			else			{				TWrapString wrapString (kFileWidth - 10);				wrapString.SetNewLine ();				wrapString.AddToThis ("The");				TString string;				string.AddToThis (strictConsensus->GetTreesDone ());				wrapString.AddToThis (string);				wrapString.AddToThis ((IsRooted ()) ? "Rooted" : "Unrooted");				wrapString.AddToThis ((strictConsensus->GetTreesDone () == 1) ? "Tree" : "Trees");				wrapString.AddToThis ("share");				wrapString.AddToThis ("no");				wrapString.AddToThis ("Strict");				wrapString.AddToThis ("Partial");				wrapString.AddToThis ("Splits");				wrapString.SetNewLine ();				*Log << wrapString.GetString ().Array ();			}		}		else		{			*Log << EOLN << "Strict Reduced Consensus Aborted: By User" << EOLN;			delete (strictConsensus);			gAborted = false;		}		fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();				TheApp->Preferences.SetIntPreference ("REDUCED_CONSENSUS", "SOURCE_INFO", (sourceInfo ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("REDUCED_CONSENSUS", "CONSENSUS_INFO", (consensusInfo ? 1 : 0), TRUE);		}	upDate ();}void VSourceTreesWindow::doAdamsConsensus (void){	CHECK_ (IsRooted ());	VDialog* dialog = TheApp->CreateDialog (dlgAdamsConsensus, TRUE, FALSE);			bool sourceInfo = (bool)(TheApp->Preferences.GetIntPreference ("ADAMS_CONSENSUS", "SOURCE_INFO", 0));	bool consensusInfo = (bool)(TheApp->Preferences.GetIntPreference ("ADAMS_CONSENSUS", "CONSENSUS_INFO", 0));		double sourceInformationInBits = 0;	double consensusInformationInBits = 0;			dialog->SetItemState (5, sourceInfo);	dialog->SetItemState (6, consensusInfo);			bool isSourceInfo = (bool)((const TSourceTreesFile*)fTreesFile)->IsTotalInformation ();	dialog->EnableItem (5, isSourceInfo);		dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit();		switch (item)		{			case 5:				dialog->ToggleDlgItem (5, NULL);				break;			case 6:				dialog->ToggleDlgItem (6, NULL);				break;			default:				break;		}			} while (item > 2);	if (item == 1)	{				sourceInfo = dialog->GetItemState (5);		consensusInfo = dialog->GetItemState (6);	}		TheApp->DestroyDialog ();	if (item == 1)	{		WatchCursor ();				*Log << EOLN << EOLN << "COMMAND: Adams Consensus '" << Name () << "'" << EOLN;		fTheTimer.StartTiming ();					TAdamsConsensus* adamsConsensus = new TAdamsConsensus ((TSourceTreesFile*)fTreesFile);		adamsConsensus->Consensus ();		if (!gAborted)		{						if (sourceInfo && isSourceInfo)			{				sourceInformationInBits = ((TSourceTreesFile*)fTreesFile)->GetTotalInformation (true);				*Log << EOLN << "Source Information (CIC): " << sourceInformationInBits << " bits" << EOLN;			}			TTreesDoc* treeDoc = new TTreesDoc;			treeDoc->New (adamsConsensus);			TheApp->AppendDocument (treeDoc);			*Log << EOLN << "Adams Consensus Tree of " << (int)adamsConsensus->GetTreesDone () << ((IsRooted ()) ? " Rooted " : " Unrooted ") << ((adamsConsensus->GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN << EOLN;						adamsConsensus->ShowTrees (dummy, 1, false);						if (consensusInfo)			{				TTree tree;				adamsConsensus->GetTreesBlock ().GetIthTree (1, tree);									TTreeCIC treeCIC (tree.IsRooted ());				treeCIC.AddTree (tree); // switching to Adams!!! needs debugging ???				treeCIC.CalcCICs ();				if (!gAborted)				{					treeCIC.IthTreeCIC (1);					consensusInformationInBits = treeCIC.IthTreeCIC (1);					*Log << EOLN << "Consensus Information (CIC): " << consensusInformationInBits << " bits" << EOLN;					if (sourceInfo && isSourceInfo)					{						double consensusEfficiencyInBits = 1;						if (consensusInformationInBits != 0 || sourceInformationInBits != 0)							consensusEfficiencyInBits = consensusInformationInBits / sourceInformationInBits;						*Log << EOLN << "Consensus Efficiency: " << consensusEfficiencyInBits << EOLN ;						}				}				else					gAborted = false;			}		}		if (gAborted)		{			*Log << EOLN << "Adams Consensus Aborted: By User" << EOLN;			gAborted = FALSE;			delete (adamsConsensus);		}			fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed() << EOLN;		ArrowCursor ();		TheApp->Preferences.SetIntPreference ("ADAMS_CONSENSUS", "SOURCE_INFO", (sourceInfo ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("ADAMS_CONSENSUS", "CONSENSUS_INFO", (consensusInfo ? 1 : 0), TRUE);	}	upDate ();}void VSourceTreesWindow::doCondenseTrees (void){	VDialog* dialog = TheApp->CreateDialog (dlgCondenseTrees, TRUE, FALSE);	dialog->CheckRadioButton (4, 8, 4);	dialog->EnableItem (8,((BOOL)(((TSourceTreesFile*)fTreesFile)->IsBootstrap () && dialog->GetItemState (9))));	dialog->EnableItem (9,((BOOL)(((TSourceTreesFile*)fTreesFile)->IsBootstrap ())));	dialog->Show();	int item;	do	{		item = TheApp->DialogItemHit();		switch (item)		{			case 4:				dialog->CheckRadioButton (4, 8, 4);				break;							case 5:				dialog->CheckRadioButton (4, 8, 5);				break;			case 6:				dialog->CheckRadioButton (4, 8, 6);				break;			case 7:				dialog->CheckRadioButton (4, 8, 7);				break;			case 8:				dialog->CheckRadioButton (4, 8, 8);				if (!dialog->GetItemState (9) && dialog->GetItemState (8))					dialog->ToggleDlgItem (9, NULL);				break;			case 9:				dialog->ToggleDlgItem (9, NULL);				if (!dialog->GetItemState (9) && dialog->GetItemState (8))					dialog->CheckRadioButton (4, 8, 4);				break;			default:				break;		}		dialog->EnableItem (8,((BOOL)(((TSourceTreesFile*)fTreesFile)->IsBootstrap () && dialog->GetItemState (9))));	} while (item > 2);	const int choice = dialog->GetGroupChoice (4, 8);	const bool bootstrap = dialog->GetItemState (9);	CHECK_ (choice != 8 || bootstrap);		TheApp->DestroyDialog ();	upDate ();		if (item == 1)	{		WatchCursor ();		*Log << EOLN << EOLN << "COMMAND: Condense Trees '" << Name () << "'" << EOLN;			fTheTimer.StartTiming ();		const unsigned int trees = fTreesFile->GetTrees ();				switch (choice)		{				case 4:				((TSourceTreesFile*)fTreesFile)->CondenseTrees (kWeightSum, bootstrap);				break;			case 5:				((TSourceTreesFile*)fTreesFile)->CondenseTrees (kWeightMean, bootstrap);								break;			case 6:				((TSourceTreesFile*)fTreesFile)->CondenseTrees (kWeightMax, bootstrap);								break;			case 7:				((TSourceTreesFile*)fTreesFile)->CondenseTrees (kWeightMin, bootstrap);								break;			case 8:				((TSourceTreesFile*)fTreesFile)->CondenseTrees (kWeightBootstrap, bootstrap);								break;			default:				CHECK (0);				break;		}				unsigned int diff = (trees - fTreesFile->GetTrees ());				*Log << EOLN << (int)diff << ' '  << ((diff == 1) ? "Tree " : "Trees ") << "Deleted" << EOLN;				*Log << EOLN << (int)fTreesFile->GetTrees () << ' ' << ((fTreesFile->GetTrees () == 1) ? "Tree " : "Trees ") << "Remaining" << EOLN;		if (bootstrap)			*Log << EOLN << ((diff == 1) ? "Tree " : "Trees ") << "Treated As Bootstrap" << EOLN;		*Log << EOLN << "Remaining Trees Weighted ";				if (choice == 8)			*Log << "Bootstrap" << EOLN;		else		{			switch (choice)			{					case 4:					*Log << "Sum of Duplicate Trees";					break;				case 5:					*Log << "Mean of Duplicate Trees";					break;				case 6:					*Log << "Max of Duplicate Trees";					break;				case 7:					*Log << "Min of Duplicate Trees";					break;				default:					CHECK_ (0);					break;			}			if (bootstrap)				*Log << ' ' << "In Same Bootstrap Replicate";			*Log << EOLN;		}					fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VSourceTreesWindow::doMRP (void){		bool components = TheApp->Preferences.GetIntPreference ("MRP", "COMPONENTS", 1);	bool purvisCoding = (bool)TheApp->Preferences.GetIntPreference ("MRP", "PURVISCODING", 0);	VDialog* dialog = TheApp->CreateDialog (dlgMRP, TRUE, FALSE);			components ? dialog->CheckRadioButton (4, 5, 4) : dialog->CheckRadioButton (4, 5, 5);	IsRooted () ? dialog->SetItemText (5, "Triplet coding") : dialog->SetItemText (5, "Quartet coding");	dialog->SetItemState (6, purvisCoding);	dialog->EnableItem (6, components && IsRooted ());			dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit ();		switch (item)		{			case 3:					break;			case 4:				dialog->CheckRadioButton (4, 5, 4);				break;							case 5:				dialog->CheckRadioButton (4, 5, 5);				break;			case 6:				dialog->ToggleDlgItem (6, NULL);				break;			default:				break;		}		dialog->EnableItem (6, dialog->GetItemState (4) && IsRooted ());	} while (item > 2);		if (item == 1)	{		components = dialog->GetItemState (4);		purvisCoding = dialog->GetItemState (6);	}		TheApp->DestroyDialog ();		if (item == 1)	{		*Log << EOLN << EOLN << "COMMAND: Matrix Representation '" << Name () << "'" << EOLN;		WatchCursor ();		fTheTimer.StartTiming ();		TMRPConsensus mrp ((TSourceTreesFile*)fTreesFile, components, components && purvisCoding && IsRooted ());		if (!mrp.CalcCharacters ())		{			Message (MSG_INFO, "Data file is too big. Try reducing the number of trees and/or leaves");			*Log << EOLN << "Matrix Representation Aborted: Data file is too big. Try reducing the number of trees and/or leaves" << EOLN;		}		else		{			VFile TreeFile;			TreeFile.SetCreator ('PAUP');			if (TreeFile.GetOutputFileName ("Save Matrix Representation as:", "Untitled"))			{									TString name (Name ());				mrp.SetFile (*TreeFile.GetOutputStream (), name);												mrp.Consensus ();				if (!gAborted)					*Log << EOLN << "Matrix Representation of " << (int)mrp.GetTreesDone () << ' ' << (IsRooted () ? "Rooted " : "Unrooted ") << ((mrp.GetTreesDone () == 1) ? "Tree " : "Trees ") << "Saved to '" << TreeFile.GetShortName () << "'" << EOLN;				else				{					*Log << EOLN << "Matrix Representation Aborted: By User" << EOLN;					gAborted = FALSE;				}				TreeFile.Close ();							}		}				fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();		components ? TheApp->Preferences.SetIntPreference ("MRP", "COMPONENTS", 1, TRUE) : TheApp->Preferences.SetIntPreference ("MRP", "COMPONENTS", 0, TRUE);		purvisCoding ? TheApp->Preferences.SetIntPreference ("MRP", "PURVISCODING", 1, TRUE) : TheApp->Preferences.SetIntPreference ("MRP", "PURVISCODING", 0, TRUE);	}	upDate ();}void VSourceTreesWindow::doPruneLeaves (void){	BOOL result = FALSE;	TPruneTreesDialog* dialog = new TPruneTreesDialog ((IsRooted () ? 3 : 4));	TheApp->Create_Dialog (dialog, dlgPruneLeaves, TRUE, FALSE);	dialog->Setup ((TSourceTreesFile*)fTreesFile);	dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit ();		if (!dialog->DoItem (item))		{			switch (item)			{				default:					break;			}		}	} while (item > 2);	TLeafSet toPrune;	dialog->GetToPrune (toPrune);		TheApp->DestroyDialog ();	if (item == 1 && toPrune != ((TSourceTreesFile*)fTreesFile)->GetPrunedLeafSet ())	{		WatchCursor ();		fTheTimer.StartTiming ();		*Log << EOLN << EOLN << "COMMAND: Prune/Regraft Leaves '" << Name () << "'" << EOLN;						if (((TSourceTreesFile*)fTreesFile)->CanPruneLeaves (toPrune))		{			TLeafSet leafSet =  toPrune - ((TSourceTreesFile*)fTreesFile)->GetPrunedLeafSet ();			if (!leafSet.IsEmpty ())			{											*Log << EOLN << (int)leafSet.GetLeaves () << ' ' << ((leafSet.GetLeaves () == 1) ? "Leaf " : "Leaves ") << "Pruned ";				*Log << "(";				leafSet.WriteToLog ();				*Log << ")";				*Log << EOLN;			}			leafSet = ((TSourceTreesFile*)fTreesFile)->GetPrunedLeafSet () - toPrune;			if (!leafSet.IsEmpty ())			{											*Log << EOLN << (int)leafSet.GetLeaves () << ' ' << ((leafSet.GetLeaves () == 1) ? "Leaf " : "Leaves ") << "Regrafted ";				*Log << "(";				leafSet.WriteToLog ();				*Log << ")";				*Log << EOLN;			}			((TSourceTreesFile*)fTreesFile)->PruneLeaves (toPrune);					}		else if (gAborted) // pruning can be aborted...		{			*Log << EOLN << "Prune/Regraft Leaves Aborted: By User" << EOLN;			gAborted = false;			}		else		{			Message (MSG_INFO, "The Pruning will Render All Trees Inactive");			*Log << EOLN << "Prune/Regraft Trees Aborted: The Pruning will Render All Trees Inactive" << EOLN;		}		fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VSourceTreesWindow::doReRoot (void){	CHECK_ (!((const TSourceTreesFile*)fTreesFile)->GetTotalLeafSet (true, true).IsEmpty ());	VDialog* dialog = TheApp->CreateDialog (dlgReRoot, TRUE, FALSE);	VListBox* List = new VListBox (dialog, 4, FALSE, TRUE); 	#ifdef Macintosh	WatchCursor ();	List->DoDraw (FALSE);#endif			const TLeafSet intersectionLeafSets = ((const TSourceTreesFile*)fTreesFile)->GetTotalLeafSet (true, true);	TTreeName name;	for (intersectionLeafSets.FirstLeaf (); intersectionLeafSets.CurLeaf (); intersectionLeafSets.NextLeaf ())		List->Append ((char*)fTreesFile->GetLeafName (intersectionLeafSets.CurLeaf ())); // JLT 010412				List->SetSelection (1);	List->DoDraw (TRUE);	ArrowCursor ();	dialog->Show();	int item;	do	{		item = TheApp->DialogItemHit ();		switch (item)		{			default:				break;		}	} while (item > 2);		const unsigned int leaf = fTreesFile->GetLeafNumber (List->String (List->GetSelection ()));			TheApp->DestroyDialog ();	// delete List; JLT 010417 		if (item == 1)	{			if (!IsRooted ())			doRootTrees ();					WatchCursor ();		*Log << EOLN << EOLN << "COMMAND: Reroot '" << Name () << "'" << EOLN;		fTheTimer.StartTiming ();						((TSourceTreesFile*)fTreesFile)->ReRoot (leaf);		*Log << EOLN << (int)((TSourceTreesFile*)fTreesFile)->GetTotalTrees () << ' ' << (((TSourceTreesFile*)fTreesFile)->GetTotalTrees () == 1 ? "Tree " : "Trees ") << "Rerooted on " << fTreesFile->GetLeafName (leaf) << EOLN;		fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VSourceTreesWindow::doRootTrees (void){	if (!fTreesFile->IsRooted ())	{		WatchCursor ();		*Log << EOLN << EOLN << "COMMAND: Root Trees '" << Name () << "'" << EOLN;		fTheTimer.StartTiming ();		*Log << EOLN << (int)((TSourceTreesFile*)fTreesFile)->GetTotalTrees () << ' ' << (((TSourceTreesFile*)fTreesFile)->GetTotalTrees () == 1 ? "Tree " : "Trees ") << "Rooted" << EOLN;		((TSourceTreesFile*)fTreesFile)->Root ();				fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VSourceTreesWindow::doUnRootTrees (void){	if (fTreesFile->IsRooted ())		{			WatchCursor ();		*Log << EOLN << EOLN << "COMMAND: Unroot Trees '" << Name () << "'" << EOLN;		fTheTimer.StartTiming ();					if (((TSourceTreesFile*)fTreesFile)->CanUnRoot ())		{			*Log << EOLN << (int)((TSourceTreesFile*)fTreesFile)->GetTotalTrees () << ' ' << (((TSourceTreesFile*)fTreesFile)->GetTotalTrees () == 1 ? "Tree " : "Trees ") << "Unrooted" << EOLN;			((TSourceTreesFile*)fTreesFile)->UnRoot ();		}		else		{			Message (MSG_INFO, "Unrooting will Render All Trees Inactive");			*Log << EOLN << "Unroot Trees Aborted: Unrooting will Render All Trees Inactive" << EOLN;		}				fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VSourceTreesWindow::doPositionalCongruence (void){		WatchCursor ();			fTheTimer.StartTiming ();	*Log << EOLN << EOLN << "COMMAND: Positional Congruence '" << Name () << "'" << EOLN;			TPositionalCongruence positionalCongruence ((TSourceTreesFile*)fTreesFile);	positionalCongruence.Consensus ();	if (gAborted)	{		*Log << EOLN << "Positional Congruence Aborted: By User" << EOLN;		gAborted = FALSE;	}	else	{		*Log << EOLN << "Positional Congruence " << "for " << (int)positionalCongruence.GetTreesDone () << ' ' << ((IsRooted ()) ? "Rooted " : "Unrooted ") << ((positionalCongruence.GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;						positionalCongruence.Write (dummy);		*Log << EOLN;	}			fTheTimer.StopTiming ();			*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		  			ArrowCursor ();	upDate ();}void VSourceTreesWindow::doLeafStabilityBootstrap (void){	bool continu = ((const TSourceTreesFile*)fTreesFile)->IsBootstrap ();	if (!continu)		continu = (bool)(ANS_YES == Message (MSG_YN, "The active source trees are not bootstrap trees. These leaf stability measures only really make sense when applied to a set of bootstrap trees.		 Continue?"));			if (continu)	{		VDialog* dialog = TheApp->CreateDialog (dlgLeafStability, TRUE, FALSE);							bool maximum = (bool)(TheApp->Preferences.GetIntPreference ("LEAF_STABILITY", "MAXIMUM", 1));			bool difference = (bool)(TheApp->Preferences.GetIntPreference ("LEAF_STABILITY", "DIFFERENCE", 0));		bool entropy = (bool)(TheApp->Preferences.GetIntPreference ("LEAF_STABILITY", "ENTROPY", 0));				dialog->SetItemState (4, maximum);		dialog->SetItemState (5, difference);		dialog->SetItemState (6, entropy);		dialog->EnableItem (1, (BOOL)(dialog->GetItemState (4) || dialog->GetItemState (5) || dialog->GetItemState (6)));	//	dialog->EnableItem (7, (BOOL)((dialog->GetItemState (4) && !dialog->GetItemState (5) && !dialog->GetItemState (6)) || (!dialog->GetItemState (4) && dialog->GetItemState (5) && !dialog->GetItemState (6)) || (!dialog->GetItemState (4) && !dialog->GetItemState (5) && dialog->GetItemState (6))));		dialog->Show ();				int item;		do		{			item = TheApp->DialogItemHit();			switch (item)			{				case 4:					dialog->ToggleDlgItem (4, NULL);					break;				case 5:					dialog->ToggleDlgItem (5, NULL);					break;				case 6:					dialog->ToggleDlgItem (6, NULL);					break;				case 7:					dialog->ToggleDlgItem (7, NULL);					break;				default:					break;			}			dialog->EnableItem (1, (BOOL)(dialog->GetItemState (4) || dialog->GetItemState (5) || dialog->GetItemState (6)));	//		dialog->EnableItem (7, (BOOL)((dialog->GetItemState (4) && !dialog->GetItemState (5) && !dialog->GetItemState (6)) || (!dialog->GetItemState (4) && dialog->GetItemState (5) && !dialog->GetItemState (6)) || (!dialog->GetItemState (4) && !dialog->GetItemState (5) && dialog->GetItemState (6))));		} while (item > 2);		if (item == 1)		{			maximum = (bool)dialog->GetItemState (4);			difference = (bool)dialog->GetItemState (5);			entropy = (bool)dialog->GetItemState (6);		}				const bool diffs = (bool)(dialog->GetItemState (7) && ((dialog->GetItemState (4) && !dialog->GetItemState (5) && !dialog->GetItemState (6)) || (!dialog->GetItemState (4) && dialog->GetItemState (5) && !dialog->GetItemState (6)) || (!dialog->GetItemState (4) && !dialog->GetItemState (5) && dialog->GetItemState (6))));		TheApp->DestroyDialog ();				if (item == 1)		{					WatchCursor ();			*Log << EOLN << EOLN << "COMMAND: Leaf Stability '" << Name () << "'" << EOLN;			fTheTimer.StartTiming ();								TLeafStability leafStability ((TSourceTreesFile*)fTreesFile, maximum, difference, entropy);	//		TLeafStability leafStability ((TSourceTreesFile*)fTreesFile, maximum, difference, entropy, 100); //use to test partitions!!						leafStability.Consensus ();						if (!gAborted)			{				*Log << EOLN << "Leaf Stabilities for " << (int)leafStability.GetTreesDone () << ' ' << (IsRooted () ? "Rooted " : "Unrooted ") << ((leafStability.GetTreesDone () == 1) ? "Tree " : "Trees ") << EOLN;				leafStability.Write (dummy);				*Log << EOLN;			}			else			{				*Log << EOLN << "Leaf Stability Aborted: By User" << EOLN;				gAborted = FALSE;			}						if (maximum)				TheApp->Preferences.SetIntPreference ("LEAF_STABILITY", "MAXIMUM", 1, TRUE);			else				TheApp->Preferences.SetIntPreference ("LEAF_STABILITY", "MAXIMUM", 0, TRUE);			if (difference)				TheApp->Preferences.SetIntPreference ("LEAF_STABILITY", "DIFFERENCE", 1, TRUE);			else				TheApp->Preferences.SetIntPreference ("LEAF_STABILITY", "DIFFERENCE", 0, TRUE);			if (entropy)				TheApp->Preferences.SetIntPreference ("LEAF_STABILITY", "ENTROPY", 1, TRUE);			else				TheApp->Preferences.SetIntPreference ("LEAF_STABILITY", "ENTROPY", 0, TRUE);											fTheTimer.StopTiming ();					*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		  					ArrowCursor ();						upDate ();				//		if (diffs)	//			doDiffsStability ();		}	}	upDate ();}void VSourceTreesWindow::doShowWeights (void){	VDialog* dialog = TheApp->CreateDialog (dlgShowWeights, TRUE, FALSE);	VListBox* List = new VListBox (dialog, 4, TRUE); 		setListBoxTreeNames (fTreesFile->GetTrees (), List);	TItemSet itemSet;	itemSet += 	fTreesFile->GetCurTreeNumber ();	setListBoxSelection (itemSet, List);			dialog->Show ();	int item;	do	{		item = TheApp->DialogItemHit ();		switch (item)		{			case 3:					break;			case 5:				List->SelectAll ();				break;							default:				break;		}	} while (item > 2);		itemSet = getListBoxSelection (List);		TheApp->DestroyDialog ();	// delete List; JLT 010417 		// could maybe do through medium of itemset.....	if (item == 1)	{		WatchCursor ();				fTheTimer.StartTiming ();							*Log << EOLN << EOLN << "COMMAND: Show Tree Weights '" << Name () << "'" << EOLN;				TTabString tabString (kFileWidth);		tabString.SetNextTabLength (6);		tabString.SetNextTabLength (15);				tabString.SetNewLine ();		tabString.AddToThis ("Tree");		tabString.AddToThis ("Weight");		tabString.SetNewLine ();		*Log << tabString.GetString ().Array ();		tabString.SetNull ();				double weight;		TString string;		CHECK_ (itemSet.LastItem () <= fTreesFile->GetTrees ());		for (itemSet.FirstItem (); itemSet.CurItem (); itemSet.NextItem ())		{						CHECK_ (fTreesFile->GetIthTree (itemSet.CurItem (), false));			fTreesFile->GetIthTreeWeight (itemSet.CurItem (), weight, false);			string.AddToThis (itemSet.CurItem ());			tabString.AddToThis (string);			string.SetNull ();			string.AddToThis ((float)weight, 4);			tabString.AddToThis (string);			string.SetNull ();			tabString.SetNewLine ();			*Log << tabString.GetString ().Array ();			tabString.SetNull ();		}				fTheTimer.StopTiming ();		*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		ArrowCursor ();	}	upDate ();}void VSourceTreesWindow::doTotalInformation (void){	WatchCursor ();	fTheTimer.StartTiming ();	*Log << EOLN << EOLN << "COMMAND: Total Information '" << Name () << "'" << EOLN;			*Log << EOLN << "Total Information: "<< ((TSourceTreesFile*)fTreesFile)->GetTotalInformation (true) << EOLN;	fTheTimer.StopTiming ();	*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		  			ArrowCursor ();	upDate ();}void VSourceTreesWindow::doWeightEqually (void){	WatchCursor ();	fTheTimer.StartTiming ();	*Log << EOLN << EOLN << "COMMAND: Weight Trees Equally'" << Name () << "'" << EOLN;		((TSourceTreesFile*)fTreesFile)->SetWeightsTrees (false);		*Log << EOLN << (int)((TSourceTreesFile*)fTreesFile)->GetTotalTrees () << ' ' << (((TSourceTreesFile*)fTreesFile)->GetTotalTrees () == 1 ? "Tree " : "Trees ") << "Weighted Equally" << EOLN;	fTheTimer.StopTiming ();	*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		  			ArrowCursor ();	upDate ();}void VSourceTreesWindow::doWeightBootstrap (void){	CHECK_ (((TSourceTreesFile*)fTreesFile)->IsBootstrap ());	WatchCursor ();	fTheTimer.StartTiming ();	*Log << EOLN << EOLN << "COMMAND: Weight Trees Bootstrap'" << Name () << "'" << EOLN;		((TSourceTreesFile*)fTreesFile)->SetWeightsTrees (true);		*Log << EOLN << (int)((TSourceTreesFile*)fTreesFile)->GetTotalTrees () << ' ' << (((TSourceTreesFile*)fTreesFile)->GetTotalTrees () == 1 ? "Tree " : "Trees ") << "Weighted Bootstrap" << EOLN;	fTheTimer.StopTiming ();	*Log << EOLN << "Time used " << fTheTimer.GetTimeUsed () << EOLN;		  			ArrowCursor ();	upDate ();}void VSourceTreesWindow::OnActivate (BOOL becomingActive){	VTreesWindow::OnActivate (becomingActive);	if (becomingActive)	{			unsigned int leavesInCommon = fTreesFile->GetLeaves (true, true);		const bool sufficientLeavesInCommon = (bool)(3 < leavesInCommon || (IsRooted () && leavesInCommon == 3));		const bool sufficientTrees = (bool)(0 < fTreesFile->GetTrees (true));				VEnableMenuItem (cmdAddOutGroup, (IsRooted () && ((const TSourceTreesFile*)fTreesFile)->GetTotalLeaves (false, false) < kMaxLeaves));		VEnableMenuItem (cmdPruneLeaves, true);		VEnableMenuItem (cmdReRoot, ((const TSourceTreesFile*)fTreesFile)->GetTotalLeaves (true, true));		VEnableMenuItem (cmdAddTrees, ((const TSourceTreesFile*)fTreesFile)->GetTotalTrees () < kMaxTrees);//		VEnableMenuItem (cmdWeightEqually, true);		VEnableMenuItem (cmdWeightBootstrap, ((const TSourceTreesFile*)fTreesFile)->IsBootstrap ());		VEnableMenuItem (cmdRooting, true);		VEnableMenuItem (cmdShowWeights, true);				if (fTreesFile->IsRooted ())		{			VCheckMenuItem (cmdRoot, true);			VCheckMenuItem (cmdUnroot, false);		}		else		{			VCheckMenuItem (cmdRoot, false);			VCheckMenuItem (cmdUnroot, true);		}		VEnableMenuItem (cmdCondenseTrees, 1 < fTreesFile->GetTrees (false));		VEnableMenuItem (cmdWeightTrees, true);				const bool conventionalConsensus = (bool)(sufficientTrees && sufficientLeavesInCommon);		const bool supertreeConsensus = sufficientTrees;		VEnableMenuItem (cmdPositionalCongruence, conventionalConsensus);		VEnableMenuItem (cmdDecayAnalysis, conventionalConsensus && leavesInCommon <= (IsRooted () ? 50 : 25) && IsRooted ()); // need to do unrooted 		VEnableMenuItem (cmdLeafStabilityDecay, conventionalConsensus && leavesInCommon <= (IsRooted () ? 50 : 25));		VEnableMenuItem (cmdLeafStabilityBootstrap, conventionalConsensus);					VEnableMenuItem (cmdConventionalConsensus, conventionalConsensus);		VEnableMenuItem (cmdAdamsConsensus, fTreesFile->IsRooted ());			VEnableMenuItem (cmdSuperTreeConsensus, supertreeConsensus);		VEnableMenuItem (cmdMRP, !fTreesFile->IsRooted () || fTreesFile->GetLeaves (false, true) < kMaxLeaves); // because need to add extra leaf if rooted	}	else	{		VEnableMenuItem (cmdAddTrees, false);		VEnableMenuItem (cmdAddOutGroup, false);		VEnableMenuItem (cmdPruneLeaves, false);		VEnableMenuItem (cmdCondenseTrees, false);		VEnableMenuItem (cmdWeightTrees, false);		VEnableMenuItem (cmdShowWeights, false);		VEnableMenuItem (cmdReRoot, false);				VEnableMenuItem (cmdRooting, false);		VEnableMenuItem (cmdPositionalCongruence, false);		VEnableMenuItem (cmdDecayAnalysis, false);		VEnableMenuItem (cmdLeafStabilityDecay, false);				VEnableMenuItem (cmdLeafStabilityBootstrap, false);					VEnableMenuItem (cmdConventionalConsensus, false);		VEnableMenuItem (cmdAdamsConsensus, false);		VEnableMenuItem (cmdSuperTreeConsensus, false);		VEnableMenuItem (cmdMRP, false); // because need to add extra leaf if rooted		VEnableMenuItem (cmdWeightBootstrap, false);	}}BOOL VSourceTreesWindow::OnMenuCommand (CmdTool cmd){	BOOL processed = FALSE;		switch (cmd)	{		case cmdDecayInput:			doDecayInput (true);			break;					case cmdDecayOutput:			doDecayOutput (true);			break;		case cmdLeafStabilityDecayInput:			doDecayInput (false);			break;					case cmdLeafStabilityDecayOutput:			doDecayOutput (false);			break;					case cmdAddTrees:			doAddTrees ();			break;			case cmdAddOutGroup:			doAddOutGroup ();			break;					case cmdComponentConsensus:			doComponentConsensus ();			break;		case cmdReducedConsensus:			doReducedConsensus ();			break;				case cmdAdamsConsensus:			doAdamsConsensus ();			break;												case cmdLeafStabilityBootstrap:			doLeafStabilityBootstrap ();			break;		case cmdPositionalCongruence:			doPositionalCongruence ();			break;					case cmdMRP:			doMRP ();			break;								case cmdPruneLeaves:			doPruneLeaves ();			break;		case cmdCondenseTrees:			doCondenseTrees ();			break;				case cmdRoot:			doRootTrees ();			break;						case cmdUnroot:			doUnRootTrees ();			break;		case cmdReRoot:			doReRoot ();			break;					case cmdShowWeights:			doShowWeights ();			break;					case cmdWeightEqually:			doWeightEqually ();			break;		case cmdWeightBootstrap:			doWeightBootstrap ();			break;										default:			processed = VTreesWindow::OnMenuCommand (cmd);	}	OnActivate (true);	return processed;}VSourceTreesWindow::VSourceTreesWindow (TSourceTreesFile* sourceTreesFile) 	: 	VTreesWindow (sourceTreesFile) {  }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifBOOL CPEditWindow::OnMenuCommand (CmdTool cmd){	BOOL result = TRUE;	TTreesDoc* d;	switch (cmd)	{		case cmdExecute:			d = (TTreesDoc*) GetParent ();			d->Execute (this);			break;		default:			result = VEditWindow::OnMenuCommand (cmd);		break;	}	return result;}// Update Execute command to reflect the active edit windowvoid CPEditWindow::OnActivate (BOOL becomingActive){	VEditWindow::OnActivate (becomingActive);	if (becomingActive)	{		// Put the current file on the File menu		char cmdText[256];		char buf[256];		GetTitle (buf, sizeof (buf));		sprintf (cmdText, "Execute '%s'", buf);		VSetMenuItemText (cmdExecute, cmdText, 'R');		VEnableMenuItem (cmdExecute, TRUE);	}	else	{		VSetMenuItemText (cmdExecute, "Execute");		VEnableMenuItem (cmdExecute, FALSE);	}}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid VMultipagePreview::OnEvent (VEvent &event){	PoinT pt;	event.GetPosition (pt);	Point p;	p.h = pt.x;	p.v = pt.y;	EventRecord e;		if (PagesMenu->HandleMouse (window, e, p) == FALSE)		VPreviewWindow::OnEvent (event);}// Print big treesvoid VMultipagePreview::Print (){	// rdmp1c	((VSourceTreesWindow*)theView)->printBigTree();}BOOL VMultipagePreview::OnMenuCommand (CmdTool cmd){	BOOL processed = TRUE;	switch (cmd)	{			case 90:			NumberOfPages = PagesMenu->GetSelection () + 1;			theView->SetNumberOfPages (NumberOfPages);						// Get new picture			if (pic != NULL)			{				::HUnlock ((Handle) pic);				::KillPicture (pic);				pic = NULL;			}						// Need to recalculate the page display, but invaildate only the page			// itself, not the whole screen to avoid page flicker			Rect r1 = pageOnScreen.GetRectTool ();			CalcPageSize ();			Rect r2 = pageOnScreen.GetRectTool ();			Rect r3;			::UnionRect (&r1, &r2, &r3);			::InsetRect (&r3, -5, -5); // allow for shadow			::InvalRect (&r3);			break;		default:			processed = VPreviewWindow::OnMenuCommand (cmd);			break;	}	return processed;}// Add a control to display the number of pages to print onvoid VMultipagePreview::CreateWindow (char* title){	VPreviewWindow::CreateWindow (title);		// 19/2/97	 PagesMenu = new VPopupMenu (this, 90, "",	250, 5, 50, 15, 90);	// If we have two many pages we will overflow the integer limits	// of the rectangle object, so we need	// to perform a check and limit	// the number of pages appropriately.	Port.PhysPageRect (page);	int max_pages = 32767 / page.GetHeight();	max_pages = MIN (max_pages, 10);	PagesMenu->Append ("1", TRUE);	for (int i = 2; i < max_pages; i++)	{		char buf[4];		sprintf (buf, "%d", i);		PagesMenu->Append (buf);	}	PagesMenu->SetSelection (0);}// Override to display pages popupvoid VMultipagePreview::DrawImage (void){	VRect r; // dummy	PagesMenu->Draw (r);	VPreviewWindow::DrawImage ();}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif// Custom dialog hook procedurepascal short myDialogHook (short item, DialogPtr theDialog, void *yourDataPtr){	Handle 	myHandle;	Rect 	myRect;	short 	myIgnore;	int 	id = 0;	char 	buf[32];		short result = item;	if (::GetWRefCon (WindowPtr (theDialog)) != (long) sfMainDialogRefCon)		return result;			// makes figures equivalent to radio buttons	if (item == id_tree_fig)		item = id_tree;	else if (item == id_text_fig)		item = id_text;			switch (item)	{			case sfHookFirstCall:				// initialise items here								// Radio buttons				::GetDialogItem (theDialog, id_tree, &myIgnore, &myHandle, &myRect);				::SetControlValue ((ControlHandle)myHandle, ((id == 0) ? 1 : 0));				::GetDialogItem (theDialog, id_text, &myIgnore, &myHandle, &myRect);				::SetControlValue ((ControlHandle)myHandle, ((id == 1) ? 1 : 0));								if (id == 0)					strcpy (buf, "Execute");				else					strcpy (buf, "Edit");				c2pstr (buf);				::GetDialogItem (theDialog, 1, &myIgnore, &myHandle, &myRect);				::SetControlTitle ((ControlHandle)myHandle, (unsigned char *)buf);												result = sfHookNullEvent;				break;											case id_tree:				::GetDialogItem (theDialog, item, &myIgnore, &myHandle, &myRect);								// Toggle radio buttons								::SetControlValue ((ControlHandle)myHandle, 1);				::GetDialogItem (theDialog, id_text, &myIgnore, &myHandle, &myRect);				::SetControlValue ((ControlHandle)myHandle, 0);				strcpy (buf, "Execute");				c2pstr (buf);				::GetDialogItem (theDialog, 1, &myIgnore, &myHandle, &myRect);				::SetControlTitle ((ControlHandle)myHandle, (unsigned char *)buf);							// Set action				id = 0;				*((int *)yourDataPtr) = id;				break;							case id_text:				::GetDialogItem (theDialog, item, &myIgnore, &myHandle, &myRect);								// Toggle radio buttons				::SetControlValue ((ControlHandle)myHandle, 1);				::GetDialogItem (theDialog, id_tree, &myIgnore, &myHandle, &myRect);				::SetControlValue ((ControlHandle)myHandle, 0);								strcpy (buf, "Edit");				c2pstr (buf);				::GetDialogItem (theDialog, 1, &myIgnore, &myHandle, &myRect);				::SetControlTitle ((ControlHandle)myHandle, (unsigned char *)buf);								// Set action				id = 1;				*((int *)yourDataPtr) = id;				break;			default:				break;	}	return result;}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TTreesDoc::makeOtherTreesDocs (TSourceTreesFileList& sourceTreesFileList){	TSourceTreesFile* sourceTreesFile = NULL;	while (!sourceTreesFileList.IsEmpty ())	{		sourceTreesFileList.DetachItem (sourceTreesFile);		TTreesDoc* treeDoc = new TTreesDoc ();		treeDoc->New (sourceTreesFile);					TheApp->AppendDocument (treeDoc);	}}void TTreesDoc::New (void){	VViewWindow* win = new CPEditWindow;	win->SetParent ((VWindow*) this);	win->Create ("Untitled");	viewList.Add (win);	win->OnActivate (TRUE); // ensure Execute menu is updated}void TTreesDoc::New (TConsensusTreesFile* consensusTreesFile){	fTreesFile = consensusTreesFile;	VConsensusTreesWindow* win = new VConsensusTreesWindow (consensusTreesFile);	win->Create ((char*)fTreesFile->GetName ()); // JLT 010412	viewList.Add (win);	win->SetParent (this);	currentView = win;}void TTreesDoc::New (TSourceTreesFile* sourceTreesFile){	fTreesFile = sourceTreesFile;	VSourceTreesWindow* win = new VSourceTreesWindow (sourceTreesFile);	win->Create ((char*)fTreesFile->GetName ()); // JLT 010412	viewList.Add (win);	win->SetParent (this);	currentView = win;}TTreesDoc::TTreesDoc (void)	: VDocument (){	fTreesFile = NULL;	fAction = 0;}TTreesDoc::~TTreesDoc (void){	if (fTreesFile)  		delete fTreesFile;}int TTreesDoc::Open (void){	SFTypeList			myTypes;	OSErr				myErr;	short				fileNum;		myErr 		= noErr;	myTypes[0] 	= 'TEXT';	#if 1 	Point  		myPoint;			::SetPt (&myPoint, -1, -1); 	// centre the dialog		fAction = 0;	DlgHookYDUPP myDlg = NewDlgHookYDProc(myDialogHook);		::CustomGetFile (nil, 1, myTypes,  &myReply, 400, myPoint, myDlg, 		nil, nil, nil, &fAction);#else	StandardGetFile (nil, 1, myTypes, &myReply);#endif	if (myReply.sfGood)	{		myErr = FSpOpenDF (&myReply.sfFile, fsRdPerm, &fileNum);		if (myErr != noErr) 		{			Message (MSG_ERROR, "Can't open file...");			return 1;		}				// Get length of file		long myLength;		myErr = GetEOF (fileNum, &myLength);		if (myErr != noErr) 		{			Message (MSG_ERROR, "Error returned by GetEOFF");			return 1;		}		// Create buffer for C++ stream, and read file's contents		char *buf = new char[myLength + 1];		myErr = FSRead (fileNum, &myLength, buf);				if (myErr != noErr) 		{			Message (MSG_ERROR, "Error reading file...");			return 1;		}		buf[myLength] = '\0'; // 12/7/96						// 14 May 1996		// Korbinian Strimmer reported that files opened in TreeView cannot be 		// trashed, even if the document window is subsequently closed. This is		// because I never called FSClose after reading the file. This line fixes this		// bug.		::FSClose (fileNum); 						// 17/9/96		// Check for Stationery		if (myReply.sfFlags & kIsStationery)		{			strcpy (fileName, "Untitled");		}		else		{			// Call document's Open (...) method with filename and stream			strcpy (fileName, (char *)myReply.sfFile.name);			p2cstr ((unsigned char *)fileName);		}		int error = Open (fileName, buf);				if ( (error == 0) && !(myReply.sfFlags & kIsStationery))			hasFile = TRUE;						// Support for recent file lists		// rdmp1c		// Only add file to MRU list if it has been executed		if ((error == 0) && (fAction == 0))		{			TheApp->AddToRecentlyOpened (myReply.sfFile);		}				// Clean up		delete buf;		return error;	}	return 1;}int TTreesDoc::Open (char* filename, char* buf){   	// Read a file here   	int error = 0; // OK so far   		strcpy (fileName, filename);#if 0		// Ask user if they want file opened or viewed	//VDialog* dialog = TheApp->Create_Dialog (136);	//dialog->CheckRadioButton (5, 6, 5);	//dialog->Show ();	int item;	do {		item = TheApp->DialogItemHit();#ifdef Macintosh		if (item == 3)			item = 5;		else if (item == 4)			item = 6;		if ((item >= 5) && (item <= 6))			dialog->CheckRadioButton (5, 6, item);#endif	} while (item > 2);	if (item == 2)	{		TheApp->DestroyDialog (); // User doesn't want to open a file	}	else	{		bool OpenTrees = dialog->GetItemState (5);		TheApp->DestroyDialog();#endif		if (fAction == 0)		{		   	// Create stream		#if (USE_MSL)			istringstream *s;			s = new istringstream (buf);		#else			istrstream *s;			s = new istrstream (buf);		#endif					TSourceTreesFileList treesFiles;//		  	fTreesFile = new TSourceTreesFile ();					  	try		  	{		  		*Log << EOLN << EOLN << "COMMAND: Open '" << filename << "'" << EOLN;		 		gTheTimer.StartTiming (); 				  		WatchCursor ();		 		TReadTreesFile* readTreesFile = new TReadTreesFile (*s, fileName, treesFiles, !TheApp->Preferences.GetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", 1), TheApp->Preferences.GetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", 1));		 // 		TReadTreesFile readFile (*s, fileName, treesFiles, !TheApp->Preferences.GetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", 1), TheApp->Preferences.GetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", 1));		 		readTreesFile->ReadFile ();		 		//		 		delete (readTreesFile);		  		CHECK_ (!treesFiles.IsEmpty ());		  		treesFiles.DetachItem ((TSourceTreesFile*&)fTreesFile);		  		ArrowCursor ();		  	}		  	catch (EInputError e) 		  	{		  		ArrowCursor ();		  		Message (MSG_ERROR, (char*)e.what ()); // JLT 010412		  		*Log << EOLN << "Open '" << filename << "' Aborted " << EOLN;		  		*Log << EOLN << "Error: " << e.what () << EOLN;				error = 1;		  	}			delete s;		  				// Display window  			  	if (error == 0)		  	{		  			  		VSourceTreesWindow* win = new VSourceTreesWindow ((TSourceTreesFile*)fTreesFile);				char *name;				name = strrchr (filename, ':');				if (name) 					name++;				else 					name = filename;				win->Create(name);		   		viewList.Add (win);		    	win->SetParent (this);		   		currentView = win;		 				 		makeOtherTreesDocs (treesFiles);				gTheTimer.StopTiming ();		  		*Log << EOLN << "Time used " << gTheTimer.GetTimeUsed () << EOLN;		  					}			else			{				gTheTimer.StopTiming ();		  		*Log << EOLN << "Time used " << gTheTimer.GetTimeUsed () << EOLN;				// Open file in editor and highlight problem			}				}		else		{			// Open in text editor#ifdef Windows			char *text = f.ReadTextFile ();#else			char *text = buf;#endif			if (text)			{				strcpy (fileName, filename);				CPEditWindow* w = new CPEditWindow;				char *name;				name = strrchr (filename, '\\');				if (name) name++;				else name = filename;				w->SetParent ((VWindow*)this);				w->Create(name);				viewList.Add (w);				w->SetText (text);				w->SetDirty (FALSE);				w->OnActivate (TRUE);#ifdef Windows				delete text;#endif				error = 0;					}		}	#if 0	}#endif	return (error);}BOOL TTreesDoc::Execute (VEditWindow* win){	*Log << EOLN << EOLN << "COMMAND: Execute " << "'" << fileName << "'" << EOLN;		// For safety ask if user wants to save before processing	if (IsModified)	{		char buf[FILE_NAME_LENGTH];		sprintf (buf, "Save changes to %s?", fileName);		if (Message (MSG_YNC, buf, "Editor") == ANS_YES)		{			SaveBeforeClosing ();			IsModified = FALSE;		}	}	// Get the text from the edit window	char *text = win->GetText ();#if (USE_MSL)	istringstream *s;	s = new istringstream (text);#else	istrstream *s;	s = new istrstream (text);#endif   	int error = 0; // OK so far			TSourceTreesFileList treesFiles;// replace with 	  	try{  		gTheTimer.StartTiming ();  		TReadTreesFile* readTreesFile = new TReadTreesFile (*s, fileName, treesFiles, !TheApp->Preferences.GetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", 1), TheApp->Preferences.GetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", 1)); // 		TReadTreesFile readFile (*s, fileName, treesFiles, !TheApp->Preferences.GetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", 1), TheApp->Preferences.GetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", 1)); 		readTreesFile->ReadFile (); 		 		delete (readTreesFile);  		CHECK_ (!treesFiles.IsEmpty ());  		treesFiles.DetachItem ((TSourceTreesFile*&)fTreesFile);  		gTheTimer.StopTiming ();  	}  	catch (EInputError e) {  		gTheTimer.StopTiming ();  		Message (MSG_ERROR, (char*)e.what ());		delete fTreesFile;		fTreesFile = NULL;		error = 1;  	}	delete s;	if (error == 0)	{		// If OK close edit window and display tree window		// Close edit window before displaying the trees #ifdef Windows		win->Close();		viewList.Delete (win); #endif	#ifdef Macintosh	 		((CPEditWindow*)win)->SetClosesDocument (FALSE);			TheApp->CloseView (win);	#endif  		VSourceTreesWindow* w = new VSourceTreesWindow ((TSourceTreesFile*)fTreesFile);		char *name;		name = strrchr (fileName, ':');		if (name) 			name++;		else 			name = fileName;		w->Create(name);   		viewList.Add (w);    	w->SetParent (this);   		currentView = w;		*Log << EOLN << "Time used " << gTheTimer.GetTimeUsed () << EOLN;		  		#ifdef Windows		viewList.Add (w);#else		TheApp->AppendView (this, w); //changed w unknown to win and one above#endif		w->OnActivate (TRUE);				// rdmp1c 		// Add this successfully executed document to the MRU list		TheApp->AddToRecentlyOpened (myReply.sfFile);		makeOtherTreesDocs (treesFiles);	}	else	{/*		// Display error		Message (MSG_ERROR, GetErrorMsg (error));		// COMPONENT only		*Log << "ERROR: " << GetErrorMsg (error) << EOLN << EOLN;;		// Highlight it in the edit window		long end = P.GetStreamPos ();		win->SetSelection (P.GetLastStreamPos(), end);*/	}	delete text;	return (true); // don't know what this boolean controls}BOOL TTreesDoc::Write (ostream& o){	BOOL result;	if (fTreesFile)	{//		doSaveTrees ();		fTreesFile->SaveTrees (o, TheApp->Preferences.GetIntPreference ("SAVE_TREES", "CHARACTERS", 0), true);		// We have a profile of trees//		MonitorDialog = TheApp->CreateMonitor (135);//		MonitorDialog->Show();//   		result = P.P->Write (s);//		result = P.P->Export (s, NEXUSFormat, FALSE, TRUE, TRUE);//		TheApp->DestroyDialog ();	}	else	{		// We have a text edit window		VEditWindow* win = (VEditWindow*) GetFirstView ();		char *text = win->GetText ();		o << text;		delete text;		result = TRUE;	}	return result;}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#ifdef Macintosh// Preferences dialog//#define PREFFONTMENU 200class PreferencesDialog : public VTabbedDialog{public:	PreferencesDialog ();	~PreferencesDialog ();	virtual void SetPanelItemValues ();	virtual void GetPanelItemValues ();	virtual void HandleItem (short item);	virtual void Apply ();protected://	MenuHandle menu;		// Item settings//	short treeStyle;//	short showLabels;//	short treeOrder;	// Fonts;//	char DocFont[256];//	char LabelFont[256];};typedef PreferencesDialog *PreferencesDialogPtr;//-----------------------------------------------------------------------------PreferencesDialog::PreferencesDialog (){	// Get current user settings from preferences file/*	menu = ::GetMenu (PREFFONTMENU);	::InsertMenu (menu, hierMenu);	::AppendResMenu (menu, 'FONT');		// Set current preferences	treeStyle  = TheApp->Preferences.GetIntPreference ("Trees", "Style", 1);	showLabels = TheApp->Preferences.GetIntPreference ("Trees","Labels", 0);	treeOrder  = TheApp->Preferences.GetIntPreference ("Trees", "Order", 0);	// Fonts	strcpy (DocFont, TheApp->Preferences.GetStrPreference ("Fonts","Document", "Helvetica,10"));	strcpy (LabelFont, TheApp->Preferences.GetStrPreference ("Fonts","Internal labels", "Helvetica,10"));*/}//-----------------------------------------------------------------------------// Kill anu font menu resources, etc.PreferencesDialog::~PreferencesDialog (){	// Free the font popup menu//	::DeleteMenu (PREFFONTMENU); // vital!//	::ReleaseResource ( (Handle) menu); // release the font menu}//-----------------------------------------------------------------------------// If user switches betwene panels ensure the controls are correctly setvoid PreferencesDialog::SetPanelItemValues (){	switch (currPanel)	{		case 1://			CheckRadioButton (6, 9, 6 + treeStyle);//			SetItemState (10, (BOOL) showLabels);			break;		case 2://			CheckRadioButton (6, 8, 6 + treeOrder);			break;					case 3://			SetFontGroupFont (6, DocFont);//			SetFontGroupFont (10, LabelFont);			break;					default:			break;	}}//-----------------------------------------------------------------------------// Called when user closes dialog, or switches between different tabsvoid PreferencesDialog::GetPanelItemValues (){//	char buf[256];		switch (currPanel)	{		case 1:/*			treeStyle = GetGroupChoice (6, 9) - 6;			showLabels = (short) GetItemState (10);*/			break;		case 2://			treeOrder = GetGroupChoice (6, 8) - 6;			break;					case 3:/*			GetFontGroupFont (6, DocFont);			GetFontGroupFont (10, LabelFont);*/			break;					default:			break;	}}//-----------------------------------------------------------------------------// Handle user clicking on an item. Need code for each panel (remember items on// different panels may have the same item numbervoid PreferencesDialog::HandleItem (short item){//	BOOL state;	switch (currPanel)	{		case 1:/*			if (item <= 9)				CheckRadioButton (6, 9, item);			else 				if (item == 10)				{					state =  GetItemState (10);					SetItemState (10, !state);				}*/			break;		case 2://			CheckRadioButton (6, 8, item);			break;					case 3:			switch (item)			{/*				case 8:				case 9:					state =  GetItemState (item);					SetItemState (item, !state);										break;									case 12:				case 13:					state =  GetItemState (item);					SetItemState (item, !state);										break;*/									default:					break;			}			break;					default:			break;	}}//-----------------------------------------------------------------------------void PreferencesDialog::Apply (){	GetPanelItemValues (); // ensure current panel's values are collected		// Save any preferences here:	/*	// Style    TheApp->Preferences.SetIntPreference ("Trees", "Style", treeStyle, TRUE);	TheApp->Preferences.SetIntPreference ("Trees", "Labels", showLabels, TRUE);	TheApp->Preferences.SetIntPreference ("Trees", "Order", treeOrder, TRUE);	// Fonts    TheApp->Preferences.SetStrPreference ("Fonts", "Document", DocFont, TRUE);    TheApp->Preferences.SetStrPreference ("Fonts", "Internal labels", LabelFont, TRUE);*/}#endif // Macintosh/*void RadConFrame::doPreferences (void){// RDMP#if 1	PreferencesDialogPtr dialog = new PreferencesDialog;	TheApp->CreateDialog (dialog, 160, FALSE, TRUE);	dialog->Show ();		short item;	do	{		item = TheApp->DialogItemHit();		switch (item)		{			case TABCNTL:				dialog->HandleTabClick ();				break;								case cancel:			case ok:				break;			default:				dialog->HandleItem (item);				break;		}	} while (item > cancel);	if (item == ok)		dialog->Apply();				TheApp->DestroyDialog();#else	VDialog* dialog = TheApp->CreateDialog (dlgPreferences, TRUE, FALSE);	bool addUnknownLeaves = TheApp->Preferences.GetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", 1);	bool multipleTreesSets = TheApp->Preferences.GetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", 1);	dialog->CheckRadioButton (4, 5, (addUnknownLeaves ? 4 : 5));	dialog->CheckRadioButton (8, 9, (multipleTreesSets ? 8 : 9));		dialog->Show ();		int item;	do	{		item = TheApp->DialogItemHit();		switch (item)		{			case 4:				dialog->CheckRadioButton (4, 5, 4);				break;							case 5:				dialog->CheckRadioButton (4, 5, 5);				break;			case 8:				dialog->CheckRadioButton (8, 9, 8);				break;			case 9:				dialog->CheckRadioButton (8, 9, 9);				break;			default:				break;		}	} while (item > 2);	if (item == 1)	{		addUnknownLeaves = (dialog->GetGroupChoice (4, 5) == 4);		multipleTreesSets = (dialog->GetGroupChoice (8, 9) == 8);	}	TheApp->DestroyDialog ();	if (item == 1)	{		TheApp->Preferences.SetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", (addUnknownLeaves ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", (multipleTreesSets ? 1 : 0), TRUE);	}#endif}*/void RadConFrame::doPreferences (void){	VDialog* dialog = TheApp->CreateDialog (dlgPreferences, TRUE, FALSE);	bool addUnknownLeaves = TheApp->Preferences.GetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", 1);	bool multipleTreesSets = TheApp->Preferences.GetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", 1);	bool rectangularTrees = TheApp->Preferences.GetIntPreference ("TREES", "RECTANGULAR", 1);	bool drawTreeNames = TheApp->Preferences.GetIntPreference ("TREES", "DRAWNAMES", 1);	bool charactersBlock = TheApp->Preferences.GetIntPreference ("SAVE_TREES", "CHARACTERS", 0);//	int nodeHeights = TheApp->Preferences.GetIntPreference ("PREFERENCES", "NODE_HEIGHTS", 1);		dialog->CheckRadioButton (4, 5, (addUnknownLeaves ? 4 : 5));	dialog->CheckRadioButton (7, 8, (multipleTreesSets ? 7 : 8));	dialog->CheckRadioButton (10, 11, (rectangularTrees ? 10 : 11));	dialog->SetItemState (13, drawTreeNames);	dialog->SetItemState (14, charactersBlock);#if 0 // JLT 010310 commented out		switch (nodeHeights)	{		case 1:			dialog->CheckRadioButton (15, 17, 15);			break;					case 2:			dialog->CheckRadioButton (15, 17, 16);			break;					case 3:			dialog->CheckRadioButton (15, 17, 17);			break;				default:			CHECK_ (0);			break;		}#endif			dialog->Show ();		int item;	do	{		item = TheApp->DialogItemHit();		switch (item)		{			case 4:				dialog->CheckRadioButton (4, 5, 4);				break;							case 5:				dialog->CheckRadioButton (4, 5, 5);				break;			case 7:				dialog->CheckRadioButton (7, 8, 7);				break;			case 8:				dialog->CheckRadioButton (7, 8, 8);				break;			case 10:				dialog->CheckRadioButton (10, 11, 10);				break;			case 11:				dialog->CheckRadioButton (10, 11, 11);				break;			case 13:				dialog->ToggleDlgItem (13, NULL);				break;			case 14:				dialog->ToggleDlgItem (14, NULL);				break;//			case 15://				dialog->CheckRadioButton (15, 17, 15);//				break;//			case 16://				dialog->CheckRadioButton (15, 17, 16);//				break;//			case 17://				dialog->CheckRadioButton (15, 17, 17);//				break;			default:				break;		}	} while (item > 2);	if (item == 1)	{		addUnknownLeaves = (dialog->GetGroupChoice (4, 5) == 4);		multipleTreesSets = (dialog->GetGroupChoice (7, 8) == 7);		rectangularTrees = (dialog->GetGroupChoice (10, 11) == 10);		drawTreeNames = dialog->GetItemState (13);		charactersBlock = dialog->GetItemState (14);//		nodeHeights = (dialog->GetGroupChoice (15, 17) - 14);	}	TheApp->DestroyDialog ();	if (item == 1)	{		TheApp->Preferences.SetIntPreference ("PREFERENCES", "ADDUNKNOWNLEAVES", (addUnknownLeaves ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("PREFERENCES", "MULTIPLETREESSETS", (multipleTreesSets ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("TREES", "RECTANGULAR", (rectangularTrees ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("TREES", "DRAWNAMES", (drawTreeNames ? 1 : 0), TRUE);		TheApp->Preferences.SetIntPreference ("SAVE_TREES", "CHARACTERS", (charactersBlock ? 1 : 0), TRUE);//		TheApp->Preferences.SetIntPreference ("PREFERENCES", "NODE_HEIGHTS", nodeHeights, TRUE);	}}BOOL RadConFrame::OnMenuCommand (CmdTool cmd){	BOOL processed = FALSE;		switch (cmd)	{		case cmdRadConPreferences:			doPreferences ();			break;								default:			processed = VFrameWindow::OnMenuCommand (cmd);	}	return processed;}// RDMP: Joe, you need to override this to query whether you want to include win in// the window list.bool RadConFrame::IncludeViewInList (VWindowPtr win){	char buf[256];	win->GetTitle (buf, sizeof (buf));	return (stricmp (buf, "Log") && ((VTreesWindow*)win)->IsSourceTrees ());}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid RadConApp::Create (){	VApp::Create ();	// Create log window	CPLogDoc* doc = new CPLogDoc;	doc->New ();	Log = (VTextWindow*) doc->GetFirstView ();	mainWindow->NewWindow (doc);		::InsertMenu (::GetMenu (mInformation), hierMenu);	::InsertMenu (::GetMenu (mRooting), hierMenu);	::InsertMenu (::GetMenu (mConventionalConsensus), hierMenu);	::InsertMenu (::GetMenu (mSuperTreeConsensus), hierMenu);	::InsertMenu (::GetMenu (mWeightTrees), hierMenu);	::InsertMenu (::GetMenu (mSelectTrees), hierMenu);	::InsertMenu (::GetMenu (mTreeMeasures), hierMenu);	::InsertMenu (::GetMenu (mDecayAnalysis), hierMenu);	::InsertMenu (::GetMenu (mLeafStabilityDecay), hierMenu);			*Log << "RadCon (Version 1.1.6 for Macintosh)" << EOLN;	*Log << EOLN;	*Log << "(c) 2001-2004, Joseph L.Thorley and Roderic D.M.Page" << EOLN;	*Log << EOLN;	*Log << Time ();	*Log << EOLN;	*Log << EOLN;	// JLT 000303 from	// Stream to the Log window	widgetbuf *w = new widgetbuf (Log, 1024);	logStream = new ostream (w);	// JLT 000303 to}#if defined(SELF_DESTRUCT) || defined(HAS_EXPIRATION_DATE)void RadConApp::OnInit (void){	VApp::OnInit();	DoExpTest ();}#endifRadConApp gRadConApp;VApp* TheApp = &gRadConApp;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifint main (void){		set_terminate (&radcon_terminate);	set_unexpected (&radcon_unexpected);	set_new_handler (&radcon_new_handler);		gSpareBlock = NULL;	gSpareBlock = new char [10240]; // allocates 10K for memory error message		TheApp->Create ();	TheApp->SetCreator ('RadC');							Port.Initialise ();	try	{	}	catch (TXception e) // because not successfully overiding exception::what () don't know why	{		if (!strcmp (e.what (), ""))			Message (MSG_ERROR, "Uncaught exception");				else			Message (MSG_ERROR, (char*)e.what ());			}		try	{		TheApp->EventLoop ();	}	catch (TMemoryException memoryException)	{		Message (MSG_ERROR, "Insufficient memory\r\rTry increasing RadCon's memory settings");	}	catch (TXception e) // because not successfully overiding exception::what () don't know why	{		if (!strcmp (e.what (), ""))			Message (MSG_ERROR, "Uncaught exception");				else			Message (MSG_ERROR, (char*)e.what ());			}	catch (exception e) 	{		if (!strcmp (e.what (), ""))			Message (MSG_ERROR, "Uncaught exception");				else			Message (MSG_ERROR, (char*)e.what ());	}	return (0);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif// this year// write up manual// email felsenstein// email rod// email evoldir// email users// release beta version 1.1.0// release 1.0.1// *derivative consensus// option to search trees// bug...// (((A,B),C),D) and (((A,B),D),C) and ((A,B),(C,D)); need to eliminate when unrooted// derivative entropy// option to control heights of internal nodes// MRP set weights of trees and write to file...very important// *control the min size of the trees window and know actual size in pixels - very useful for getting tree drawings// *need to truncate too long leaf names if attempt to draw in window// for rod - these are not critical for release!!// *crash when edit window too much....// *when execute have two entries in window menu// *preferences dialog box and fonts etc etc// *have logging output option always active whether log window active or not// *resolution wrt triplets and quartets// *if multiple default trees then 1st tree the default// *current tree number overflows if 10,000 trees// **save as for trees "Save Trees As" not "Save Document As"??// **aho and min cut and reduced supertrees// *tabstring better that just give length that to increase by each time...see example with tree imbalances// *use NCL and STL// *increase speed// *increase number of leaves to 10000!!// **bug get problematic files in recently looked at files...// **problem with fitting in long leaf names...???// choice of viewing all, activate, or selected trees??// get rid of fast forward buttons...just change selection ??// show trees and tree measures only work on selected trees...// *edit trees// *add trees is a little bit shite as even if only room for 1 one more tree will read in upto max trees!!!//