#include "TOpenFile.h"#include "VMsg.h"//#include <vector>pascal short myDialogHookText (short item, DialogPtr theDialog, void *yourDataPtr);//pascal short FileDialogHook (short item, DialogPtr theDialog, void *yourDataPtr);//pascal void ItemProc (DialogPtr dlg, short itemNumber);//pascal Boolean FileDialogFilter (DialogPtr dlg, EventRecord *event, short *itemhit, void *myDataPtr);// void HiliteButton (DialogPtr dlg, short id, Boolean on);// void CheckList (DialogPtr dlg);// void AddFile (DialogPtr dlg);// void RemoveFile (DialogPtr dlg);// bool HaveFile (int i);extern StandardFileReply	myReply;// extern ListHandle 			list;// bool				bCheckList;// vector<StandardFileReply> fileList;// #define listID 		12// #define addID		10// #define doneID		15	// #define removeID	11	pascal short myDialogHookText (short item, DialogPtr theDialog, void *yourDataPtr){	int 	id = 0;		short result = item;	if (::GetWRefCon (WindowPtr (theDialog)) != (long) sfMainDialogRefCon)		return result;					switch (item)	{			case sfHookFirstCall:				result = sfHookNullEvent;				break;											default:				break;	}	return result;}char* OpenFile (const int dialogid, TString& fileName){		SFTypeList			myTypes;	OSErr				myErr;	short				fileNum;	char* buf = NULL;		myErr 		= noErr;	myTypes[0] 	= 'TEXT';	#if 1 	Point  		myPoint;			::SetPt (&myPoint, -1, -1); 	// centre the dialog		int action = 0;	DlgHookYDUPP myDlg = NewDlgHookYDProc(myDialogHookText);		::CustomGetFile (nil, 1, myTypes,  &myReply, dialogid, myPoint, myDlg, 		nil, nil, nil, &action);#else	StandardGetFile (nil, 1, myTypes, &myReply);#endif	if (myReply.sfGood)	{		myErr = FSpOpenDF (&myReply.sfFile, fsRdPerm, &fileNum);		if (myErr != noErr) 		{			Message (MSG_ERROR, "Can't open file...");			return (buf);		}				// Get length of file		long myLength;		myErr = GetEOF (fileNum, &myLength);		if (myErr != noErr) 		{			Message (MSG_ERROR, "Error returned by GetEOFF");			return (buf);		}		// Create buffer for C++ stream, and read file's contents		buf = new char[myLength + 1];		myErr = FSRead (fileNum, &myLength, buf);				if (myErr != noErr) 		{			Message (MSG_ERROR, "Error reading file...");			return (NULL);		}		buf[myLength] = '\0'; // 12/7/96						// 14 May 1996		// Korbinian Strimmer reported that files opened in TreeView cannot be 		// trashed, even if the document window is subsequently closed. This is		// because I never called FSClose after reading the file. This line fixes this		// bug.		::FSClose (fileNum);				char nom [256]; 		strcpy (nom, (char *)myReply.sfFile.name);		p2cstr ((unsigned char *)nom);		fileName = nom;	}	return (buf);}