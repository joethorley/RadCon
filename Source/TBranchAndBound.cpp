#include "TBranchAndBound.h"#include "DialogIDs.h"extern BOOL gAborted;bool TBranchAndBound::AddNextLeaf (void){	if (fPositions.NextPosition ())	{		fTree.GraftLeaf (fPositions.CurLeaf (), fPositions.CurPosition ());		return (true);	}	return (false);}bool TBranchAndBound::NextBranch (void) { 	if (fPositions.NextBranch ())	{		unsigned int leaf;		if (fPositions.IsSequential ())			for (leaf = fTree.GetLeaves (); fPositions.CurLeaves () < leaf; --leaf)				fTree.PruneLeaf (leaf);		else			for (leaf = fTree.GetLeaves (); fPositions.CurLeaves () < leaf; --leaf)				fTree.PruneLeaf (fTree.GetLeafSet ().IthLeaf (leaf));				if (leaf < fPositions.BranchLeaves ())					MonitorDialog->UpdateMeter (fPositions.BranchesDone ());		MonitorDialog->ProcessExternal ();		gAborted = MonitorDialog->HasAborted ();						return (true);	}	return (false);}TBranchAndBound::TBranchAndBound (const unsigned int leaves, const bool rooted)	: fPositions (leaves, rooted){	CHECK_ ((3 < GetLeaves ()) || (rooted && 2 < GetLeaves ()));		if (IsRooted ())	{		if (!fTree.IsRooted ())			fTree.Root ();		fTree.TwoLeafTree (GetLeaves ());	}	else	{		if (fTree.IsRooted ())			fTree.UnRoot ();		fTree.ThreeLeafTree (GetLeaves ());	}		MonitorDialog = TheApp->CreateMonitor (dlgProgressBar);	MonitorDialog->SetItemText (4, "Branch and Bound");	MonitorDialog->SetMeter (fPositions.BranchesTotal ());	MonitorDialog->Show ();}TBranchAndBound::TBranchAndBound (const TLeafSet& leafSet, const bool rooted)	: fPositions (leafSet, rooted){	CHECK_ ((3 < GetLeaves ()) || (rooted && 2 < GetLeaves ()));		if (IsRooted ())	{		if (!fTree.IsRooted ())			fTree.Root ();		fTree.TwoLeafTree (GetLeafSet ());	}	else	{		if (fTree.IsRooted ())			fTree.UnRoot ();		fTree.ThreeLeafTree (GetLeafSet ());	}	MonitorDialog = TheApp->CreateMonitor (dlgProgressBar);	MonitorDialog->SetItemText (4, "Branch and Bound");	MonitorDialog->SetMeter (fPositions.BranchesTotal ());	MonitorDialog->Show ();	}TBranchAndBound::~TBranchAndBound (void) { 	TheApp->DestroyDialog ();}bool TBranchAndBound::TPositions::NextBranch (void){	CHECK_ ((3 < fCurLeaves) || (IsRooted () && 2 < fCurLeaves));		unsigned int lastLeaf = fCurLeaves;		for (; fCurPositions[fCurLeaves - 1] == fMaxPositions[fCurLeaves - 1]; --fCurLeaves)	{		fCurPositions[fCurLeaves - 1] = 0;		if ((IsRooted () && fCurLeaves == 2) || (!IsRooted () && fCurLeaves == 3))			break;	}	--fCurLeaves;		if (fCurLeaves < fBranchLeaves)	{		unsigned int branches = 1;		while (++lastLeaf <= fBranchLeaves)			branches *= fMaxPositions[lastLeaf - 1];		fBranchesDone += branches;	}	if ((IsRooted () && fCurLeaves == 1) || (!IsRooted () && fCurLeaves == 2))	{		CHECK_ (fBranchesDone == fBranchesTotal);		return (false);	}	return (true);}TBranchAndBound::TPositions::TPositions (const unsigned int leaves, const bool rooted)	: fLeafSet (leaves)	, fCurPositions (leaves)	, fMaxPositions (leaves){	CHECK ((rooted && 2 < GetLeaves ()) || (!rooted && 3 < GetLeaves ()));		fRooted = rooted;	fContigousLeafSet = true;	fBranchesDone = 0;	if (GetLeaves () < 6)	{		fBranchLeaves = GetLeaves ();		fBranchesTotal = calcB (GetLeaves () - (IsRooted () ? 0 : 1));	}	else 	{		if (IsRooted ())			fBranchLeaves = 5;		else 			fBranchLeaves = 6;		fBranchesTotal = calcB (5);	}		fCurPositions.Fill (0);	fCurPositions[0] = 1;	fCurPositions[1] = 1;	if (IsRooted ())		fCurLeaves = 2;	else	{		fCurPositions[2] = 1;		fCurLeaves = 3;	}			fMaxPositions[0] = 1;	fMaxPositions[1] = 1;		if (IsRooted ())	{		for (unsigned int i = 2; i < GetLeaves (); ++i)			fMaxPositions[i] = (((i - 1)*2)+1);	}	else	{		for (unsigned int i = 2; i < GetLeaves (); ++i)			fMaxPositions[i] = (((i - 2)*2)+1);	}}TBranchAndBound::TPositions::TPositions (const TLeafSet leafSet, const bool rooted)	: fLeafSet (leafSet)	, fCurPositions (leafSet.GetLeaves ())	, fMaxPositions (leafSet.GetLeaves ()){	CHECK ((rooted && 2 < GetLeaves ()) || (!rooted && 3 < GetLeaves ()));		fRooted = rooted;	fContigousLeafSet = fLeafSet.IsSequential ();	fBranchesDone = 0;	if (GetLeaves () < 6)	{		fBranchLeaves = GetLeaves ();		fBranchesTotal = calcB (GetLeaves () - (IsRooted () ? 0 : 1));	}	else 	{		if (IsRooted ())			fBranchLeaves = 5;		else 			fBranchLeaves = 6;		fBranchesTotal = calcB (5);	}		fCurPositions.Fill (0);	fCurPositions[0] = 1;	fCurPositions[1] = 1;	if (IsRooted ())		fCurLeaves = 2;	else	{		fCurPositions[2] = 1;		fCurLeaves = 3;	}			fMaxPositions[0] = 1;	fMaxPositions[1] = 1;		if (IsRooted ())	{		for (unsigned int i = 2; i < GetLeaves (); ++i)			fMaxPositions[i] = (((i - 1)*2)+1);	}	else	{		for (unsigned int i = 2; i < GetLeaves (); ++i)			fMaxPositions[i] = (((i - 2)*2)+1);	}}