#include "TFuse.h"#include "DialogIDs.h"extern BOOL gAborted;#include "wstream.h"extern ostream *logStream;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TFuse::AddSplit (TSplit* split){	CHECK_ (split);	CHECK_ (0 < split->GetWeight ());		CHECK_ (IsRooted () ? split->IsRooted () : !split->IsRooted ());	CHECK_ (split->GetLeafSet ().IsSubset (GetLeafSet ()));		if (fMaxValue < split->GetWeight ())		fMaxValue = split->GetWeight (); 		fInputSplits.AddSplit (split, false);}void TFuse::Copy (const TObject& obj) { 	CHECK_ (Class () == obj.Class ());	const TFuse& fuse = (const TFuse&)obj;		CHECK_ (0);}void TFuse::Fuse (TSplitSet& splitSet){	fInputSplits.Sort ();		fCurValue = fMaxValue;	fCurRun = 1;	fCurSplit = 0;		MonitorDialog = TheApp->CreateMonitor (dlgProgressTextNoTree);	MonitorDialog->Show ();			while (!gAborted && !fInputSplits.IsEmpty ())	{			if	(addSplits ())		{			fuseSplits ();			if (!gAborted)				storeSplits (splitSet);		}		--fCurValue;	}		TheApp->DestroyDialog ();		splitSet.Sort ();}bool TFuse::addSplits (void){	bool added = false;	const TSplit* curSplit = NULL; // JLT 010412 made const	fInputSplits.FirstSplit (curSplit);	while (fInputSplits.CurSplit (curSplit))	{		if (curSplit->GetWeight () == fCurValue)		{			TSplit* detachSplit; // JLT 010412 added			fInputSplits.DetachCurSplit (detachSplit);			fFuseSplits.AddSplit (detachSplit, false); // JLT 010207 assuming not redundant			added = true;		}		else			fInputSplits.NextSplit (curSplit);	}	return (added);}void TFuse::storeSplits (TSplitSet& splitSet){	const TSplit* curSplit = NULL; // JLT 010412 made const	for (fFuseSplits.FirstSplit (curSplit); fFuseSplits.CurSplit (curSplit); fFuseSplits.NextSplit (curSplit))	{		if (curSplit->GetWeight () == fCurValue)			splitSet.AddSplit (*curSplit, true);	}}void TFuse::fuseSplits (void){	bool added = true;	bool completeRun = false;		fCurRun = 0;	fCurSplit = 0;	const TSplit* curSplit = NULL;	const TSplit* nextSplit = NULL;	TSplit prod1 (IsRooted ());	TSplit prod2 (IsRooted ());			do	{		completeRun = true;							++fCurRun;		fCurSplit = 1;						TString progress = "Decay Index: ";		progress.AddToThis (fCurValue);		progress +=  " Run: ";		progress.AddToThis (fCurRun);		progress += " Split: ";				TSplitSetIteratorConst iteratorConst (fFuseSplits);						iteratorConst.FirstSplit ();		while (iteratorConst.CurSplit (curSplit) && fCurValue < curSplit->GetWeight ())		{			TSplitSetIteratorConst nextIteratorConst (iteratorConst);			nextIteratorConst.NextSplit ();			while (nextIteratorConst.CurSplit (nextSplit) && fCurValue < nextSplit->GetWeight ()) // JLT 010311 added so does not repeat previous pairwise fusions ie only works with at least one of the new splits				nextIteratorConst.NextSplit (); 				while (!added && nextIteratorConst.CurSplit (nextSplit))			{								curSplit->GetFusionProducts (*nextSplit, prod1, prod2);								if (1 < prod1.GetLeaves (true) && 1 < prod1.GetLeaves (false) && !prod1.IsRedundant (*curSplit) && !prod1.IsRedundant (*nextSplit))				{					if (1 < prod2.GetLeaves (true) && 1 < prod2.GetLeaves (false) && !prod2.IsRedundant (*curSplit) && !prod2.IsRedundant (*nextSplit))					{						added = fFuseSplits.AddSplit (prod1, true);						bool bol = fFuseSplits.AddSplit (prod2, true);						added = (added ? added : bol);					}					else						added = fFuseSplits.AddSplit (prod1, true);				}				else if (1 < prod2.GetLeaves (true) && 1 < prod2.GetLeaves (false) && !prod2.IsRedundant (*curSplit) && !prod2.IsRedundant (*nextSplit))					added = fFuseSplits.AddSplit (prod2, true);				nextIteratorConst.NextSplit ();			}			if (added)			{				added = false;				completeRun = false;			}			else			{			 	iteratorConst.NextSplit ();			 	++fCurSplit;			 	TString progressSplits = progress;				progressSplits.AddToThis (fCurSplit);				MonitorDialog->SetItemText (4, progressSplits.Array ());			}			MonitorDialog->ProcessExternal ();			gAborted = MonitorDialog->HasAborted ();		}		unsigned int splitCount = fCurSplit;		while (iteratorConst.CurSplit (curSplit))		{			TSplitSetIteratorConst nextIteratorConst (iteratorConst);			nextIteratorConst.NextSplit ();			while (!added && nextIteratorConst.CurSplit (nextSplit))			{								curSplit->GetFusionProducts (*nextSplit, prod1, prod2);								if (1 < prod1.GetLeaves (true) && 1 < prod1.GetLeaves (false) && !prod1.IsRedundant (*curSplit) && !prod1.IsRedundant (*nextSplit))				{					if (1 < prod2.GetLeaves (true) && 1 < prod2.GetLeaves (false) && !prod2.IsRedundant (*curSplit) && !prod2.IsRedundant (*nextSplit))					{						added = fFuseSplits.AddSplit (prod1, true);						bool bol = fFuseSplits.AddSplit (prod2, true);						added = (added ? added : bol);					}					else						added = fFuseSplits.AddSplit (prod1, true);				}				else if (1 < prod2.GetLeaves (true) && 1 < prod2.GetLeaves (false) && !prod2.IsRedundant (*curSplit) && !prod2.IsRedundant (*nextSplit))						added = fFuseSplits.AddSplit (prod2, true);				 nextIteratorConst.NextSplit ();			}			if (added)			{				added = false;				completeRun = false;				iteratorConst.FirstSplit ();				while (iteratorConst.CurSplit (curSplit) && fCurValue < curSplit->GetWeight ())					iteratorConst.NextSplit ();				splitCount = fCurSplit;			}			else			{			 	iteratorConst.NextSplit ();			 	++splitCount;			 	TString progressSplits = progress;				progressSplits.AddToThis (splitCount);				MonitorDialog->SetItemText (4, progressSplits.Array ());			}			MonitorDialog->ProcessExternal ();			gAborted = MonitorDialog->HasAborted ();		}	}	while (!gAborted && !completeRun);}bool TFuse::IsEqual (const TObject& obj) const{	CHECK_ (Class () == obj.Class ());		const TFuse& fuse = (const TFuse&)obj;	CHECK_ (0);		return (false);}TFuse& TFuse::operator = (const TFuse& fuse){	SetFlag (kRooted, fuse.IsRooted ());	CHECK_ (0);			return (*this);}TFuse::TFuse (const TLeafSet& leafSet, const bool rooted)	:	fInputSplits (rooted),		fFuseSplits (rooted){	CHECK_ (rooted); // need to do unrooted		CHECK_ (3 < leafSet.GetLeaves ());	SetFlag (kRooted, rooted);		fLeafSet = leafSet;	fMaxValue = 0;	fCurValue = 0;	fCurRun = 0;	fCurSplit = 0;}TFuse::TFuse (const TFuse& fuse){	SetFlag (kRooted, fuse.IsRooted ());}TFuse::~TFuse (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif