#include "TSplit.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifint TSplit::Compare (const TSortable& obj) const{	CHECK_ (Class () == obj.Class ());	const TSplit& split = (const TSplit&) obj;	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());		if (GetWeight () != split.GetWeight ())	{		if (split.GetWeight () < GetWeight ()) // JLT 010211			return (-1);		return (1);	}	if (GetLeaves () != split.GetLeaves ()) 	{		if (split.GetLeaves () < GetLeaves ())			return (-1);		return (1);	}	// JLT 011128 added to remove bug in strict RCC profile which producing multiple copies of same trees	// JLT 011129 switched ranking	if (fLeafSet != split.fLeafSet) 	{		if (split.fLeafSet < fLeafSet)			return (-1);		return (1);	}	// JLT 011129	// JLT 011128	if (!IsRooted ())	{		if (fInsideSet->FirstLeaf () < fOutsideSet->FirstLeaf ())			Flip ();		if (split.fInsideSet->FirstLeaf () < split.fOutsideSet->FirstLeaf ())			split.Flip ();	}	if (*fInsideSet != *split.fInsideSet) 	{		if (*fInsideSet < *split.fInsideSet)			return (-1);		return (1);	}	if (*fOutsideSet != *split.fOutsideSet) 	{		if(*fOutsideSet < *split.fOutsideSet)			return (-1);		return (1);	}			return (0);}void TSplit::Copy (const TObject& obj) {	CHECK_ (Class () == obj.Class ());	const TSplit& split = (const TSplit&)obj;	SetFlag (kRooted, split.IsRooted ());		fPartitionA.Copy (split.fPartitionA);	fPartitionB.Copy (split.fPartitionB);	if (split.fInsideSet == &split.fPartitionA)	{		fInsideSet = &fPartitionA;		fOutsideSet = &fPartitionB;	}	else	{		fInsideSet = &fPartitionB;		fOutsideSet = &fPartitionA;	}	fLeafSet.Copy (split.fLeafSet);	fNumber = split.fNumber;	fWeight = split.fWeight;}void TSplit::EmptySplit (void){	fInsideSet->SetEmpty ();	fOutsideSet->SetEmpty ();	fLeafSet.SetEmpty ();}void TSplit::Flip (void) const{		CHECK_ (!IsRooted ());	TLeafSet* swap = ((TSplit*)this)->fInsideSet;	((TSplit*)this)->fInsideSet = fOutsideSet;	((TSplit*)this)->fOutsideSet = swap;}bool TSplit::GetFusionProducts (const TSplit& fuse2, TSplit& prod1, TSplit& prod2) const{	CHECK_ (IsRooted ()); // do unrooted	const TSplit& fuse1 = *this;	const bool inside = true;	const bool outside = false;	bool fused = false;		prod1.SetEmpty ();	prod2.SetEmpty ();		CHECK_ (IsRooted () ? fuse2.IsRooted () && prod1.IsRooted () && prod2.IsRooted () : !fuse2.IsRooted () && !prod1.IsRooted () && !prod2.IsRooted ());		double minWeight = (fuse1.GetWeight () < fuse2.GetWeight () ? fuse1.GetWeight () : fuse2.GetWeight ());	prod1.SetWeight (minWeight);	prod2.SetWeight (minWeight);		if (!(fuse1.GetLeafSet (inside) * fuse2.GetLeafSet (inside)).IsEmpty ())	{						if (!(fuse1.GetLeafSet (inside) * fuse2.GetLeafSet (outside)).IsEmpty ())		{			CHECK_ ((fuse2.GetLeafSet (inside) * fuse1.GetLeafSet (outside)).IsEmpty ()) // attempting to fuse two incompatible splits 			*prod1.fInsideSet = (fuse1.GetLeafSet (inside) + fuse2.GetLeafSet (inside));			*prod1.fOutsideSet = (fuse1.GetLeafSet (outside));			prod1.fLeafSet = (*prod1.fInsideSet + *prod1.fOutsideSet); 			*prod2.fInsideSet = (fuse2.GetLeafSet (inside));			*prod2.fOutsideSet = (fuse1.GetLeafSet (outside) + fuse2.GetLeafSet (outside));			prod2.fLeafSet = (*prod2.fInsideSet + *prod2.fOutsideSet); 		}		else if (!(fuse2.GetLeafSet (inside) * fuse1.GetLeafSet (outside)).IsEmpty ())		{			*prod1.fInsideSet = (fuse1.GetLeafSet (inside) + fuse2.GetLeafSet (inside));			*prod1.fOutsideSet = (fuse2.GetLeafSet (outside));			prod1.fLeafSet = (*prod1.fInsideSet + *prod1.fOutsideSet); 			*prod2.fInsideSet = (fuse1.GetLeafSet (inside));			*prod2.fOutsideSet = (fuse1.GetLeafSet (outside) + fuse2.GetLeafSet (outside));			prod2.fLeafSet = (*prod2.fInsideSet + *prod2.fOutsideSet); 		}		else		{			*prod1.fInsideSet = (fuse1.GetLeafSet (inside) * fuse2.GetLeafSet (inside));			*prod1.fOutsideSet = (fuse1.GetLeafSet (outside) + fuse2.GetLeafSet (outside));			prod1.fLeafSet = (*prod1.fInsideSet + *prod1.fOutsideSet); 						*prod2.fInsideSet = (fuse1.GetLeafSet (inside) + fuse2.GetLeafSet (inside));			*prod2.fOutsideSet = (fuse1.GetLeafSet (outside) * fuse2.GetLeafSet (outside));			prod2.fLeafSet = (*prod2.fInsideSet + *prod2.fOutsideSet); 		}		fused = true;	}	else if (!(fuse1.GetLeafSet (inside) * fuse2.GetLeafSet (outside)).IsEmpty () && !(fuse2.GetLeafSet (inside) * fuse1.GetLeafSet (outside)).IsEmpty ())	{			// what the fuck is going on here??			if ((fuse1.GetLeafSet (inside)).GetLeaves () > ((fuse1.GetLeafSet (inside) * fuse2.GetLeafSet (outside)).GetLeaves ()) )		{			*prod1.fInsideSet = (fuse2.GetLeafSet (inside));			*prod1.fOutsideSet = (fuse1.GetLeafSet (inside) + fuse2.GetLeafSet (outside));			prod1.fLeafSet = (*prod1.fInsideSet + *prod1.fOutsideSet); 			fused = true;		}		if (fuse2.GetLeafSet (inside).GetLeaves () > ((fuse2.GetLeafSet (inside) * fuse1.GetLeafSet (outside)).GetLeaves ()))		{			*prod2.fInsideSet = (fuse1.GetLeafSet (inside));			*prod2.fOutsideSet = (fuse2.GetLeafSet (inside) + fuse1.GetLeafSet (outside));			prod2.fLeafSet = (*prod2.fInsideSet + *prod2.fOutsideSet); 			fused = true;		}	}	return (fused);}void TSplit::Intersection (const TSplit& split, TSplit& intersection) const{	CHECK_ (IsRooted () ? split.IsRooted () && intersection.IsRooted () : !split.IsRooted () && !intersection.IsRooted ());	intersection = split;	intersection.fInsideSet->IntersectWithThis (*fInsideSet);	intersection.fOutsideSet->IntersectWithThis (*fOutsideSet);	intersection.fLeafSet = (*intersection.fInsideSet + *intersection.fOutsideSet);	intersection.fWeight = min (fWeight, split.fWeight);}bool TSplit::IsCompatible (const TSplit& split) const{	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());			if (((*fInsideSet) * (*split.fInsideSet)).IsEmpty ()) 		return (true);			if (((*fInsideSet) * (*split.fOutsideSet)).IsEmpty ()) 		return (true);		if (((*fOutsideSet) * (*split.fInsideSet)).IsEmpty ()) 		return (true);		if (!IsRooted() && ((*fOutsideSet) * (*split.fOutsideSet)).IsEmpty ()) 		return (true);		return (false);}bool TSplit::IsDisplays (const TQuartet& quartet) const{	CHECK_ (IsRooted () ? quartet.IsRooted () : !quartet.IsRooted ());	return (false);}bool TSplit::IsEqual (const TObject& obj) const{	CHECK_ (Class () == obj.Class ());	const TSplit& split = (const TSplit&)obj;	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());		if (GetWeight () != split.GetWeight () || !GetLeafSet ().IsEqual (split.GetLeafSet ()))		return (false);				if (fInsideSet->IsEqual (*split.fInsideSet) && fOutsideSet->IsEqual (*split.fOutsideSet))			return (true);			if (IsRooted ()) 		return (false);	Flip ();	return ((bool)(fInsideSet->IsEqual (*split.fInsideSet) && fOutsideSet->IsEqual (*split.fOutsideSet)));}bool TSplit::IsInformative (void) const{	if (IsRooted ())		return ((bool)(fInsideSet->GetLeaves () > 1 && fOutsideSet->GetLeaves () > 0 && GetWeight ()));	else		return ((bool)(fInsideSet->GetLeaves () > 1 && fOutsideSet->GetLeaves () > 1 && GetWeight ()));}bool TSplit::IsRedundant (const TSplit& split) const{	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());		if (split.GetWeight () < GetWeight ())		return (false);		TSplit intersection (IsRooted ());	Intersection (split, intersection); 	if (IsRooted ())		return (IsEqual (intersection));			if (IsEqual (intersection))		return (true);	Flip ();	Intersection (split, intersection);	return (IsEqual (intersection));}TSplit& TSplit::operator = (const TSplit& split){	SetFlag (kRooted, split.IsRooted ());	fPartitionA = split.fPartitionA;	fPartitionB = split.fPartitionB;	if (split.fInsideSet == &split.fPartitionA)	{		fInsideSet = &fPartitionA;		fOutsideSet = &fPartitionB;	}	else	{		fInsideSet = &fPartitionB;		fOutsideSet = &fPartitionA;	}	fLeafSet = split.fLeafSet;	fNumber = split.fNumber;	fWeight = split.fWeight;	return (*this);}void TSplit::PruneLeaf (const unsigned int leaf){	fInsideSet->SubtractFromThis (leaf);	fOutsideSet->SubtractFromThis (leaf);	fLeafSet.SubtractFromThis (leaf);}void TSplit::PruneLeaves (const TLeafSet& leafSet){	fInsideSet->SubtractFromThis (leafSet);	fOutsideSet->SubtractFromThis (leafSet);	fLeafSet.SubtractFromThis (leafSet);}TSplit::TSplit (const bool rooted, const double weight){	SetFlag (kRooted, rooted);	fInsideSet = &fPartitionA;	fOutsideSet = &fPartitionB;		fWeight = weight;	fNumber = 0;}TSplit::TSplit (const TLeafSet& insideSet, const TLeafSet& leafSet, const bool rooted, const double weight){	CHECK (insideSet.IsSubset (leafSet));	SetFlag (kRooted, rooted);	fPartitionA = insideSet;	fPartitionB = leafSet - insideSet;	fInsideSet = &fPartitionA;	fOutsideSet = &fPartitionB;		fLeafSet = leafSet;	fNumber = 0;	fWeight = weight;}TSplit::TSplit (const TSplit& split){	SetFlag (kRooted, split.IsRooted ());	fPartitionA = split.fPartitionA;	fPartitionB = split.fPartitionB;	if (split.fInsideSet == &split.fPartitionA)	{		fInsideSet = &fPartitionA;		fOutsideSet = &fPartitionB;	}	else	{		fInsideSet = &fPartitionB;		fOutsideSet = &fPartitionA;	}	fLeafSet = split.fLeafSet;	fNumber = split.fNumber;	fWeight = split.fWeight;}ostream& TSplit::WriteAsStar (ostream &o, const TLeafSet leafSet, const bool writeWeight) const{	if (!IsRooted () && fInsideSet->FirstLeaf () < fOutsideSet->FirstLeaf ())		Flip ();		for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())	{		if (fInsideSet->IsLeaf (leaf))			o <<'*';		else if (fOutsideSet->IsLeaf (leaf))			o <<'.';		else 			o << '?';					if (!(leaf % 5))      		o << " ";	}	if (writeWeight)		o << ' ' << fWeight;	return (o);}ostream& TSplit::WriteAsNewick (ostream &o, const bool writeWeight) const{	if (!IsRooted () && fInsideSet->FirstLeaf () < fOutsideSet->FirstLeaf ())		Flip ();	if (IsRooted ())		o << "[&R] ";	else		o << "[&U] ";		 	o << "((";		unsigned int n = fInsideSet->FirstLeaf ();		if (n) 	{		o << n;		while ((n = fInsideSet->NextLeaf ()) != 0)			o << ',' << n;	}			o << ')';		if (writeWeight) // JLT 010311 added write weight	{		o << ":" << GetWeight ();	}			n = fOutsideSet->FirstLeaf ();		if (n) 	{		o << ',' << n;		while ((n = fOutsideSet->NextLeaf ()) != 0)			o << ',' << n;	}	o << ");";		return (o);}ostream& TSplit::WriteAsCharacter (ostream& o, const TLeafSet leafSet) const{	if (!IsRooted () && fInsideSet->FirstLeaf () < fOutsideSet->FirstLeaf ())		Flip ();	for (unsigned int leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())	{			if (fInsideSet->IsLeaf (leaf))				o << '1';			else if (fOutsideSet->IsLeaf (leaf))				o << '0';			else 				o << '?';	}	return (o);}TSplit::~TSplit (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif