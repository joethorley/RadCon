#ifndef __TLEAFMAP_H#define __TLEAFMAP_H#include "TClassTypes.h"#include "TArray.h"#include "TCladistic.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TLeafMap ___#endif// provides one to one mapping between two leafsetsclass TLeafMap : public TCladistic{	public:		TLeafMap (void);		TLeafMap (const unsigned int from, const unsigned int to);		TLeafMap (const TLeafSet& from, const TLeafSet& to);		TLeafMap (const TLeafMap& leafMap);		virtual ~TLeafMap (void); 				virtual void							AddMapping (const unsigned int from, const unsigned int to);		virtual void							AddMapping (const TLeafSet& from, const TLeafSet& to);		virtual ClassType						Class (void) const { return (kTLeafMapClass); };		virtual TObject*						Clone (void) const { return (new TLeafMap (*this)); };		virtual void							Copy (const TObject& object);		virtual void							ClearMapping (const unsigned int leaf);		virtual void							ClearMapping (const TLeafSet& leafSet);		virtual void							ClearMapping (void);		virtual const TLeafSet&					GetLeafSet (void) const { return (fFrom); };		virtual unsigned int						GetMapping (unsigned int from) const { return (fMap[from - 1]); };		virtual TLeafSet						GetMapping (const TLeafSet& leafSet) const;		virtual const TLeafSet&					GetMapping (void) const { return (fTo); };		virtual void							IncrMapping (const unsigned int incr = 1);		// will not be a mapping if empty or if the leafsets are identical		virtual bool							IsMapping (void) const { return (fFrom != fTo); };		TLeafMap&								operator = (const TLeafMap& leafMap);		virtual void							SetMapping (const unsigned int from, const unsigned int to);		virtual void							SetMapping (const TLeafSet& from, const TLeafSet& to);	protected:		TArray<unsigned int> 						fMap;		TLeafSet								fFrom;		TLeafSet								fTo;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#endif // __TLEAFMAP_H