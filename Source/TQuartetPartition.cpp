#include "TQuartetPartition.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TQuartetPartition::AddQuartets (const TDistanceMatrix& distanceMatrix, const double weight){		if (IsRooted ())	{		unsigned short AB, AC, A, B, C;		for (unsigned short i = 1; i <= GetQuartets (); ++i)		{			TQuartet& quartet = ithQuartetRef (i);						A = quartet.A ();			B = quartet.B ();			C = quartet.C ();			if (distanceMatrix.IsLeaf (A) && distanceMatrix.IsLeaf (B) && distanceMatrix.IsLeaf (C))			{											AB = distanceMatrix.Distance (A, B);				AC = distanceMatrix.Distance (A, C);				if (AB < AC)					quartet.AddQuartetType (kOne, weight);				else if (AC < AB)					quartet.AddQuartetType (kTwo, weight);				else if (distanceMatrix.Distance (B, C) < AB)					quartet.AddQuartetType (kThree, weight);				else					quartet.AddQuartetType (kZero, weight);			}		}	}	else	{		unsigned short AB, AC, BC, AD, BD, A, B, C, D;		for (unsigned short i = 1; i <= GetQuartets (); ++i)		{			TQuartet& quartet = ithQuartetRef (i);						A = quartet.A ();			B = quartet.B ();			C = quartet.C ();			D = quartet.D ();									if (distanceMatrix.IsLeaf (A) && distanceMatrix.IsLeaf (B) && distanceMatrix.IsLeaf (C) && distanceMatrix.IsLeaf (D))			{				AB = distanceMatrix.Distance (A, B);				AC = distanceMatrix.Distance (A, C);				BC = distanceMatrix.Distance (B, C);				if (AB < AC) // ((A,B),C)				{					AD = distanceMatrix.Distance (A, D);					if (AB < AD) // ((A,B),C) + ((A,B),D) = ((A,B),C,D)						quartet.AddQuartetType (kOne, weight);					else if (AD < AB) // ((A,B),C) + ((A,D),B) = ((A,D),B),C)						quartet.AddQuartetType (kThree, weight);					else if (distanceMatrix.Distance (B, D) < AD) // ((A,B),C) + ((B,D),A) = ((B,D),A),C) 						quartet.AddQuartetType (kTwo, weight);					else // ((A,B),C) + (A,B,D) = (A,B,D),C) 						quartet.AddQuartetType (kZero, weight);				}				else if (AC < AB) // ((A,C),B)				{					AD = distanceMatrix.Distance (A, D);					if (AC < AD) // ((A,C),B) + ((A,C),D) = ((A,C),B,D)						quartet.AddQuartetType (kTwo, weight);					else if (AD < AC) // ((A,C),B) + ((A,D),C) = ((A,D),C),B)						quartet.AddQuartetType (kThree, weight);					else if (distanceMatrix.Distance (C, D) < AD) // ((A,C),B) + ((C,D),A) = ((C,D),A),B) 						quartet.AddQuartetType (kOne, weight);					else // ((A,C),B) + (A,C,D) = ((A,C,D),B) 						quartet.AddQuartetType (kZero, weight);				}				else if (BC < AB) // ((B,C),A)				{					BD = distanceMatrix.Distance (B, D);					if (BC < BD) // ((B,C),A) + ((B,C),D) = ((B,C),A,D)						quartet.AddQuartetType (kThree, weight);					else if (BD < BC) // ((B,C),A) + ((B,D),C) = ((B,D),C),A)						quartet.AddQuartetType (kTwo, weight);					else if (distanceMatrix.Distance (C, D) < BD) // ((B,C),A) + ((C,D),B) = ((C,D),B),A) 						quartet.AddQuartetType (kOne, weight);					else // ((B,C),A) + (B,C,D) = ((B,C,D),A) 						quartet.AddQuartetType (kZero, weight);				}				else // (A,B,C)				{					if (distanceMatrix.Distance (A, D) < AB) // (A,B,C) + ((A,D),B) = ((A,D),B,C)						quartet.AddQuartetType (kThree, weight);					else if (distanceMatrix.Distance (B, D) < AB) // (A,B,C) + ((B,D),A) = ((B,D),A,C)						quartet.AddQuartetType (kTwo, weight);					else if (distanceMatrix.Distance (C, D) < AB) // (A,B,C) + ((C,D),A) = ((C,D),A,B) 						quartet.AddQuartetType (kOne, weight);					else // (A,B,C) + (A,B,C,D) = (A,B,C,D) 						quartet.AddQuartetType (kZero, weight);				}			}									}	}}void TQuartetPartition::Copy (const TObject& obj){	CHECK (Class () == obj.Class ());	const TQuartetPartition& quartetPartition = (const TQuartetPartition&)obj;	fLeaves = quartetPartition.fLeaves;	fArray = quartetPartition.fArray;	fStart.Copy (quartetPartition.fStart);		SetFlag (TQUARTETPARTITION_FLAG_ROOTED, quartetPartition.IsRooted ());}unsigned short TQuartetPartition::GetResolvedQuartets (const unsigned short leaf) const{	CHECK_ (!leaf || leaf <= fLeaves);		const TQuartet* quartet;	unsigned short resolvedQuartets = 0;		for (unsigned short i = 1; IthQuartet (i, quartet); ++i)		if ((!leaf || quartet->IsLeaf (leaf)) && quartet->IsResolved ())			++resolvedQuartets;	return (resolvedQuartets);}		bool TQuartetPartition::IsEqual (const TObject&) const{	CHECK_ (0);	return (0);}bool TQuartetPartition::IthQuartet (const unsigned short i, const TQuartet*& quartet) const{	if (IthQuartet (i))	{		quartet = &IthQuartetRef (i);		return (true);	}	return (false);}TQuartetPartition& TQuartetPartition::operator = (const TQuartetPartition& quartetPartition){	fLeaves = quartetPartition.fLeaves;	fArray = quartetPartition.fArray;	fStart = quartetPartition.fStart;		SetFlag (TQUARTETPARTITION_FLAG_ROOTED, quartetPartition.IsRooted ());	return (*this);}// a copy of TQuartet start is used as its value is alteredTQuartetPartition::TQuartetPartition (TQuartet start, const unsigned short quartets, const unsigned short leaves)	: fArray (quartets)	, fStart (start)	, fLeaves (leaves){	SetFlag (TQUARTETPARTITION_FLAG_ROOTED, fStart.IsRooted ());		for (unsigned short i = 0; i < quartets; ++i)	{		if (!IsRooted ()) // essential if unrooted as the default TQuartets created in the array are rooted			fArray[i].UnRoot ();		fArray[i].SetLeaves (start);		start.SetLeavesNextQuartet (leaves);	}}TQuartetPartition::TQuartetPartition (const TQuartetPartition& quartetPartition)	: fArray (quartetPartition.fArray)	, fStart (quartetPartition.fStart)	, fLeaves (quartetPartition.fLeaves){	SetFlag (TQUARTETPARTITION_FLAG_ROOTED, quartetPartition.IsRooted ());}TQuartetPartition::~TQuartetPartition (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif