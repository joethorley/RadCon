#ifndef __TTREE_H#define __TTREE_H// the number of internal branches is always one less than the number of internals// (but cannot be less than 0)// the number of internal branches is always one less if the tree is unrooted if the// degree of the root is less than 3.// a tree is uninformative if number of internal branches == 0// can have trees with no internal nodes (and no internal branches)// i.e. if no leaves i.e. just root and then unrooted !!!!!// note an unrooted tree should never have a binaryroot and unless being stored...// better to store as if rooted with binary root and collapse when wanted.// think I understand....#include "TClassTypes.h"#include "TNexusName.h"#include "TTreeNodeStack.h"#include "TTreeNode.h"#include "TCalc.h"#include "TAncestorFunction.h"#include "TObject.h"#include "TTaxaBlock.h"#include "TTranslationTable.h"#include "TPlot.h"#include "TChecks.h"#include "TSplit.h"#include "TDistanceMatrix.h"#include "TLeafMap.h"#include "TSplit.h"#include "TCladistic.h"#include "TFlags.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TSourceTreesFile ___#endifclass TTree : public TCladistic{	public:		enum		{			kCMF						= 0x0004, // draw trees using component monaco font as opposed to ASCII characters			kBranchAndBound				= 0x0010, // used to indicate if grafting and pruning leaves from store			kWeightsInternals			= 0x1000		};				TTree (const bool rooted = true);		TTree (const TTree& tree);		virtual	~TTree (void);		virtual void								AddToThis (const TCluster& cluster, const TString label = "");		virtual void								AddToThis (const TLeafSet& cluster, const double weight = kDefaultWeight);		virtual void								AddToThis (const TSplit& split);		virtual void 								AddToThis (const TTree& tree);		 		virtual	void								AncestorFunction (TAncestorFunction& anf) const;					virtual ClassType							Class (void) const { return (kTTreeClass); };		virtual TObject*							Clone (void) const { return (new TTree (*this)); };				virtual void								Copy (const TObject& obj);						virtual	void 								DeleteTree (void);				virtual unsigned int 							Distance (const unsigned int leafA, const unsigned int leafB) const;		virtual void								DistanceMatrix (TDistanceMatrix& matrix);		virtual void 								Draw (VRect rect, VFontPtr labelFont, const TTreeStyle& treeStyle, VFontPtr edgeFont) const;		//		virtual	void 								Draw (const TTreePlot& treeplot) const;		virtual	TTree&								FromAncestorFunction (const TAncestorFunction& anf);				virtual TTree& 								FromTreeString (const TString& treeString);		virtual float			 					GetCIC (void) const { return (calcCIC (GetResolutions (), calcB (GetLeaves () - (IsRooted () ? 0 : 1)))); };		virtual float			 					GetMaxCIC (void) const { return (calcCIC (1, calcB (GetLeaves () - (IsRooted () ? 0 : 1)))); };		virtual float			 					GetNormalisedCIC (void) const { return (GetCIC () / GetMaxCIC ()); };		virtual bool								IthInternalNode (const unsigned int i, const TTreeNode*& node) const;		virtual const TTreeNode*					GetRoot (void) const { return (fRoot); };		virtual double								GetResolutions (void) const;		virtual TreeType							GetTreeType (void) const { return (fTreeType); };				virtual unsigned long							GetBalance (void) const { return (GetMaxImbalance () - GetImbalance ()); };		virtual unsigned long							GetImbalance (void) const;		virtual unsigned long 							GetMaxImbalance (void) const { CHECK_ (IsRooted () && IsBinary ()); return (getMaxImbalance (GetLeaves ())); };		virtual unsigned long 							GetMinImbalance (void) const { return (getMinImbalance (GetLeaves ())); };		virtual unsigned long 							GetMaxBalance (void) const { CHECK_ (IsBinary () && IsRooted () && 3 < GetLeaves ()); return (GetMaxImbalance () - GetMinImbalance ()); }				virtual unsigned long					GetResolvedTriplets (void) const;		virtual unsigned long					GetResolvedQuartets (void) const;		virtual unsigned long 					GetMaxResolvedTriplets (void) const { CHECK_ (2 < GetLeaves () && GetLeaves () <= 1500); return (((unsigned long)GetLeaves () * (unsigned long)(GetLeaves () - 1) * (unsigned long)(GetLeaves () - 2)) / (unsigned long)6); };		virtual unsigned long					GetMaxResolvedQuartets (void) const { CHECK_ (3 < GetLeaves () && GetLeaves () <= 500); return (((unsigned long)GetLeaves () * (unsigned long)(GetLeaves () - 1) * (unsigned long)(GetLeaves () - 2) * (unsigned long)(GetLeaves () - 3)) / (unsigned long)24); };				virtual float								GetNormalisedResolvedTriplets (void) const { return ((double)GetResolvedTriplets () / (double)GetMaxResolvedTriplets ()); };		virtual float								GetNormalisedResolvedQuartets (void) const { return ((double)GetResolvedQuartets () / (double)GetMaxResolvedQuartets ()); };				virtual void 								GraftLeaf (const unsigned int leaf, unsigned int position);		virtual void 								GraftLeafAsOutgroup (const unsigned int leaf);			virtual	unsigned int							InternalBranches (void) const { return (InternalNodes () - 1); };		virtual unsigned int						GetResolution (void) const { return (InternalBranches ()) ; };		virtual unsigned int						GetMaxResolution (void) const { return (GetLeaves () - (IsRooted () ? 2 : 3)); };		virtual float								GetNormalisedResolution (void) const { return ((float)GetResolution () / (float)GetMaxResolution ()); };		virtual unsigned int							InternalNodes (void) const { return (fInternals); };		virtual bool 								IsAdamsResolution (const TTree& tree) const;		virtual bool								IsBinaryRoot (void) const { return (isNodeBinary (fRoot)); };		virtual bool								IsBinary (void) const { CHECK_ (IsRooted () || !isNodeBinary (fRoot)); return ((bool)(IsRooted () ? ((fLeaves - fInternals) == 1) : ((fLeaves - fInternals) == 2))); };				virtual bool								IsCompatible (const TTree& tree) const;		virtual bool								IsCompatible (const TSplit& split) const;		virtual bool								IsCompatible (const TLeafSet& cluster) const;		virtual bool								IsContraction (const TTree& tree) const;		virtual bool								IsDisplays (const TSplit& split) const;		virtual bool								IsDisplays (const TLeafSet& cluster) const { return ((bool)(MRCA (cluster)->IsEqual (cluster))); };				virtual bool								IsEqual (const TObject& obj) const;		virtual bool								IsWeightsInternals (void) const { return (IsFlag (kWeightsInternals)); };		virtual void								SetLabelsInternals (void);						virtual void								SetWeightsInternals (const bool set = true) { SetFlag (kWeightsInternals, set); };				virtual	bool								IsInformative (void) const { return (InternalBranches ()); };				virtual bool								IsStarTree (void) const { CHECK_ (GetLeaves ()); return (!InternalBranches ()); };				virtual unsigned int 						GetMaxLeafHeight (void) const { return (fMaxLeafHeight); };		virtual	const TLeafSet&						GetLeafSet (void) const { CHECK_ (fRoot); return (*fRoot); }; 					virtual void 								LabelCluster (const TLeafSet& cluster, const TString label);		virtual	void								LabelLeaves (const TTaxaBlock&);		virtual const TTreeNode* 					LUB (const TLeafSet& leafSet) const;			virtual void 								MapLeaves (const TLeafMap& leafMap);				virtual const TTreeNode*					MRCA (const TLeafSet& leafSet) const;				virtual	const TTreeName&					GetName (void) const { return (fName); };		virtual	unsigned int							Nodes (void) const { return (GetLeaves () + InternalNodes ()); };					virtual	TTree& 								operator = (const TTree& tree); 		virtual void 								PruneLeaf (const unsigned int leaf);		virtual	void 								PruneLeaves (const TLeafSet& toPrune);				virtual	void 								ReArrange (void) const { reArrangeTraverse (fRoot); };		virtual	void 								Root (const bool binaryRoot = true);					virtual void								SetBootstrap (const unsigned int replicate, const unsigned int number) { fName.SetBootstrap (replicate, number); };		virtual	void								SetName (const char* str) { fName = str; };		virtual	void								SetName (const TString& str)  { fName = str; };		virtual void								SetNodeHeights (const TTreeStyle::NodeHeights nodeHeights = TTreeStyle::kCardinality); 		virtual void								SetWeight (const double weight) { CHECK_ (kMinWeight <= weight && weight <= kMaxWeight); fWeight = weight; };		virtual void								ReRoot (const unsigned int leaf);		virtual void								SetTreeType (const TreeType treeType) { CHECK_ (treeType != kStrictNestings || IsRooted ()); fTreeType = treeType; };				virtual void 								StarTree (const unsigned int leaves);		virtual void								StarTree (const TLeafSet& leafSet);		virtual void 								ThreeLeafTree (const unsigned int leaves);		virtual void 								TwoLeafTree (const unsigned int leaves);		virtual void 								ThreeLeafTree (const TLeafSet& leafSet);		virtual void 								TwoLeafTree (const TLeafSet& leafSet);		virtual	void 								UnRoot (void);						  	  	virtual double							GetWeight (void) const { return (fWeight); };			virtual	ostream&		 					Write (ostream& o) const { return (Write (o, true)); };		virtual	ostream&		 					Write (ostream& o, const bool name) const { return (WriteAsText (o, name)); };		virtual	ostream&		 					WriteAsText (ostream& o, const bool name = true, const bool cmf = true) const;		virtual	ostream&							WriteAsNexus (ostream& o, const int fileWidth = 0) const;		virtual	ostream&							WriteAsNewickTreeDescription (ostream& o, const int fileWidth = 0) const;		virtual	void			 					WriteToLog (void) const { WriteToLog (true); };		virtual void								WriteToLog (const bool name) const;	   		protected:		virtual	void 								calcCoordinates (TTreeNode* node) const;		virtual void 								addToThisTraverse (const TTreeNode* node);		virtual void								collapseBinaryRoot (TTreeNode*& nodePtr) const;		virtual	void								deleteNode (TTreeNode* n) const { delete (n); };		virtual	void 								deleteTraverse (TTreeNode* n);		virtual void 								deleteTree (void);		virtual	char								downChar (void) const { return ((IsFlag (kCMF)) ? ((char)227) : ((char)43)); }; // +		virtual	void 								drawTraverse (TTreeNode* node) const;		virtual	void 								drawAsTextTraverse (ostream& o, const TTreeNode* n) const;		virtual	void 								drawAsTextPendantEdge (ostream& o, const TTreeNode* n) const;		virtual	void 								drawAsTextInteriorEdge (ostream& o, const TTreeNode* n) const;		virtual	void 								drawAsTextFillInAncestors (const TTreeNode* n) const;		virtual TTreeNode* 							firstNonMarkedDescendant (TTreeNode* n) const;		// change name of this bollocking thing!!		virtual void 								fromAncestorFunctionAddNode (TTreeNode* nunode, const unsigned int ancestor);		virtual unsigned int							getDegreeNode (const TTreeNode& node) const;		virtual	TTreeNode*&							getIthInternal (const unsigned int n) const { return (n < kMaxLeaves ? (((TTree*)this)->fInternalArray[n - 1]) : (((TTree*)this)->fInternalArray[n - (kMaxLeaves + 1)])); };		virtual TTreeNode*							getInternal (const TLeafSet& cluster) const;		virtual void 								getImbalanceTraverse (const TTreeNode* node, unsigned long& imbalance) const;				virtual TTreeNode* 							getIthInternalTraversal (const unsigned int i);		virtual	TTreeNode*&							getLeaf (const unsigned int n) const { return (((TTree*)this)->fLeafArray[n - 1]); };		static unsigned long 						getMinImbalance (const unsigned int leaves);		static unsigned long 						getMaxImbalance (const unsigned int leaves) { CHECK_ (2 < leaves); return (((leaves - 1) * (leaves - 2)) / 2); };		virtual void 								getResolutionsTraverse (const TTreeNode* node, double& resolutions) const;		virtual void 								graftLeaf (TTreeNode* leafPtr, TTreeNode* nodePtr, TTreeNode* internalPtr = NULL);		virtual bool 								isEqual (const TTreeNode* node, const TTree& tree) const;		virtual	char								hbarChar (void) const { return ((IsFlag (kCMF)) ? ((char)220) : ((char)45)); }; // -		virtual bool 								isCompatibleTraverse (const TTreeNode* node) const;		virtual bool 								isContractionTraverse (const TTreeNode* node) const;				virtual bool								isNodeBinary (TTreeNode* n) const;		virtual bool								isOutGroup (const unsigned int leaf) const { CHECK_ (IsLeaf (leaf)); return (isOutGroup (getLeaf (leaf))); };		virtual bool								isOutGroup (const TTreeNode* n) const { CHECK_ (n); return ((bool)(fRoot->GetChild () == n) && (2 < GetLeaves () || (IsRooted () && 1 < GetLeaves ())) && (IsRooted () ? IsBinaryRoot () : !IsBinaryRoot ())); };		virtual void 								ithInternalTraverse (unsigned int& i, TTreeNode* n, TTreeNode*& internal);		virtual	char								leftmostChar (void) const { return ((IsFlag (kCMF)) ? ((char)223) : ((char)92)); };		virtual	void 								listOtherDescendants (TTreeNode* n) const;		virtual	char								lonenodeChar (void) const { return ((IsFlag (kCMF)) ? ((char)208) : ((char)63)); };		virtual	void	  							makeAncestor (void);		virtual	void 								makeChild (void);		virtual	void	  							makeSibling (void);		virtual void								makeRootBinary (void) const;		virtual	void								mark (TTreeNode* n, const bool bmark);		virtual	void								markAll (const bool bmark = true) { mark (fRoot, bmark); };		virtual	void 								markPath (TTreeNode* n) const;		virtual TTreeNode*							newNode (void) const { return (new TTreeNode (GetWeight ())); }; //wtf is all the weight about ???		virtual	TTreeNode* 							nextNonMarkedDescendant (TTreeNode* n) const;				virtual unsigned int							getOutGroup (void) const { CHECK_ (GetLeaves ()); return (isOutGroup (fRoot->GetChild ()) ? fRoot->GetChild ()->GetNumber () : 0); };				virtual void 								pruneLeaf (TTreeNode* leaf, TTreeNode*& internal);		virtual void 								readComponentFromTreeString (TStringIteratorConst& iterator);		virtual	unsigned int 							readNodeNumber (char** p) const;		virtual	void 								reArrangeComponent (TTreeNode* n) const;				virtual	void								reArrangeTraverse (TTreeNode* n) const;		virtual void 								replaceNode (TTreeNode* node, TTreeNode* replacement);		virtual	char								rightmostChar (void) const { return ((IsFlag (kCMF)) ? ((char)222) : ((char)43)); }; //		virtual	char								rootChar (void) const { return (teeChar ()); };				virtual	void 								reRoot (TTreeNode* n);		virtual void 								setNodeHeights_Height (TTreeNode* node, const unsigned int height);		virtual void 								setNodeHeights_Depth (TTreeNode* node);		virtual void 								setNodeHeights_Cardinality (TTreeNode* node);		virtual void 								setNodeHeights_TopDown (TTreeNode* node);		virtual void 								setNodeHeights_BottomUp (TTreeNode* node);		virtual void								setLabelsInternals (TTreeNode* node);		virtual	char								sibChar (void) const { return ((IsFlag (kCMF)) ? ((char)225) : ((char)43)); };		virtual	void 								switchNodes (TTreeNode* n1, TTreeNode* n2) const;		virtual void 								traverseQuartets (const TTreeNode* node, unsigned long& quartets) const;		virtual void 								traverseTriplets (const TTreeNode* node, unsigned long& triplets) const;		virtual	char								teeChar (void) const { return ((IsFlag (kCMF)) ? ((char)224) : ((char)47)); }; // /						virtual void 								upDate (void) const { upDateTraverse (fRoot); };		virtual void 								upDateTraverse (TTreeNode* n) const;				virtual void								upDateLeafArray (void) const;		virtual void								upDateLeafArrayTraverse (TTreeNode* n) const;		virtual void								upDateInternalArray (void) const;		virtual void 								upDateInternalArrayTraverse (TTreeNode* n, unsigned int& count) const;		virtual	char								vbarChar (void) const { return ((IsFlag (kCMF)) ? ((char)221) : ((char)124)); }; // |						virtual	void								writeAsNewickTreeDescription (TTreeNode* n, const int fileWidth) const;		TTreeNode*									fRoot;		TreeType									fTreeType;		unsigned int								fInternals;		unsigned int								fLeaves;		unsigned int								fMaxLeafHeight;		TArray<TTreeNode*>							fLeafArray; 		TArray<TTreeNode*>							fInternalArray; 		TTreeName									fName;		double										fWeight;				TTreePlot									fTreePlot;		TTreeNode*									fCurNode; // maybe try and remove....		TTreeNodeStack								fNodeStack; // should be static but problems...				static int									fCharacterNumber;		static TTreeNode*							fAddThere;		static char*								fLine;		static ostream*								fOStream; // get rid off ??};#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#endif // __TTREE_H