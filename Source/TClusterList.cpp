#include "TClusterList.h"#include "TCalc.h"#include "TTabString.h"// orders clusters first by GetWeight () head > tail // then those with equal weight ordered conventional cluster ordering head < tailvoid TClusterList::AddCluster (TCluster* cluster){	CHECK_ (cluster->IsInformative (GetLeafSet ()));	CHECK_ (cluster->GetWeight ());		const TCluster* item = NULL;	for (FirstCluster (); CurCluster (item); NextCluster ())	{		if (item->GetWeight () < cluster->GetWeight ())		{			fDList.AddItemAtCur (cluster, false); // adds cluster before CurItem ()			return;		}		if (cluster->GetWeight () == item->GetWeight ())		{			if (*cluster < *item)			{				fDList.AddItemAtCur (cluster, false); // adds cluster before CurItem ()				return;			}		}	}	fDList.AddItem (cluster, true); // adds cluster at tail}void TClusterList::Copy (const TObject& obj) { 	CHECK_ (Class () == obj.Class ());	const TClusterList& clusterList = (const TClusterList&)obj;	fDList.Copy (clusterList.fDList);	fLeafSet.Copy (clusterList.fLeafSet);}bool TClusterList::CurCluster (const TCluster*& cluster) const{	const TObject* obj = NULL;	if (fDList.CurItem (obj))	{		cluster = (const TCluster*) obj;		return (true);	}	return (false);}void TClusterList::DetachCurCluster (TCluster*& cluster){	TObject* obj = NULL;	fDList.DetachCurItem (obj);	cluster = (TCluster*)obj;}bool TClusterList::FirstCluster (const TCluster*& cluster) const{	FirstCluster ();	return (CurCluster (cluster));}double TClusterList::getDifference (const TCluster& cluster) const{	CHECK_ (cluster.IsInformative (GetLeafSet ()));	const TCluster* item = NULL;	TClusterListIteratorConst& iteratorConst = IteratorConst ();	for (iteratorConst.FirstCluster (); iteratorConst.CurCluster (item); iteratorConst.NextCluster ())		if (!item->IsCompatible (cluster))			return (cluster.GetWeight () - item->GetWeight ());	return (cluster.GetWeight ());}bool TClusterList::IsEqual (const TObject& obj) const{	CHECK_ (Class () == obj.Class ());		const TClusterList& clusterList = (const TClusterList&)obj;	return (fLeafSet.IsEqual (clusterList.fLeafSet) && fDList.IsEqual (clusterList.fDList));}bool TClusterList::IsCompatible (const TCluster& cluster) const{	CHECK_ (cluster.IsInformative (GetLeafSet ()));	const TCluster* item = NULL;	TClusterListIteratorConst& iteratorConst = IteratorConst ();	for (iteratorConst.FirstCluster (); iteratorConst.CurCluster (item); iteratorConst.NextCluster ())		if (!item->IsCompatible (cluster))			return (false);				delete (&iteratorConst);	return (true);}bool TClusterList::LastCluster (const TCluster*& cluster) const{	LastCluster ();	return (CurCluster (cluster));}bool TClusterList::NextCluster (const TCluster*& cluster) const{	NextCluster ();	return (CurCluster (cluster));}TClusterList& TClusterList::operator = (const TClusterList& clusterList){	fDList = clusterList.fDList;	fLeafSet = clusterList.fLeafSet;	return (*this);}ostream& TClusterList::Write (ostream& o, const float limit, const bool writeWeights, const bool writeDifferences) const{		CHECK_ (0 <= limit && limit <= 1);		// use limit to not draw all components to log...	writeLeafNumbers (o, GetLeaves ()); // this could potentially be messed up ??	writeBorder (o, GetLeaves ());	const TCluster* cluster = NULL;	TTabString tabString (kFileWidth);	tabString.SetTab (5);	TString string;	unsigned int i;	for (i = 1, FirstCluster (); CurCluster (cluster) && limit <= cluster->GetWeight (); NextCluster (), ++i)	{		string.AddToThis ((int)i);		tabString.AddToThis (string);		o << tabString;		tabString.SetNull ();		string.SetNull ();		cluster->WriteAsStar (o, GetLeafSet (), false);		TString weight;		if (writeWeights)		{			weight.AddToThis (' ');			weight.AddToThis ((float)cluster->GetWeight (), 3);			weight.AddToThis (' ');		}		if (writeDifferences)		{				weight.AddToThis ('(');			weight.AddToThis (getDifference (*cluster), 3);			weight.AddToThis (')');		}		weight.Write (o);		o << EOLN;	}	writeBorder (o, GetLeaves ());	o << "(" << Clusters (limit) << ((Clusters (limit) == 1) ? " Component, " : " Components, ") << GetLeaves () << " Leaves)" << EOLN;	return (o);}// JLT 010418 added function to remove bug which gave too many clusters for the actual number in a cluster tableunsigned int TClusterList::Clusters (const float limit) const{	CHECK_ (0 <= limit && limit <= 1);		if (!limit)		return (Clusters ());			const TCluster* cluster = NULL;	unsigned int count = 0;	for (FirstCluster (); CurCluster (cluster) && limit <= cluster->GetWeight (); NextCluster ()) 		++count;		return (count);}ostream& TClusterList::writeLeafNumbers (ostream& o, const unsigned int leaves) const{	if (100 <= leaves)	{		o << "     ";		TString string;		for (unsigned int i = 1; i <= leaves; ++i)		{					if (GetUnits (i, 3) != -1)			{				string.AddToThis (GetUnits (i, 3));			}			else				string.AddToThis (' ');			if (!(i % 5))				string.AddToThis (' ');					}		o << string;		o << EOLN;	}	if (10 <= leaves)	{		o << "     ";		TString string;		for (unsigned int i = 1; i <= leaves; ++i)		{					if (GetUnits (i, 2) != -1)			{				string.AddToThis (GetUnits (i, 2));			}			else				string.AddToThis (' ');			if (!(i % 5))				string.AddToThis (' ');			}		o << string;		o << EOLN;	}	o << "     ";	TString string;	for (unsigned int i = 1; i <= leaves; ++i)	{				string.AddToThis (GetUnits (i, 1));		if (!(i % 5))			string.AddToThis (' ');				}	o << string;	return (o << EOLN);	}ostream& TClusterList::writeBorder (ostream& o, const unsigned int leaves) const{	o << "-----";	for (unsigned int i = 1; i <= leaves; ++i)	{		if (i % 5)      		o << "-";      	else      		o << "- ";	}	return (o << EOLN);}bool TClusterListIteratorConst::CurCluster (const TCluster*& cluster) const{	const TObject* obj;	if (fDListIteratorConst.CurItem (obj))	{		cluster = (const TCluster*)obj;		return (true);	}	return (false);}bool TClusterListIteratorConst::FirstCluster (const TCluster*& cluster){	const TObject* obj;	if (fDListIteratorConst.FirstItem (obj))	{		cluster = (const TCluster*)obj;		return (true);	}	return (false);}bool TClusterListIteratorConst::LastCluster (const TCluster*& cluster){	const TObject* obj;	if (fDListIteratorConst.LastItem (obj))	{		cluster = (const TCluster*)obj;		return (true);	}	return (false);}bool TClusterListIteratorConst::NextCluster (const TCluster*& cluster){	const TObject* obj;	if (fDListIteratorConst.NextItem (obj))	{		cluster = (const TCluster*)obj;		return (true);	}	return (false);}bool TClusterListIteratorConst::PrevCluster (const TCluster*& cluster){	const TObject* obj;	if (fDListIteratorConst.PrevItem (obj))	{		cluster = (const TCluster*)obj;		return (true);	}	return (false);}TClusterListIteratorConst::TClusterListIteratorConst (const TClusterList& clusterList)	: fClusterList (clusterList)	, fDListIteratorConst ((TDListIteratorConst&)clusterList.fDList.IteratorConst ()){	}TClusterListIteratorConst::~TClusterListIteratorConst (void) { 	delete (&fDListIteratorConst); }