#include "TQuartet.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TQuartetType::AddQuartetType (const QuartetType quartetType, const double weight){	switch (quartetType)	{		case kZero:			fWeights[0] += weight;			break;		case kOne:			fWeights[1] += weight;			break;		case kTwo:			fWeights[2] += weight;			break;		case kThree:			fWeights[3] += weight;			break;		default:			CHECK_ (0);			break;	}}void TQuartetType::AddQuartetType (const TQuartetType& quartetType){	fWeights[0] += quartetType.fWeights[0];	fWeights[1] += quartetType.fWeights[1];	fWeights[2] += quartetType.fWeights[2];		fWeights[3] += quartetType.fWeights[3];}void TQuartetType::Copy (const TObject& obj){	CHECK (Class () == obj.Class ());	const TQuartetType& quartetTypeWeighted = (const TQuartetType&) obj;	fWeights = quartetTypeWeighted.fWeights;}double TQuartetType::GetEntropy (double weight) const{	if (!weight)		weight = GetWeight (); 		double entropy = 0;		if (fWeights[0])	{		entropy += -(probType (kOne, weight) * log2 (probType (kOne, weight)));		entropy += -(probType (kTwo, weight) * log2 (probType (kTwo, weight)));		entropy += -(probType (kThree, weight) * log2 (probType (kThree, weight)));	}	else	{		if (fWeights[1])			entropy += -(probType (kOne, weight) * log2 (probType (kOne, weight)));		if (fWeights[2])			entropy += -(probType (kTwo, weight) * log2 (probType (kTwo, weight)));		if (fWeights[3])			entropy += -(probType (kThree, weight) * log2 (probType (kThree, weight)));	}	return (entropy);}QuartetType TQuartetType::GetQuartetType (void) const{		unsigned char i = 0;	QuartetType quartetType = kZero;	if (fWeights[0])		return (quartetType);			if (fWeights[1])	{		++i;		quartetType = kOne;	}	if (fWeights[2])	{		++i;		quartetType = kTwo;	}	if (fWeights[3])	{		++i;		quartetType = kThree;	}	if (i < 2)		return (quartetType);	return (kZero);}double TQuartetType::GetWeight (void) const{	double sum = fWeights[0];	sum += fWeights[1];	sum += fWeights[2];	sum += fWeights[3];	return (sum);//	return (fWeights[0] + fWeights[1] + fWeights[2] + fWeights[3]);}double TQuartetType::GetWeightType (const QuartetType quartetType) const{	switch (quartetType)	{		case kZero:			return (fWeights[0]);			break;				case kOne:			return (fWeights[1]);			break;				case kTwo:			return (fWeights[2]);			break;				case kThree:				return (fWeights[3]);			break;				default:			CHECK_ (0);			break;	}	return (0);}HashValue TQuartetType::Hash (void) const{	CHECK (0);	return (0);}bool TQuartetType::IsEqual (const TObject& obj) const{	CHECK (Class () == obj.Class ());	const TQuartetType& quartetType = (const TQuartetType&) obj;	CHECK (0);	return (0);}TQuartetType& TQuartetType::operator = (const TQuartetType& quartetType){	fWeights = quartetType.fWeights;	return (*this);}double TQuartetType::probType (QuartetType quartetType, double weight) const{	switch (quartetType)	{		case kOne:			return ((fWeights[1] + (fWeights[0] / (double)3)) / weight);			break;				case kTwo:			return ((fWeights[2] + (fWeights[0] / (double)3)) / weight);			break;					case kThree:			return ((fWeights[3] + (fWeights[0] / (double)3)) / weight);			break;				default:			CHECK (0);			break;	}	return (0);}void TQuartetType::SetQuartetType (const QuartetType quartetType, const double weight){	fWeights[0] = fWeights[1] = fWeights[2] = fWeights[3] = 0;	AddQuartetType (quartetType, weight);}void TQuartetType::SetQuartetType (const TQuartetType& quartetType){	fWeights = quartetType.fWeights;}void TQuartetType::SetWeightType (const QuartetType quartetType, const double weight){	CHECK_ (kMinWeight <= weight && weight <= kMaxWeight);	switch (quartetType)	{		case kZero:			fWeights[0] = weight;			break;		case kOne:			fWeights[1] = weight;			break;		case kTwo:			fWeights[2] = weight;			break;		case kThree:			fWeights[3] = weight;			break;		default:			CHECK_ (0);			break;	}}TQuartetType::TQuartetType (void)	: fWeights (4, 0){}TQuartetType::TQuartetType (const TQuartetType& weights)	: fWeights (weights.fWeights){}TQuartetType::TQuartetType (const QuartetType quartetType, const double weight)	:	fWeights (4, 0){	switch (quartetType)	{		case kZero:			fWeights[0] += weight;			break;		case kOne:			fWeights[1] += weight;			break;		case kTwo:			fWeights[2] += weight;			break;		case kThree:			fWeights[3] += weight;			break;		default:			CHECK_ (0);			break;	}}TQuartetType::~TQuartetType (void) { }int TQuartet::Compare (const TSortable& sortable) const{	CHECK (Class () == sortable.Class ());	const TQuartet& quartet = (const TQuartet&)sortable;	CHECK_ (IsRooted () == quartet.IsRooted ());		if (GetLeafD () != quartet.GetLeafD ())		return (GetLeafD () < quartet.GetLeafD () ? -1 : 1);	if (GetLeafC () != quartet.GetLeafC ())		return (GetLeafC () < quartet.GetLeafC () ? -1 : 1);	if (GetLeafB () != quartet.GetLeafB ())		return (GetLeafB () < quartet.GetLeafB () ? -1 : 1);	if (GetLeafA () != quartet.GetLeafA ())		return (GetLeafA () < quartet.GetLeafA () ? -1 : 1);	return (0);}void TQuartet::Copy (const TObject& obj){	CHECK (Class () == obj.Class ());	const TQuartet& quartet = (const TQuartet&) obj;	fLeaves = quartet.fLeaves;	fQuartetType.Copy (quartet.fQuartetType);}unsigned long TQuartet::GetQuartetNumber (void) const {	CHECK_ (IsRooted () ? GetLeafC () <= 1500 : GetLeafD () <= 500);		// maximum....	unsigned long quartetNumber = (GetLeafA () - 1);	if (GetLeafB () != 2)		quartetNumber += (unsigned long)((unsigned long)(GetLeafB () - 1) * (unsigned long)(GetLeafB () - 2) / (unsigned long)2);	if (GetLeafC () != 3)		quartetNumber += (unsigned long)(((unsigned long)(GetLeafC () - 1) * (unsigned long)(GetLeafC () - 2) * (unsigned long)(GetLeafC () - 3)) / (unsigned long)6);	if (IsRooted () || GetLeafD () == 4)		return (quartetNumber += 1);	return (quartetNumber += (unsigned long)((((unsigned long)(GetLeafD () - 1) * (unsigned long)(GetLeafD () - 2) * (unsigned long)(GetLeafD () - 3) * (unsigned long)(GetLeafD () - 4)) / (unsigned long)24) + (unsigned long)1));}/*// kZero = (A,B,C,D)  kOne = (((A,B),C),D))  kTwo =  (((A,C),B),D))  kThree =  (((B,C),A),D))// from Estabrook (1992) Syst. Biol. 41. 172-177QuartetType TQuartet::GetQuartetType (const unsigned int leaf1, const unsigned int leaf2) const{		CHECK (IsLeaf (leaf1) && IsLeaf (leaf2));	if (GetLeafA () == leaf1)	{		if (GetLeafB () == leaf2)			return (kOne);		if (GetLeafC () == leaf2)			return (kTwo);		return (kThree);		}	if (GetLeafB () == leaf1)	{		if (GetLeafC () == leaf2)			return (kThree);		return (kTwo);	}	return (kOne);}*/// provides a unique hash value for all quartets which corresponds to order as determined by Compare ()/*Quartet Position HashValue1234	 1		 01235	 2		 11245	 3		 21345	 4		 32345	 5		 4	1236	 6		 51246	 7		 61346	 8		 72346	 9		 81256	10		 91356	11		102356	12		111456	13		122456	14		133456	15		14*/HashValue TQuartet::Hashish (const unsigned short leafA, const unsigned short leafB, const unsigned short leafC, const unsigned short leafD)			{	CHECK_ ( (0 < leafA && leafA < leafB && leafB < leafC) && ( (leafD && leafC < leafD) || !leafD ));	HashValue h = (leafA - 1);	if (leafB != 2)		h += ((leafB - 2) * (leafB - 1) / 2);	if (leafC != 3)		h += (((leafC - 1) * (leafC - 2) * (leafC - 3)) / 6);	if (leafD != 0 && leafD != 4)		h += (((leafD - 1) * (leafD - 2) * (leafD - 3) * (leafD - 4)) / 24);	return (h);}bool TQuartet::IsLeaf_InsideSet (const unsigned short leaf, const QuartetType quartetType) const{	CHECK_ (leaf);	switch (quartetType)	{		case kOne:			return (leaf == GetLeafA () || leaf == GetLeafB ());			break;				case kTwo:			return (leaf == GetLeafA () || leaf == GetLeafC ());			break;				case kThree:			return (leaf == GetLeafB () || leaf == GetLeafC ());			break;				default:			CHECK_ (0);			break;	}	CHECK_ (0);	return (false);}bool TQuartet::IsLeaf_OutsideSet (const unsigned short leaf, const QuartetType quartetType) const{	CHECK_ (leaf);	switch (quartetType)	{		case kOne:			return (leaf == GetLeafC () || leaf == GetLeafD ());			break;				case kTwo:			return (leaf == GetLeafB () || leaf == GetLeafD ());			break;				case kThree:			return (leaf == GetLeafA () || leaf == GetLeafD ());			break;				default:			CHECK_ (0);			break;	}	CHECK_ (0);	return (false);}TLeafSet TQuartet::GetLeafSet (void) const{	TLeafSet leafSet;	leafSet += GetLeafA ();	leafSet += GetLeafB ();	leafSet += GetLeafC ();	if (GetLeafD ()) 		leafSet += GetLeafD ();	return (leafSet);}TLeafSet TQuartet::LeafSet_InsideSet (const QuartetType quartetType) const{	TLeafSet leafSet;	switch (quartetType)	{		case kOne:			leafSet += GetLeafA ();			leafSet += GetLeafB ();			break;				case kTwo:			leafSet += GetLeafA ();			leafSet += GetLeafC ();			break;				case kThree:			leafSet += GetLeafB ();			leafSet += GetLeafC ();			break;				default:			CHECK_ (0);			break;	}	return (leafSet);}TLeafSet TQuartet::LeafSet_OutsideSet (const QuartetType quartetType) const{	TLeafSet leafSet;	switch (quartetType)	{		case kOne:			leafSet += GetLeafC ();			if (GetLeafD ()) 				leafSet += GetLeafD ();			break;				case kTwo:			leafSet += GetLeafB ();			if (GetLeafD ()) 				leafSet += GetLeafD ();			break;				case kThree:			leafSet += GetLeafA ();			if (GetLeafD ()) 				leafSet += GetLeafD ();			break;				default:			CHECK_ (0);			break;	}	return (leafSet);}TQuartet& TQuartet::operator = (const TQuartet& quartet){	fLeaves = quartet.fLeaves;	fQuartetType = quartet.fQuartetType;	return (*this);	}bool TQuartet::SetLeavesFirstQuartet (const unsigned short leaf){	fLeaves[0] = 1;	fLeaves[1] = 2;	if (IsRooted ())	{		if (2 < leaf)			fLeaves[2] = leaf;		else			fLeaves[2] = 3;		fLeaves[3] = 0;	}	else	{		fLeaves[2] = 3;		if (3 < leaf)			fLeaves[3] = leaf;		else			fLeaves[3] = 4;	}	return (true);}bool TQuartet::SetLeavesFirstQuartet (const TLeafSet& leafSet, const unsigned short leaf) // need to do so can look up particular leaf....{	CHECK_ (3 < leafSet.GetLeaves () || (IsRooted () && leafSet.GetLeaves () == 3));	CHECK_ (!leaf || leafSet.IsLeaf (leaf));		SetLeavesFirstQuartet (leaf);	if (leafSet.IsLeaf (GetLeafA ()) && leafSet.IsLeaf (GetLeafB ()) && leafSet.IsLeaf (GetLeafC ()) && (IsRooted () || leafSet.IsLeaf (GetLeafD ()))) 		return (true);	return (SetLeavesNextQuartet (leafSet, leaf));}// goes through quartets in hash and rank order!!bool TQuartet::SetLeavesNextQuartet (const unsigned short leaves, const unsigned short leaf){	if (!leaf)	{		CHECK_ (!leaf || IsLeaf (leaf));		CHECK_ ((IsRooted () && GetLeafC () <= leaves) || (!IsRooted () && GetLeafD () <= leaves));		if (IsRooted ())		{			if (fLeaves[0] < fLeaves[1] - 1)				fLeaves[0] += 1;			else if (fLeaves[1] < fLeaves[2] - 1)			{				fLeaves[0] = 1;				fLeaves[1] += 1;			}			else if (fLeaves[2] < leaves)			{				fLeaves[0] = 1;				fLeaves[1] = 2;				fLeaves[2] += 1;			}			else				return (false);		}		else // !IsRooted ()		{			if (fLeaves[0] < fLeaves[1] - 1)				fLeaves[0] += 1;			else if (fLeaves[1] < fLeaves[2] - 1)			{				fLeaves[0] = 1;				fLeaves[1] += 1;			}			else if (fLeaves[2] < fLeaves[3] - 1)			{				fLeaves[0] = 1;				fLeaves[1] = 2;				fLeaves[2] += 1;			}			else if (fLeaves[3] < leaves)			{				fLeaves[0] = 1;				fLeaves[1] = 2;				fLeaves[2] = 3;				fLeaves[3] += 1;			}			else				return (false);		}		return (true);	}	// need more efficient algorithm	while (SetLeavesNextQuartet (leaves))		if (IsLeaf (leaf))			return (true);	return (false);}// goes through quartets in hash and rank order!!bool TQuartet::SetLeavesNextQuartet (const TLeafSet& leafSet, const unsigned short leaf) // need to do so can lokk up particular leaf...{	CHECK_ (3 < leafSet.GetLeaves () || (IsRooted () && leafSet.GetLeaves () == 3));	CHECK_ (!leaf || leafSet.IsLeaf (leaf));		unsigned short lastLeaf = leafSet.LastLeaf ();	while (SetLeavesNextQuartet (lastLeaf, leaf))		if (leafSet.IsLeaf (GetLeafA ()) && leafSet.IsLeaf (GetLeafB ()) && leafSet.IsLeaf (GetLeafC ()) && (IsRooted () || leafSet.IsLeaf (GetLeafD ()))) 				return (true);	return (false);}void TQuartet::SetLeavesQuartetNumber (const unsigned long quartetNumber){	CHECK_ (0);		/*	write if it is possible to determine the maximum value of x efficiently for any positive value of k where k <= x choose 4	*/}TQuartet::TQuartet (const unsigned short a, const unsigned short b, const unsigned short c, const unsigned short d)	:	fQuartetType ()	,	fLeaves (4){	CHECK_ ( (0 < a && a < b && b < c) && ( (d && c < d) || !d ));	fLeaves[0] = a;	fLeaves[1] = b;	fLeaves[2] = c;	fLeaves[3] = d;}TQuartet::TQuartet (const TQuartet& quartet)	: 	fQuartetType (quartet.fQuartetType)	,	fLeaves (quartet.fLeaves){}ostream& TQuartet::Write (ostream& o) const{	o << fLeaves[0] << ' ' << fLeaves[1] << ' ' << fLeaves[2];	if (fLeaves[3]) 		o << ' ' << fLeaves[3];	o << ' ';	fQuartetType.Write (o);	return (o);}ostream& TQuartet::WriteAsCharacter (ostream& o, const TLeafSet& leafSet) const{	QuartetType quartetType = GetQuartetType ().GetQuartetType ();	CHECK_ (quartetType != kZero);	for (unsigned short leaf = leafSet.FirstLeaf (); leaf; leaf = leafSet.NextLeaf ())		o << (IsLeaf (leaf) ? (IsLeaf_InsideSet (leaf, quartetType) ? "0" : "1") : "?");	return (o);}ostream& TQuartet::WriteAsNexus (ostream& o, unsigned int leaf) const{	CHECK_ (!leaf || !fLeaves[3]);	CHECK_ (!leaf || fLeaves[0] != leaf);	CHECK_ (!leaf || fLeaves[1] != leaf);	CHECK_ (!leaf || fLeaves[2] != leaf);		QuartetType quartetType = GetQuartetType ().GetQuartetType ();		switch (quartetType)	{		case kZero:			o << "(" << fLeaves[0] << "," << fLeaves[1] << "," << fLeaves[2];			if (leaf || fLeaves[3])				o << "," << (leaf ? leaf : fLeaves[3]);			o << ");";			break;		case kOne:			if (leaf || fLeaves[3])				o << "(";			o << "((" << fLeaves[0] << "," << fLeaves[1] << ")," << fLeaves[2] << ")";			if (leaf || fLeaves[3])				o << "," << (leaf ? leaf : fLeaves[3]) << ")";			o << ";";			break;		case kTwo:			if (leaf || fLeaves[3])				o << "(";			o << "((" << fLeaves[0] << "," << fLeaves[2] << ")," << fLeaves[1] << ")";			if (leaf || fLeaves[3])				o << "," << (leaf ? leaf : fLeaves[3]) << ")";			o << ";";			break;		case kThree:			if (leaf || fLeaves[3])				o << "(";			o << "((" << fLeaves[1] << "," << fLeaves[2] << ")," << fLeaves[0] << ")";			if (leaf || fLeaves[3])				o << "," << (leaf ? leaf : fLeaves[3]) << ")";			o << ";";			break;	}	return (o);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif