#include "TSplitSet.h"#include "TTabString.h"#include "TCalc.h"#include "TBTree.h"// JLT 000624#include "wstream.h"extern ostream *logStream;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifbool TSplitSet::AddSplit (TSplit* split, const bool nonRedundant){	CHECK_ (split);		CHECK_ (IsRooted () ? split->IsRooted () : !split->IsRooted ());		if (nonRedundant)	{		const TSplit* curSplit = NULL;// JLT 010412 made const		for (bool b = FirstSplit (curSplit); b; b = NextSplit (curSplit))		{			if (split->IsRedundant (*curSplit))			{				delete (split);				return (false);			}			if (curSplit->IsRedundant (*split))			{				DeleteCurSplit ();				while (CurSplit (curSplit))				{					if (curSplit->IsRedundant (*split))						DeleteCurSplit ();					else						NextSplit ();				}			}		}	}	fDList.AddItem (split);	if (IsFlag (kLeafSetsUpdated))	{		fIntersection *= split->GetLeafSet ();		fUnion += split->GetLeafSet ();	}	SetFlag (kSorted, false);	return (true);}void TSplitSet::Copy (const TObject& obj) { 	CHECK_ (Class () == obj.Class ());	const TSplitSet& splitSet = (const TSplitSet&)obj;	fDList.Copy (splitSet.fDList);	fIntersection.Copy (splitSet.fIntersection);	fUnion.Copy (splitSet.fUnion);	SetFlag (kRooted, splitSet.IsRooted ());	SetFlag (kLeafSetsUpdated, splitSet.IsFlag (kLeafSetsUpdated));	SetFlag (kSorted, splitSet.IsFlag (kSorted));}bool TSplitSet::CurSplit (const TSplit*& split) const{	const TObject* obj = NULL;	if (fDList.CurItem (obj))	{		split = (const TSplit*) obj;		return (true);	}	return (false);}void TSplitSet::DeleteAll (void) { 	fDList.DeleteAll (); 	SetFlag (kLeafSetsUpdated, false);}void TSplitSet::DeleteCurSplit (void) { 	fDList.DeleteCurItem (); 	SetFlag (kLeafSetsUpdated, false);}void TSplitSet::DetachCurSplit (TSplit*& split){	TObject* obj = NULL;	fDList.DetachCurItem (obj);	split = (TSplit*)obj;		SetFlag (kLeafSetsUpdated, false);}bool TSplitSet::FindSplit (const TSplit& toFind, const TSplit*& split) const{	CHECK_ (IsRooted () ? toFind.IsRooted () : !toFind.IsRooted ());		for (bool b = FirstSplit (split); b ; b = NextSplit (split))		if (toFind == *split)			return (true);	split = NULL;	return (false);}bool TSplitSet::FirstSplit (const TSplit*& split) const{	FirstSplit ();	return (CurSplit (split));}const TLeafSet& TSplitSet::GetLeafSet (const bool intersection) const{	if (!IsFlag (kLeafSetsUpdated))		upDateLeafSets ();	return (intersection ? fIntersection : fUnion);}bool TSplitSet::IsCompatible (const TSplit& split) const{	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());		const TSplit* curSplit; 	for (bool b = FirstSplit (curSplit); b; b = NextSplit (curSplit))		if (!curSplit->IsCompatible (split))			return (false);	return (true);}bool TSplitSet::IsEqual (const TObject& obj) const{	CHECK_ (Class () == obj.Class ());		const TSplitSet& splitSet = (const TSplitSet&)obj;	CHECK_ (IsRooted () ? splitSet.IsRooted () : !splitSet.IsRooted ());		if (GetSplits () == splitSet.GetSplits () && GetLeafSet (false) == splitSet.GetLeafSet (false) && GetLeafSet (true) == splitSet.GetLeafSet (true))	{		Sort ();		splitSet.Sort ();		return (fDList.IsEqual (splitSet.fDList));	}	return (false);}bool TSplitSet::IsSplitRedundant (const TSplit& split) const{	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());		const TSplit* curSplit = NULL; 	for (bool b = FirstSplit (curSplit); b; b = NextSplit (curSplit))		if (split.IsRedundant (*curSplit))			return (true);	return (false);}bool TSplitSet::LastSplit (const TSplit*& split) const{	LastSplit ();	return (CurSplit (split));}bool TSplitSet::NextSplit (const TSplit*& split) const{	NextSplit ();	return (CurSplit (split));}TSplitSet& TSplitSet::operator = (const TSplitSet& splitSet){	fDList = splitSet.fDList;	fIntersection = splitSet.fIntersection;	fUnion = splitSet.fUnion;	SetFlag (kRooted, splitSet.IsRooted ());	SetFlag (kLeafSetsUpdated, splitSet.IsFlag (kLeafSetsUpdated));	SetFlag (kSorted, splitSet.IsFlag (kSorted));		return (*this);}void TSplitSet::PruneLeaves (const TLeafSet& leafSet, const bool nonRedundant){	CHECK_ (!leafSet.IsEmpty ());		if (!(GetLeafSet () * leafSet).IsEmpty ())	{		TSplitSet splitSet = *this;		DeleteAll ();		const TSplit* split; // JLT 010412 made const		splitSet.FirstSplit (split);		while (splitSet.CurSplit ())		{			TSplit* splitDetach; // JLT 010412 added			splitSet.DetachCurSplit (splitDetach);			splitDetach->PruneLeaves (leafSet);			AddSplit (splitDetach, nonRedundant);		}	}}void TSplitSet::Sort (void) const{	TBTree bTree;	TSplit* split;	FirstSplit ();	while (!IsEmpty ())	{		((TSplitSet*)this)->DetachCurSplit (split);		bTree.AddItem (split);	}	TObject* obj;	// speed up use detachitem but not sure about correctness!!!	for (bool b = bTree.FirstItem (obj); b; b = bTree.NextItem (obj))		((TSplitSet*)this)->AddSplit (*((TSplit*)obj), false);}TSplitSet::TSplitSet (const bool rooted)	: 	fDList ()	,	fIntersection ()	,	fUnion (){	SetFlag (kRooted, rooted);	SetFlag (kLeafSetsUpdated, false);	SetFlag (kSorted, false);}TSplitSet::TSplitSet (const TSplitSet& splitSet)	:	fDList (splitSet.fDList)	,	fIntersection (splitSet.fIntersection)	,	fUnion (splitSet.fUnion){	SetFlag (kRooted, splitSet.IsRooted ());	SetFlag (kLeafSetsUpdated, splitSet.IsFlag (kLeafSetsUpdated));	SetFlag (kSorted, splitSet.IsFlag (kSorted));}void TSplitSet::upDateLeafSets (void) const{	if (!IsEmpty ())	{		TSplitSetIteratorConst&	iterator = IteratorConst ();		const TSplit* split;		iterator.FirstSplit (split);		((TSplitSet*)this)->fUnion = split->GetLeafSet ();		((TSplitSet*)this)->fIntersection = split->GetLeafSet ();		for (bool b = iterator.FirstSplit (split); b; b = iterator.NextSplit (split))		{			((TSplitSet*)this)->fIntersection *= split->GetLeafSet ();			((TSplitSet*)this)->fUnion += split->GetLeafSet ();		}		delete (&iterator);	}	else		{		((TSplitSet*)this)->fIntersection.SetEmpty ();		((TSplitSet*)this)->fUnion.SetEmpty ();	}}ostream& TSplitSet::WriteAsNewick (ostream &o) const{	Sort ();		const TSplit* split;	for (bool b = FirstSplit (split); b; b = NextSplit (split))	{		split->WriteAsNewick (o);		o << EOLN;	}	return (o);}ostream& TSplitSet::WriteAsTable (ostream &o, const float limit, const bool weight) const{//	CHECK_ (0 <= limit && limit <= 1); JLT 010206 commented out//	Sort (); JLT 010311 commented out as like to look inside and see as is		const unsigned int leaves = GetLeafSet (false).LastLeaf ();	const TLeafSet leafSet (leaves);	writeLeafNumbers (o, leaves);	writeBorder (o, leaves);	const TSplit* split;	TTabString tabString (kFileWidth);	tabString.SetTab (5);	TString string;	unsigned int i;	bool b;	TSplitSetIteratorConst& iteratorConst = IteratorConst (); // JLT 010208 now uses iterator instead of in built iterator (useful for debugging)	for (i = 1, b = iteratorConst.FirstSplit (split); b && limit <= split->GetWeight () ; b = iteratorConst.NextSplit (split), ++i)	{		string.AddToThis ((int)i);		tabString.AddToThis (string);		o << tabString;		tabString.SetNull ();		string.SetNull ();		split->WriteAsStar (o, leafSet, weight);		o << EOLN;	}	delete (&iteratorConst); 	writeBorder (o, leaves);	o << "(" << GetSplits () << ' ' << (GetSplits () == 1?  "Split, " :  "Splits, ") << GetLeaves () << " Leaves)" << EOLN;	return (o);}ostream& TSplitSet::WriteAsTable (ostream &o, const TLeafSet& leafSet, const float limit, const bool weight) const{//	CHECK_ (0 <= limit && limit <= 1); JLT 010206 commented out	CHECK_ (!leafSet.IsEmpty ());	//	Sort (); JLT 010311 commented out as like to look inside and see as is		const unsigned int leaves = leafSet.GetLeaves ();	writeLeafNumbers (o, leaves);	writeBorder (o, leaves);	const TSplit* split;	TTabString tabString (kFileWidth);	tabString.SetTab (5);	TString string;	unsigned int i;	bool b;	TSplitSetIteratorConst& iteratorConst = IteratorConst (); // JLT 010208 now uses iterator instead of in built iterator (useful for debugging)	for (i = 1, b = iteratorConst.FirstSplit (split); b && limit <= split->GetWeight () ; b = iteratorConst.NextSplit (split), ++i)	{		string.AddToThis ((int)i);		tabString.AddToThis (string);		o << tabString;		tabString.SetNull ();		string.SetNull ();		split->WriteAsStar (o, leafSet, weight);		o << EOLN;	}	delete (&iteratorConst); 	writeBorder (o, leaves);	o << "(" << GetSplits () << ' ' << (GetSplits () == 1?  "Split, " :  "Splits, ") << leafSet.GetLeaves () << " Leaves)" << EOLN;	return (o);}ostream& TSplitSet::writeLeafNumbers (ostream& o, const unsigned int leaves) const{	if (100 <= leaves)	{		o << "     ";		TString string;		for (unsigned int i = 1; i <= leaves; ++i)		{					if (GetUnits (i, 3) != -1)			{				string.AddToThis (GetUnits (i, 3));			}			else				string.AddToThis (' ');			if (!(i % 5))				string.AddToThis (' ');					}		o << string;		o << EOLN;	}	if (10 <= leaves)	{		o << "     ";		TString string;		for (unsigned int i = 1; i <= leaves; ++i)		{					if (GetUnits (i, 2) != -1)			{				string.AddToThis (GetUnits (i, 2));			}			else				string.AddToThis (' ');			if (!(i % 5))				string.AddToThis (' ');			}		o << string;		o << EOLN;	}	o << "     ";	TString string;	for (unsigned int i = 1; i <= leaves; ++i)	{				string.AddToThis (GetUnits (i, 1));		if (!(i % 5))			string.AddToThis (' ');				}	o << string;	return (o << EOLN);	}ostream& TSplitSet::writeBorder (ostream& o, const unsigned int leaves) const{	o << "-----";	for (unsigned int i = 1; i <= leaves; ++i)	{		if (i % 5)      		o << "-";      	else      		o << "- ";	}	return (o << EOLN);}void TSplitSet::WriteToLogAsTable (const TLeafSet& leafSet, const float limit, const bool weight) const{	#ifdef VCLASS 		WriteAsTable (*logStream, leafSet, limit, weight);		logStream->flush();	#else		Write (cout);	#endif}void TSplitSet::WriteToLogAsTable (const float limit, const bool weight) const{// JLT 000624	#ifdef VCLASS 		WriteAsTable (*logStream, limit, weight);		logStream->flush();	#else		Write (cout);	#endif}TSplitSet::~TSplitSet (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifbool TSplitSetIteratorConst::CurSplit (const TSplit*& split) const{	const TObject* obj;	if (fDListIteratorConst.CurItem (obj))	{		split = (const TSplit*)obj;		return (true);	}	return (false);}bool TSplitSetIteratorConst::FirstSplit (const TSplit*& split){	const TObject* obj;	if (fDListIteratorConst.FirstItem (obj))	{		split = (const TSplit*)obj;		return (true);	}	return (false);}bool TSplitSetIteratorConst::LastSplit (const TSplit*& split){	const TObject* obj;	if (fDListIteratorConst.LastItem (obj))	{		split = (const TSplit*)obj;		return (true);	}	return (false);}bool TSplitSetIteratorConst::NextSplit (const TSplit*& split){	const TObject* obj;	if (fDListIteratorConst.NextItem (obj))	{		split = (const TSplit*)obj;		return (true);	}	return (false);}bool TSplitSetIteratorConst::PrevSplit (const TSplit*& split){	const TObject* obj;	if (fDListIteratorConst.PrevItem (obj))	{		split = (const TSplit*)obj;		return (true);	}	return (false);}// JLT 010207 think this works ?? 010311 just modified it - hopefully works nowTSplitSetIteratorConst::TSplitSetIteratorConst (const TSplitSetIteratorConst& splitSetIteratorConst)	: fSplitSet (splitSetIteratorConst.fSplitSet)	, fDListIteratorConst (splitSetIteratorConst.fDListIteratorConst){	}// JLT 010311 modified as well - i am not totally sure what's going on here!TSplitSetIteratorConst::TSplitSetIteratorConst (const TSplitSet& splitSet)	: fSplitSet (splitSet)	, fDListIteratorConst (splitSet.fDList){	}TSplitSetIteratorConst::~TSplitSetIteratorConst (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif