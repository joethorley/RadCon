#include "TAncestorFunction.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifunsigned int TAncestorFunction::getAncestor (const unsigned int node) const{	CHECK_ (fArray);		if (node <= kMaxLeaves) 	{		if (fLeafSet.IsLeaf (node)) 		{			unsigned int number = 1;			for (fLeafSet.FirstLeaf (); fLeafSet.CurLeaf (); fLeafSet.NextLeaf (), ++number)				if (fLeafSet.CurLeaf () == node)					return (fArray->IthItemRef (number));		}	}	else if ((node - kMaxLeaves) <= GetInternalNodes ())		return (fArray->IthItemRef (GetLeaves () + (node - kMaxLeaves)));	return (0);}void TAncestorFunction::Copy (const TObject& obj){	const TAncestorFunction& anf = (const TAncestorFunction&)obj;		fTreeType = anf.fTreeType;	fName.Copy (anf.fName); 	fLeafSet.Copy (anf.fLeafSet);		SetFlag (kBinaryRoot, anf.IsBinaryRoot ());		if (fWeightsInternals)		delete (fWeightsInternals);		fWeightsInternals = (anf.fWeightsInternals ? new TArray<double> (*anf.fWeightsInternals): NULL);	if (fArray)		delete (fArray);		fArray = (anf.fArray ? new TArray<unsigned int> (*anf.fArray): NULL);	fWeight = anf.fWeight;}bool TAncestorFunction::IsEqual (const TObject& obj) const {	CHECK_ (Class () == obj.Class ());	const TAncestorFunction& ancestorFunction = (const TAncestorFunction&)obj;		CHECK_ (fTreeType == ancestorFunction.fTreeType);		if (fLeafSet == ancestorFunction.fLeafSet)		return (*fArray == *ancestorFunction.fArray);	return (false);}TAncestorFunction& TAncestorFunction::operator = (const TAncestorFunction& anf){	fTreeType = anf.fTreeType;	fName = anf.fName;	fLeafSet = anf.fLeafSet;		fWeight = anf.fWeight;		SetFlag (kBinaryRoot, anf.IsBinaryRoot ());	if (fWeightsInternals)		delete (fWeightsInternals);		fWeightsInternals = (anf.fWeightsInternals ? new TArray<double> (*anf.fWeightsInternals): NULL);	if (fArray)		delete (fArray);		fArray = (anf.fArray ? new TArray<unsigned int> (*anf.fArray): NULL);	return (*this);}void TAncestorFunction::setArray (const unsigned int nodes){	if (fArray)		delete (fArray);			fArray = new TArray<unsigned int> (nodes);	fArray->IthItemRef (nodes) = codingRootsAncestor ();	fCount = 0;}void TAncestorFunction::setWeightsInternals (const bool set){	if (fWeightsInternals)		delete (fWeightsInternals);			fWeightsInternals = (set ? new TArray<double> (GetInternalNodes ()) : NULL);	fCount = 0;}TAncestorFunction::TAncestorFunction (const TAncestorFunction& anf){	fTreeType = anf.fTreeType;	fName = anf.fName;	fLeafSet = anf.fLeafSet;		fWeight = anf.fWeight;		SetFlag (kBinaryRoot, anf.IsBinaryRoot ());		fWeightsInternals = (anf.fWeightsInternals ? new TArray<double> (*anf.fWeightsInternals): NULL);	fArray = (anf.fArray ? new TArray<unsigned int> (*anf.fArray): NULL);}TAncestorFunction::TAncestorFunction (void){	fWeight = 0;	fTreeType = kStrictCladistic;		fArray = NULL;	fWeightsInternals = NULL;		SetFlag (kBinaryRoot, false);}TAncestorFunction::~TAncestorFunction (void) { 	if (fWeightsInternals)		delete (fWeightsInternals);		if (fArray)		delete (fArray);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif