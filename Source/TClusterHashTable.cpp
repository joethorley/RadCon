#include "TClusterHashTable.h"void TClusterHashTable::AddCluster (const TCluster& cluster){	CHECK_ (cluster.IsInformative (GetLeafSet ()));	CHECK_ (cluster.GetWeight ());		TCluster* clusterPtr = NULL;	if (fHashTable.FindItem ((const TObject&)cluster, (TObject*&)clusterPtr))		clusterPtr->AddWeight (cluster.GetWeight ());	else		fHashTable.AddItem (cluster);}void TClusterHashTable::AddCluster (TCluster* cluster){	CHECK_ (cluster->IsInformative (GetLeafSet ()));	CHECK_ (cluster->GetWeight ());		TCluster* clusterPtr = NULL;	if (fHashTable.FindItem ((const TObject&)*cluster, (TObject*&)clusterPtr))	{		clusterPtr->AddWeight (cluster->GetWeight ());		delete (cluster);		cluster = NULL;	}	else		fHashTable.AddItem (cluster);}bool TClusterHashTable::CurCluster (TCluster*& cluster){	TObject* obj = NULL;	if (fHashTable.CurItem (obj))	{		cluster = (TCluster*) obj;		return (true);	}	return (false);}bool TClusterHashTable::CurCluster (const TCluster*& cluster) const{	const TObject* obj = NULL;	if (fHashTable.CurItem (obj))	{		cluster = (const TCluster*) obj;		return (true);	}	return (false);}void TClusterHashTable::DetachCurCluster (TCluster*& cluster){	TObject* obj = NULL;	fHashTable.DetachCurItem (obj);	cluster = (TCluster*)obj;}bool TClusterHashTable::FirstCluster (TCluster*& cluster){	TObject* obj = NULL;	if (fHashTable.FirstItem (obj))	{		cluster = (TCluster*) obj;		return (true);	}	return (false);}bool TClusterHashTable::FirstCluster (const TCluster*& cluster) const{	const TObject* obj = NULL;	if (fHashTable.FirstItem (obj))	{		cluster = (const TCluster*) obj;		return (true);	}	return (false);}bool TClusterHashTable::IsCompatible (const TCluster& cluster) const{	CHECK_ (cluster.IsInformative (GetLeafSet ()));		const TCluster* item = NULL;	TClusterHashTableIteratorConst& iteratorConst = IteratorConst ();	for (iteratorConst.FirstCluster (); iteratorConst.CurCluster (item); iteratorConst.NextCluster ())	{		if (!item->IsCompatible (cluster))		{			delete (&iteratorConst);			return (false);		}	}	delete (&iteratorConst);	return (true);}bool TClusterHashTable::NextCluster (TCluster*& cluster){	TObject* obj = NULL;	if (fHashTable.NextItem (obj))	{		cluster = (TCluster*) obj;		return (true);	}	return (false);}bool TClusterHashTable::NextCluster (const TCluster*& cluster) const{	const TObject* obj = NULL;	if (fHashTable.NextItem (obj))	{		cluster = (const TCluster*) obj;		return (true);	}	return (false);}ostream& TClusterHashTable::WriteAsStar (ostream &o, const bool writeWeight) const{	const TCluster* cluster = NULL;	for (FirstCluster (); CurCluster (cluster); NextCluster ())	{		cluster->WriteAsStar (o, fLeafSet, writeWeight);		o << EOLN;	}	return (o);}TClusterHashTableIteratorConst::TClusterHashTableIteratorConst (const TClusterHashTable& clusterHashTable)	: fClusterHashTable (clusterHashTable)	, fHashTableIterator ((THashTableIteratorConst&)clusterHashTable.fHashTable.IteratorConst ()){}TClusterHashTableIteratorConst::TClusterHashTableIteratorConst (const TClusterHashTableIteratorConst& clusterHashTableIteratorConst)	: fClusterHashTable (clusterHashTableIteratorConst.fClusterHashTable)	, fHashTableIterator (clusterHashTableIteratorConst.fHashTableIterator){}	    TClusterHashTableIteratorConst::~TClusterHashTableIteratorConst (void){	delete (&fHashTableIterator);}bool TClusterHashTableIteratorConst::CurCluster (const TCluster*& cluster) const{	const TObject* obj = NULL; // JLT 010412 made const	if (fHashTableIterator.CurItem (obj))	{		cluster = (TCluster*) obj;		return (true);	}	return (false);}bool TClusterHashTableIteratorConst::FirstCluster (const TCluster*& cluster){	const TObject* obj = NULL; // JLT 010412 made const	if (fHashTableIterator.FirstItem (obj))	{		cluster = (TCluster*) obj;		return (true);	}	return (false);}		bool TClusterHashTableIteratorConst::NextCluster (const TCluster*& cluster){	const TObject* obj = NULL; // JLT 010412 made const	if (fHashTableIterator.NextItem (obj))	{		cluster = (TCluster*) obj;		return (true);	}	return (false);}