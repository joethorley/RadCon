#include "TTreePlot.h"#include <algorithm.h>#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifTTreeStyle& TTreeStyle::operator = (const TTreeStyle& treeStyle){	fNodeHeights = treeStyle.fNodeHeights;	SetRectangular (treeStyle.IsRectangular ());	SetDrawName (treeStyle.IsDrawName ());	return (*this);}TTreeStyle::TTreeStyle (void)	:	fNodeHeights (kCardinality){	SetRectangular ();	SetDrawName ();}TTreeStyle::TTreeStyle (const TTreeStyle& treeStyle)	:	fNodeHeights (treeStyle.fNodeHeights){	SetRectangular (treeStyle.IsRectangular ());	SetDrawName (treeStyle.IsDrawName ());}TTreeStyle::~TTreeStyle (void){}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TTreePlot::DrawLabel (const TPoint point, const TString& label, const bool isLeaf) const{	CHECK_ (fLeaves);	CHECK_ (fLabelFont);		if (isLeaf)		Port.SelectAFont (fLabelFont);	else		Port.SelectAFont (fEdgeFont);	TRect labelRect;		Coordinate h = Port.FontHeight() / 2;	labelRect.SetRect (point.GetX (), point.GetY () - h, point.GetX () + Port.TextWidth ((char*)label.Array (), label.Length ()) + 2, point.GetY () + h ); // JLT 010412 ADDED CAST	CHECK_ (!isLeaf || labelRect.GetWidth () <= fMaxLeafName + 2);	labelRect.Offset (Port.MaxCharWidth() / 2, 0);	VRect vrect = labelRect.GetVRect ();	Port.DrawText (vrect, (char*)label.Array (), label.Length(), 'l', FALSE); // JLT 010412 added cast}void TTreePlot::DrawLine (const TPoint pointA, const TPoint pointB) const { 	CHECK_ (fLeaves); 	CHECK_ (IsPointInRect (pointA) && IsPointInRect (pointB)); 	Port.DrawLine (pointA.GetPoinT (), pointB.GetPoinT ()); }Coordinate TTreePlot::GetCurLeafY (void) const{	CHECK_ (fCount < fLeaves);	((TTreePlot*)this)->fLastLeafY = ((Coordinate)((float)GetTop() + ((float)(((TTreePlot*)this)->fCount++) * fLeafGap)));	CHECK_ (GetTop () <= fLastLeafY && fLastLeafY <= GetBottom ());	return (fLastLeafY);}TTreePlot& TTreePlot::operator = (const TTreePlot& treePlot){	TRect::operator = (treePlot);	fCount = treePlot.fCount;	fLeaves = treePlot.fLeaves;	fLastLeafY = treePlot.fLastLeafY;	fNodeGap = treePlot.fNodeGap;	fLeafGap = treePlot.fLeafGap;	fLabelFont = treePlot.fLabelFont;	fEdgeFont = treePlot.fEdgeFont;	fMaxLeafName = treePlot.fMaxLeafName;	fTreeStyle = treePlot.fTreeStyle;	return (*this);}void TTreePlot::SetLeafHeight (const unsigned int height) const{	CHECK_ (fLabelFont);	CHECK_ (fLeaves);	CHECK_ (IsRooted () ? height : height - 1);	// what happens of leaves have zero height ??	((TTreePlot*)this)->fLeafHeight = height;	((TTreePlot*)this)->SetRight (GetRight () - fMaxLeafName);		((TTreePlot*)this)->fLeafGap = ((float)(GetBottom () - GetTop ()) / (float)(fLeaves - 1));	((TTreePlot*)this)->fNodeGap = ((float)(GetRight () - GetLeft ()) / (float)(IsRooted () ? fLeafHeight + 1 : fLeafHeight));}void TTreePlot::SetLeafName (const TString& leafName) const{	CHECK_ (fLabelFont);	CHECK_ (!fLeafHeight);			((TTreePlot*)this)->fMaxLeafName = max (fMaxLeafName, Port.TextWidth ((char*)leafName.Array (), leafName.Length ()));	// JLT 010412 added cast	CHECK_ (fMaxLeafName < GetWidth ());	((TTreePlot*)this)->fLeaves++;}void TTreePlot::SetTreeName (const string& treeName) const{	CHECK_ (!fLeaves);		CHECK_ (treeName.length ());	if (fTreeStyle.IsDrawName ())	{		((TTreePlot*)this)->SetTop (GetTop() + (Port.FontHeight() * 2));		Port.SelectAFont (fEdgeFont);		TRect rect (GetLeft (), (float)GetTop () - (2 * Port.FontHeight ()), GetRight (), GetTop () - (Coordinate)Port.FontHeight ());		VRect vrect = rect.GetVRect ();		Port.DrawString (vrect, (char*)treeName.c_str (), 'l', FALSE);	// JLT 010412 added cast	}}void TTreePlot::SetUp (VRect rect, VFontPtr labelFont, const TTreeStyle& treeStyle, VFontPtr edgeFont) const{	CHECK_ (labelFont);	((TTreePlot*)this)->SetRect (rect);	((TTreePlot*)this)->fTreeStyle = treeStyle;	((TTreePlot*)this)->fLabelFont = labelFont;		((TTreePlot*)this)->fEdgeFont = (edgeFont ? edgeFont : labelFont);	Port.SelectAFont (fEdgeFont);	((TTreePlot*)this)->Inset (0, Port.FontHeight() / 2);	((TTreePlot*)this)->fCount = 0;	((TTreePlot*)this)->fLeaves = 0;	((TTreePlot*)this)->fLeafHeight = 0;	((TTreePlot*)this)->fMaxLeafName = 0;}		TTreePlot::TTreePlot (void)	:	fLabelFont (NULL){}TTreePlot::TTreePlot (const TTreePlot& treePlot)	:	TRect (treePlot)	,	fCount (treePlot.fCount)	,	fLeaves (treePlot.fLeaves)	,	fLeafHeight (treePlot.fLeafHeight)	,	fMaxLeafName (treePlot.fMaxLeafName)	,	fLastLeafY (treePlot.fLastLeafY)	,	fNodeGap (treePlot.fNodeGap)	,	fLeafGap (treePlot.fLeafGap)	,	fLabelFont (treePlot.fLabelFont)	,	fEdgeFont (treePlot.fEdgeFont)	,	fTreeStyle (treePlot.fTreeStyle){}TTreePlot::~TTreePlot (void){}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif