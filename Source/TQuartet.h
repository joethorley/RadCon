#ifndef __TQUARTET_H#define __TQUARTET_H#include "TFlags.h"#include "TObject.h"#include "TClassTypes.h"#include "TSortable.h"#include "TArray.h"#include "TLeafSet.h"#include "TStandardTemplates.h"#include "TCladistic.h"enum QuartetType { 	kZero 			= 0x0001, // kZero = (A,B,C,D)	kOne			= 0x0002, // kOne = (((A,B),C),D))	kTwo    		= 0x0004, // kTwo =  (((A,C),B),D))	kThree			= 0x0008  // kThree =  (((B,C),A),D))};#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TQuartetType ___#endifclass TQuartetType : public TObject{	public:		TQuartetType (void);		TQuartetType (const QuartetType quartetType, const double weight = kDefaultWeight);		TQuartetType (const TQuartetType& quartetType);		~TQuartetType (void);		virtual void							AddQuartetType (const QuartetType quartetType, const double weight = kDefaultWeight);		virtual void							AddQuartetType (const TQuartetType& quartetType);		virtual ClassType						Class (void) const { return (kTQuartetTypeClass); };		virtual TObject*						Clone (void) const { return (new TQuartetType (*this)); };		virtual void							Copy (const TObject& obj);		virtual double							GetDifference (void) const { return ((double)((double)Max (fWeights[1], fWeights[2], fWeights[3]) - (double)Median (fWeights[1], fWeights[2], fWeights[3])) / (double)GetWeight ()); };		virtual double							GetEntropy (const double weight = 0) const;		virtual double							GetInformation (double weight = 0) const { return ((maxE () - GetEntropy (weight)) / maxE ()); };		virtual double							GetMaximum (void) const { 	return ((double)Max (fWeights[1], fWeights[2], fWeights[3]) / (double)GetWeight ()); };		virtual QuartetType 					GetQuartetType (void) const;						virtual double							GetWeight (void) const;		virtual double							GetWeightType (const QuartetType quartetType) const;    	virtual HashValue						Hash (void) const;				virtual bool							IsResolved (void) const { return (GetQuartetType () != kZero); };		    	virtual bool 							IsEqual (const TObject& obj) const;		virtual TQuartetType&					operator = (const TQuartetType& quartetType);		virtual void							SetQuartetType (const QuartetType quartetType, const double weight = kDefaultWeight);		virtual void							SetQuartetType (const TQuartetType& quartetType);		virtual void							SetWeightType (const QuartetType quartetType, const double weight = kDefaultWeight);		virtual ostream&						Write (ostream& o) const { return (o << fWeights[0] << ' ' << fWeights[1] << ' ' << fWeights[2] << ' ' << fWeights[3]); };			protected:		static double							maxE (void) { return (-log2 ((double)((double)1 / (double)3))); }; // maybe hard wire this value in......		virtual double 							probType (QuartetType quartetType, double weight) const;				TArray<double>							fWeights;};class TQuartet : public TSortable{	public:		TQuartet (const unsigned short a = 1, const unsigned short b = 2, const unsigned short c = 3, const unsigned short d = 0);		TQuartet (const TQuartet& quartet);		virtual ~TQuartet (void) { };		virtual void							AddQuartetType (const QuartetType quartetType, const double weight = kDefaultWeight) { fQuartetType.AddQuartetType (quartetType, weight); };		virtual void							AddQuartetType (const TQuartetType& quartetType) { fQuartetType.AddQuartetType (quartetType); };		virtual ClassType						Class (void) const { return (kTQuartetClass); };		virtual TObject*						Clone (void) const { return (new TQuartet (*this)); };		virtual int								Compare (const TSortable& sortable) const;		virtual void							Copy (const TObject& obj);		virtual double							GetDifference (void) const { return (fQuartetType.GetDifference ()); };		virtual double							GetInformation (const double weight = 0) const { return (fQuartetType.GetInformation (weight)); };		virtual double							GetMaximum (void) const { return (fQuartetType.GetMaximum ()); };		virtual unsigned short					GetLeafA (void) const { return (fLeaves[0]); };		virtual unsigned short					GetLeafB (void) const { return (fLeaves[1]); };		virtual unsigned short					GetLeafC (void) const { return (fLeaves[2]); };		virtual unsigned short					GetLeafD (void) const { return (fLeaves[3]); };		virtual unsigned short					A (void) const { return (GetLeafA ()); };		virtual unsigned short					B (void) const { return (GetLeafB ()); };		virtual unsigned short					C (void) const { return (GetLeafC ()); };		virtual unsigned short					D (void) const { return (GetLeafD ()); };		virtual unsigned long 				GetQuartetNumber (void) const;//		virtual QuartetType 					GetQuartetType (const unsigned short leaf1, const unsigned short leaf2) const;		virtual const TQuartetType&				GetQuartetType (void) const { return (fQuartetType); }		virtual HashValue						Hash (void) const { return (Hashish (GetLeafA (), GetLeafB (), GetLeafC (), GetLeafD ())); };		static HashValue						Hashish (const unsigned short leafA, const unsigned short leafB, const unsigned short leafC, const unsigned short leafD = 0);									virtual bool							IsEqual (const TObject& obj) const { CHECK (Class () == obj.Class ()); return ((bool)(GetLeafA () == ((const TQuartet&)obj).GetLeafA () && GetLeafB () == ((const TQuartet&)obj).GetLeafB () && GetLeafC () == ((const TQuartet&)obj).GetLeafC () && GetLeafD () == ((const TQuartet&)obj).GetLeafD ())); };				virtual bool							IsLeaf (const unsigned short leaf) const { CHECK (leaf); return (GetLeafA () == leaf || GetLeafB () == leaf || GetLeafC () == leaf || (!IsRooted () && GetLeafD () == leaf)); };		virtual bool							IsLeaf_InsideSet (const unsigned short leaf, const QuartetType quartetType) const;		virtual bool							IsLeaf_OutsideSet (const unsigned short leaf, const QuartetType quartetType) const;		virtual bool							IsResolved (void) const { return (fQuartetType.IsResolved ()); };		virtual bool							IsRooted (void) const { return ((bool)(!GetLeafD ())); };		virtual unsigned short					GetLeaves (void) const { return (IsRooted () ? 3 : 4); };		virtual TLeafSet						GetLeafSet (void) const;		virtual TLeafSet						LeafSet_InsideSet (const QuartetType quartetType) const;		virtual TLeafSet						LeafSet_OutsideSet (const QuartetType quartetType) const;		virtual TQuartet&						operator = (const TQuartet& quartet);		virtual void							SetLeaves (const TQuartet& quartet) { CHECK_ (IsRooted () ? quartet.IsRooted () : !quartet.IsRooted ()); fLeaves = quartet.fLeaves; };		virtual bool 							SetLeavesFirstQuartet (const unsigned short leaf = 0);		virtual bool 							SetLeavesFirstQuartet (const TLeafSet& leafSet, const unsigned short leaf = 0);		virtual bool							SetLeavesNextQuartet (const unsigned short leaves = kMaxLeaves, const unsigned short leaf = 0);		virtual bool 							SetLeavesNextQuartet (const TLeafSet& leafSet, const unsigned short leaf = 0); // need to do so can lokk up particular leaf...		virtual void							SetLeavesQuartetNumber (const unsigned long quartetNumber);		virtual void							SetQuartetType (const QuartetType quartetType, const double weight = kDefaultWeight) { fQuartetType.SetQuartetType (quartetType, weight); };		virtual void							SetQuartetType (const TQuartetType& quartetType) { fQuartetType.SetQuartetType (quartetType); };		virtual void							UnRoot (void) { CHECK_ (IsRooted () && GetLeafC () < kMaxLeaves); fLeaves[3] = GetLeafC () + 1; };		virtual ostream&						Write (ostream& o) const;		virtual ostream&						WriteAsNexus (ostream& o, const unsigned int leaf = 0) const;		virtual ostream&						WriteAsCharacter (ostream& o, const TLeafSet& leafSet) const;	protected:		TArray<unsigned short>					fLeaves;		TQuartetType							fQuartetType;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#endif // __TQUARTET_H