#include "TQuartetSet.h"void TQuartetSet::Copy (const TObject& obj){	CHECK_ (0);	CHECK_ (Class () == obj.Class ());		const TQuartetSet& quartetSet = (const TQuartetSet&)obj;	fLeafSet = quartetSet.fLeafSet;	SetFlag (TQUARTETSET_FLAG_ROOTED, quartetSet.IsRooted ());	}bool TQuartetSet::FirstPartition (void){	CHECK_ (!CurPartition ());	fPartition = new TQuartetPartition (fStartPartition, fPartitionSize, GetLeaves ());	fCurPartition = 1;	return (true);}unsigned long TQuartetSet::GetQuartets (const bool leaf) const{	CHECK_ (GetLeaves () <= (IsRooted () ? 1500: 500));		if (!leaf)	{ 		if (IsRooted ())			return (((unsigned long)((unsigned long)GetLeaves () * (unsigned long)(GetLeaves () - 1) * (unsigned long)(GetLeaves () - 2)) / (unsigned long)6));		return (((unsigned long)((unsigned long)GetLeaves () * (unsigned long)(GetLeaves () - 1) * (unsigned long)(GetLeaves () - 2) * (unsigned long)(GetLeaves () - 3)) / (unsigned long)24));	}	if (IsRooted ())		return (((unsigned long)((unsigned long)(GetLeaves () - 1) * (unsigned long)(GetLeaves () - 2)) / (unsigned long)2));	return (((unsigned long)((unsigned long)(GetLeaves () - 1) * (unsigned long)(GetLeaves () - 2) * (unsigned long)(GetLeaves () - 3)) / (unsigned long)6));}HashValue TQuartetSet::Hash (void) const { 	CHECK_ (0); 	return (0); }				bool TQuartetSet::IsEqual (const TObject& obj) const { 	CHECK_ (0); 	const TQuartetSet& quartetSet = (const TQuartetSet&)obj;	if (fLeafSet.GetLeaves () != quartetSet.GetLeaves ())		return (false);	return (false); }bool TQuartetSet::NextPartition (void){	if (CurPartition () && fCurPartition++ < fPartitions)	{		CHECK_ (fPartition);		fStartPartition = fPartition->IthQuartetRef (fPartition->GetQuartets ());		fStartPartition.SetLeavesNextQuartet (GetLeaves ()); 		delete (fPartition);		fPartition = new TQuartetPartition (fStartPartition, (fCurPartition < fPartitions ? fPartitionSize : fLastPartitionSize), GetLeaves ());		return (true);	}	CHECK_ (CurPartition ());	delete (fPartition);	fPartition = NULL;	fCurPartition = 0;	return (false);}TQuartetSet& TQuartetSet::operator = (const TQuartetSet& quartetSet){	CHECK_ (0);	fLeafSet = quartetSet.fLeafSet;	SetFlag (TQUARTETSET_FLAG_ROOTED, quartetSet.IsRooted ());		return (*this);}ostream& TQuartetSet::Write (ostream& o) const {	if (CurPartition ())		fPartition->Write (o); 	return (o);}TQuartetSet::TQuartetSet (const unsigned short leaves, const bool rooted)	: fLeafSet (leaves){	SetFlag (TQUARTETSET_FLAG_ROOTED, rooted);	// the maximum value of unsigned long ULONG_MAX = 4294967295U	// hence the limits of unrooted 500 * 499 * 498 * 497 / 24 = 2573031125U (2.5 * 10^6) and	// 1500 * 1499 * 1498 / 6 = 561375500U (0.5 * 10^6)	CHECK_ (GetLeaves () >= (IsRooted () ? 3 : 4));	CHECK_ (GetLeaves () <= (IsRooted () ? 1500: 500));	if (!IsRooted ())		fStartPartition.UnRoot ();	const unsigned long quartets = GetQuartets ();		fPartitionSize = ((quartets < (unsigned long)65535U) ? (unsigned short)quartets : (unsigned short)65535U);	fCurPartition = 0;	fPartition = NULL;			// the maximum number of partitions is 65535U and the maximum size of each partition is 65535U	// therefore the maximum number of quartets that can be stored is 65535U^2 = 4294836225	// which is slightly less than ULONG_MAX = 4294967295U	// the limits of unrooted 500 * 499 * 498 * 497 / 24 = 2573031125U (2.5 * 10^6) and	// 1500 * 1499 * 1498 / 6 = 561375500U are still sufficient (0.5 * 10^6)	fPartitions = (unsigned long)quartets / (unsigned long)fPartitionSize;	// is this rounding up or down ?? assume rounded down.....		fLastPartitionSize = (quartets - (unsigned long)((unsigned long)fPartitions * (unsigned long)fPartitionSize));	if (fLastPartitionSize)		++fPartitions;	else		fLastPartitionSize = fPartitionSize;}TQuartetSet::TQuartetSet (const TQuartetSet& quartetSet)	: fLeafSet (quartetSet.fLeafSet){	CHECK_ (0);}TQuartetSet::~TQuartetSet (void) { 	if (fPartition)		delete (fPartition);}