#include "TTreeNode.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TTreeNode::CalcCoordinates (const TTreePlot& treePlot) const{	if (IsLeaf ())		((TTreeNode*)this)->fPoint.SetPoint (treePlot.GetRight (), treePlot.GetCurLeafY ());	else	{		((TTreeNode*)this)->fPoint.SetX ((float)treePlot.GetLeft () + treePlot.GetNodeGap () * (float)(treePlot.IsRooted () ? GetHeight () + 1 : GetHeight ()));		if (!treePlot.GetTreeStyle ().IsRectangular ())			((TTreeNode*)this)->fPoint.SetY ((float)treePlot.GetLastLeafY () - (treePlot.GetLeafGap () * (float)(GetLeaves () - 1)) / 2);		else			((TTreeNode*)this)->fPoint.SetY ((float)fChild->fPoint.GetY () + (float)(fChild->GetRightMostSibling ()->fPoint.GetY () - fChild->fPoint.GetY ()) / 2);	}	CHECK_ (treePlot.IsPointInRect (fPoint));}void TTreeNode::Draw (const TTreePlot& treePlot) const{	if (!treePlot.GetTreeStyle ().IsRectangular ())	{		if (!IsRoot ())			treePlot.DrawLine (fPoint, fAnc->fPoint);		else if (treePlot.IsRooted ())		{			TPoint point (treePlot.GetLeft (), fPoint.GetY ());			treePlot.DrawLine (point, fPoint);				}	}	else	{		TPoint point1;		if (!IsRoot ())		{			point1.SetPoint (fAnc->fPoint.GetX (), fPoint.GetY ());			treePlot.DrawLine (fPoint, point1);		}		else if (treePlot.IsRooted ())		{			TPoint point (treePlot.GetLeft (), fPoint.GetY ());			treePlot.DrawLine (point, fPoint);				}		if (!IsLeaf())		{			point1.SetPoint (fPoint.GetX (), fChild->fPoint.GetY ());			TPoint point2 (fPoint.GetX (), fChild->GetRightMostSibling ()->fPoint.GetY ());			treePlot.DrawLine (point1, point2);		}	}	if (HasLabel () && !IsRoot ())		treePlot.DrawLabel (fPoint, GetLabel (), IsLeaf ());}// returns a pointer to the node immediately to the left of thisTTreeNode* TTreeNode::GetLeftSibling (void) {	CHECK_ (fAnc);	TTreeNode* n = fAnc->fChild;	while (n && n->fSib != this)		n = n->fSib;	return (n);}// returns a pointer to the node immediately to the left of thisconst TTreeNode* TTreeNode::GetLeftSibling (void) const{	CHECK_ (fAnc);	const TTreeNode* n = fAnc->fChild;	while (n && n->fSib != this)		n = n->fSib;	return (n);}TTreeNode& TTreeNode::operator = (const TTreeNode& treeNode){	TCluster::operator = (treeNode);	return (*this);}TTreeNode* TTreeNode::GetRightMostSibling (void) {	TTreeNode *p = this;	while (p->fSib) 		p = p->fSib;	return (p);}const TTreeNode* TTreeNode::GetRightMostSibling (void) const{	const TTreeNode *p = this;	while (p->fSib) 		p = p->fSib;	return (p);}TTreeNode::TTreeNode (const double weight)	: TCluster (weight){	fAnc 	  		= NULL;	fChild  		= NULL;	fSib 	  		= NULL;		fNumber			= 0;				fDegree			= 0;				fHeight			= 0;}TTreeNode::TTreeNode (const TLeafSet& leafSet, const double weight)	: TCluster (leafSet, weight){	fAnc 	  		= NULL;	fChild  		= NULL;	fSib 	  		= NULL;		fNumber			= 0;				fDegree			= 0;				fHeight			= 0;}TTreeNode::~TTreeNode (void) { }#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif