#ifndef __TSPLIT_H#define __TSPLIT_H#include "TChecks.h"#include "TFlags.h"#include "TSortable.h"#include "TLeafSet.h"#include "TString.h"#include "TQuartet.h"#include "TCladistic.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TSplit ___#endifclass TSplit : public TCladistic{	public:				TSplit (const bool rooted = true, const double weight = kDefaultWeight);		TSplit (const TLeafSet& insideSet, const TLeafSet& leafSet, bool rooted = true, double weight = kDefaultWeight);		TSplit (const TSplit& split);				virtual ~TSplit (void);				virtual ClassType						Class (void) const { return (kTSplitClass); };		virtual TObject*						Clone (void) const { return (new TSplit (*this)); };		virtual void							Copy (const TObject& obj);		virtual int								Compare (const TSortable& sortable) const;		virtual void 							EmptySplit (void);		virtual void							Flip (void) const;				virtual unsigned int					GetNumber (void) const { return (fNumber); };		virtual double							GetWeight (void) const { return (fWeight); };				virtual HashValue						Hash (void) const { return (fLeafSet.Hash () + fPartitionA.Hash () + fPartitionB.Hash ()); };		virtual void 							Intersection (const TSplit& split, TSplit& intersection) const;				virtual bool							IsCompatible (const TSplit& split) const;		virtual bool							IsDisplays (const TQuartet& quartet) const;				virtual bool							IsEqual (const TObject& obj) const;		virtual bool							IsInformative (void) const;		virtual bool 							IsRedundant (const TSplit& split) const;		virtual bool							GetFusionProducts (const TSplit& fuse2, TSplit& prod1, TSplit& prod2) const;		virtual const TLeafSet&					GetLeafSet (void) const { return (fLeafSet); };		virtual unsigned int					GetLeaves (void) const { return (GetLeafSet ().GetLeaves ()); }; 		virtual const TLeafSet&					GetLeafSet (const bool inside) const { return (inside ? *fInsideSet : *fOutsideSet); };		virtual unsigned int					GetLeaves (const bool inside) const { return (GetLeafSet (inside).GetLeaves ()); }; 				virtual TSplit& 						operator = (const TSplit& split);				virtual void							PruneLeaf (const unsigned int leaf);		virtual void							PruneLeaves (const TLeafSet& leafSet);		virtual void 							SetEmpty (void) { EmptySplit (); };		virtual void							SetNumber (const unsigned int number) const { ((TSplit*)this)->fNumber = number; };		virtual void							SetWeight (const double weight = kDefaultWeight) { CHECK_ (kMinWeight <= weight && weight <= kMaxWeight); fWeight = weight; };				virtual ostream&						Write (ostream& o) const { return (WriteAsNewick(o)); };		virtual ostream&						WriteAsNewick (ostream& o, const bool weight = false) const;	 	virtual ostream&						WriteAsStar (ostream& o, const TLeafSet leafSet, const bool weight = false) const;	 	virtual ostream&						WriteAsCharacter (ostream& o, const TLeafSet leafSet) const;	protected:		TLeafSet*								fInsideSet;		TLeafSet*								fOutsideSet;				TLeafSet								fPartitionA;		TLeafSet								fPartitionB;		TLeafSet								fLeafSet;				unsigned int							fNumber;				double									fWeight;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#endif // __TSPLIT_H