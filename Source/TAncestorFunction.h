#ifndef __ANCESTORFUNCTION_H#define __ANCESTORFUNCTION_H#include "TClassTypes.h"#include "TNexusName.h"#include "TArray.h"#include "TVArray.h"#include "TCladistic.h"#include "TString.h"#include <iostream.h>// codes (1,2),3 as 1:501 2:501 3:502 4:502 5: codingRootsAncestor ()#if PRAGMA_MARK_SUPPORTED#pragma mark -#pragma mark ___ class TAncestorFunction ___#endifclass TTree;class TAncestorFunction: public TCladistic{	friend class TTree;	public:		enum		{			kBinaryRoot = 0x0010		};						TAncestorFunction (void);		TAncestorFunction (const TAncestorFunction& anf);		virtual ~TAncestorFunction (void);						virtual ClassType							Class (void) const { return (kTAncestorFunctionClass); };				virtual TObject*							Clone (void) const { return (new TAncestorFunction (*this)); };		virtual int									Compare (const TSortable& sortable) const { CHECK_ (0); return (0); };		virtual void								Copy (const TObject& obj);		virtual TreeType							GetTreeType (void) const { return (fTreeType); };				virtual HashValue							Hash (void) const { CHECK_ (0); return (0); };		virtual unsigned int						GetInternalNodes (const bool rooted = true) const { return (fArray ? fArray->Size () - GetLeaves () - (!rooted && IsBinaryRoot () ? 1 : 0) : 0); };		virtual unsigned int						GetInternalBranches (const bool rooted = true) const { CHECK_ (GetInternalNodes (rooted)); return (GetInternalNodes (rooted) - 1); };				virtual bool								IsBinary (const bool rooted = true) const { return (GetInternalBranches (rooted) == (GetLeaves () - 2 - (!rooted ? 1 : 0))); };		virtual bool								IsBinaryRoot (void) const { return (IsFlag (kBinaryRoot)); };		virtual bool								IsEqual (const TObject& obj) const;		virtual bool								IsRooted (void) const { return (true); }; // stored as rooted...				virtual const TLeafSet&						GetLeafSet (void) const { return (fLeafSet); };		virtual const TTreeName&					GetName (void) const { return (fName); };		virtual const double&					GetWeight (void) const { return (fWeight); };		virtual double							GetWeightIthInternal (const unsigned int i) const { return (fWeightsInternals ? fWeightsInternals->IthItemRef (i) : fWeight);  }		TAncestorFunction&							operator = (const TAncestorFunction& anf);				virtual void								SetName (const TString& name) { fName = name; };		virtual void								SetTreeType (const TreeType treeType) { fTreeType = treeType; };		virtual void								SetWeight (const double weight = kDefaultWeight) { CHECK_ (kMinWeight <= weight && weight <= kMaxWeight); fWeight = weight; };								virtual ostream&							Write (ostream &o) const { 	return (o << fName << " = " << "[&W " << fWeight << "] " << *fArray); };	protected:				virtual unsigned int 							getAncestor (const unsigned int node) const;		static unsigned int							codingRootsAncestor (void) { return (kMaxNodes + 1); };		virtual bool								isWeightsInternals (void) const { return (fWeightsInternals); };		virtual void								setLeafSet (const TLeafSet& leafSet) { fLeafSet = leafSet; };		virtual void								setTreeType (const TreeType& treeType) { fTreeType = treeType; };		virtual void								setArray (const unsigned int nodes);		virtual void								setNextAncestor (const unsigned int anc) { CHECK_ (fArray); CHECK_ (fCount < fArray->Size () - 1); fArray->IthItemRef (++fCount) = anc; };		virtual void								setWeightsInternals (const bool set = true);		virtual void 								setWeightNextInternal (const double weight) { CHECK_ (fWeightsInternals); CHECK_ (fCount < fWeightsInternals->Size ()); fWeightsInternals->IthItemRef (++fCount) = weight; };		virtual void								setBinaryRoot (const bool binaryRoot = true) { SetFlag (kBinaryRoot, binaryRoot); };		TArray<unsigned int>*							fArray;		TArray<double>*						fWeightsInternals;				unsigned int									fCount;				TLeafSet									fLeafSet;		TTreeName									fName;		double									fWeight;		TreeType									fTreeType;};#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif#endif // __TANCESTORFUNCTION_H	