#include "TTree.h"#include "CMinLimits.h"#include "TCladistic.h"#include "TCalc.h"#include <locale.h> // JLT 010412// JLT 000624#include "wstream.h"extern ostream *logStream;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif// new way always have degrees and leafsets updated in external trees....// but not with numbering of internal nodes just guarantee that consecutive..// are all of these static bullshits needed ...no just first twoostream* TTree::fOStream					;char* TTree::fLine 							;TTreeNode* TTree::fAddThere 				= NULL; //used in setOutGroup and listOtherDescendants that is called by setOutGroup..this can be got rid of//TTreeNodeStack TTree::fNodeStack			;int TTree::fCharacterNumber;  //again just used WriteAsNewick and WriteTraverse...can be replaced...void TTree::AddToThis (const TCluster& cluster, const TString label){	CHECK_ (cluster.IsSubset (GetLeafSet ()));	CHECK_ (1 < cluster.GetLeaves () && cluster != GetLeafSet ());	CHECK_ (cluster.GetWeight ());	TTreeNode* p = fRoot;	TTreeNode* q = p->GetChild ();	bool finished = false;		// locate insertion point	while (q && !finished)	{		switch (cluster.Relationship (*q))		{			case disjoint:				p = q;				q = q->GetSibling ();				break;			case subset:				p = q;				q = q->GetChild ();				break;			case superset:				finished = true;				break;						case identity://				CHECK_ (q->GetWeight () == cluster.GetWeight ());				return;							default:				CHECK_ (0);				break;		}	}	TTreeNode* nunode = newNode ();	++fInternals;	nunode->AddToThis (cluster);	nunode->SetWeight (cluster.GetWeight ());	nunode->SetLabel (label);	switch (cluster.Relationship (*q))	{		case disjoint:			p->SetSibling (nunode);			nunode->SetAnc (p->GetAnc ());			break;		case subset:			p->SetChild (nunode);			nunode->SetAnc (p);			break;		case superset:			if (q == p->GetChild ())			{				p->SetChild (nunode);				nunode->SetChild (q);				nunode->SetAnc (p);				q->SetAnc (nunode);			}			else			{				p->SetSibling (nunode);				nunode->SetChild (q);				nunode->SetAnc (p->GetAnc ());				q->SetAnc (nunode);			}			TTreeNode* r = q;			TTreeNode* s = q->GetSibling ();			TTreeNode* t = q->GetAnc ();			while (s) // wtf is this about ??			{				if (s->IsSubset (*nunode))				{					s->SetAnc (q->GetAnc());					r = s;					s = s->GetSibling ();				}				else				{					t->SetSibling (s);					r->SetSibling (s->GetSibling ());					t = s;					t->SetSibling (NULL);					s = r->GetSibling ();				}			}			break;		default:			CHECK_ (0);			break;	}	upDate (); // is this needed here ?? what is going on ??}void TTree::AddToThis (const TLeafSet& leafSet, const double weight){	TCluster cluster (leafSet, weight);	AddToThis (cluster);}void TTree::AddToThis (const TSplit& split){	CHECK_ (split.IsInformative () && split.GetWeight ());	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());	CHECK_ (split.GetLeafSet () == GetLeafSet ());		if (IsRooted ())		AddToThis (split.GetLeafSet (true), split.GetWeight ());	else	{		if (!split.GetLeafSet (true).IsLeaf (getOutGroup ()))			AddToThis (split.GetLeafSet (true), split.GetWeight ());		else			AddToThis (split.GetLeafSet (false), split.GetWeight ());	}}void TTree::AddToThis (const TTree& tree){	CHECK_ (IsRooted () ? tree.IsRooted () : !tree.IsRooted ());	CHECK_ (IsRooted () || isOutGroup (tree.getOutGroup ()));		addToThisTraverse (tree.GetRoot ());}void TTree::addToThisTraverse (const TTreeNode* node){	if (node)	{		if (!node->IsLeaf () && !node->IsRoot ())			AddToThis ((const TLeafSet)*node, (const double)node->GetWeight ()); // JLT 010412 added casts		addToThisTraverse (node->GetChild ());		addToThisTraverse (node->GetSibling ());	}}void TTree::AncestorFunction (TAncestorFunction& anf) const{	upDateInternalArray (); // if want to compare then must rearrange	anf.SetName (GetName ());	anf.SetWeight (GetWeight ());	anf.setTreeType (GetTreeType ());		anf.setLeafSet (GetLeafSet ());	anf.setBinaryRoot (IsBinaryRoot ());		anf.setArray (Nodes ());		for (unsigned int leaf  = FirstLeaf (); leaf; leaf = NextLeaf ())		anf.setNextAncestor (getLeaf (leaf)->GetAnc ()->GetNumber ()); 	 	for (unsigned int i = kMaxLeaves + 1; i < kMaxLeaves + InternalNodes (); ++i) 		anf.setNextAncestor (getIthInternal (i)->GetAnc ()->GetNumber ()); 		if (IsWeightsInternals ())	{		anf.setWeightsInternals (true); 		for (unsigned int i = 1; i <= InternalNodes (); ++i) 			anf.setWeightNextInternal (getIthInternal (i)->GetWeight ()); 	} 	else		anf.setWeightsInternals (false);}void TTree::calcCoordinates (TTreeNode* node) const{	if (node)	{		calcCoordinates (node->GetChild ());		node->CalcCoordinates (fTreePlot);		calcCoordinates (node->GetSibling ());	}}void TTree::collapseBinaryRoot (TTreeNode*& nodePtr) const{	CHECK_ (IsBinaryRoot () && 2 < GetLeaves ());	CHECK_ (fRoot->GetChild () && fRoot->GetChild ()->GetSibling () && !fRoot->GetChild ()->GetSibling ()->GetSibling ());		TTreeNode* newRoot = fRoot->GetChild ()->GetSibling ();	TTreeNode* nodeToMove;		if (!newRoot->IsLeaf ())	{			nodeToMove = fRoot->GetChild ();		nodeToMove->SetSibling (newRoot->GetChild ());		newRoot->SetChild (nodeToMove);	}	else	{		nodeToMove = newRoot;		newRoot = fRoot->GetChild ();		CHECK_ (!newRoot->IsLeaf ());		newRoot->GetChild ()->GetRightMostSibling ()->SetSibling (nodeToMove);		newRoot->SetSibling (NULL);				}	nodeToMove->SetAnc (newRoot);	newRoot->AddToThis (*nodeToMove);	newRoot->SetAnc (NULL);	nodePtr = fRoot;	fRoot->Disconnect ();	((TTree*)this)->fInternals -= 1; 	((TTree*)this)->fRoot = newRoot;}void TTree::Copy (const TObject& obj) { 	CHECK (Class () == obj.Class ());	const TTree& tree = (const TTree&)obj;		SetFlag (kRooted, tree.IsRooted ());		TAncestorFunction anf;	tree.AncestorFunction (anf);	FromAncestorFunction (anf);}void TTree::deleteTraverse (TTreeNode* n){	if (n)	{		deleteTraverse (n->GetChild ());		deleteTraverse (n->GetSibling ());		deleteNode (n);	}}void TTree::DeleteTree (void){		deleteTree ();			fLeafArray.Fill (NULL); 	fRoot = newNode ();	fInternals = 1;	fLeaves = 0;	fMaxLeafHeight = 0;}void TTree::deleteTree (void){	if (IsFlag (kBranchAndBound))	{	    unsigned int i;	    TTreeNode* n;	    for (i = 1; i <= kMaxLeaves; ++i)	    {		    	n = getLeaf (i);	    	if (n && !n->IsLeaf ())	    	{	    		deleteNode (n->GetChild ());	    		deleteNode (n);	    	}		}		SetFlag (kBranchAndBound, false);	}	deleteTraverse (fRoot);}unsigned int TTree::Distance (const unsigned int leafA, const unsigned int leafB) const{	CHECK (IsLeaf (leafA) && IsLeaf (leafB) && leafA < leafB);		TTreeNode* n = getLeaf (leafA)->GetAnc ();		while (!n->IsLeaf (leafB))		n = n->GetAnc ();		return (n->GetLeaves () - 1);}void TTree::DistanceMatrix (TDistanceMatrix& matrix){		matrix.SetLeafSet (GetLeafSet ());	if (GetLeafSet ().IsSequential ())	{		for (unsigned int leafA = 1; leafA < GetLeaves (); ++leafA)			for (unsigned int leafB = leafA + 1; leafB <= GetLeaves (); ++leafB)				matrix.SetDistance (leafA, leafB, Distance (leafA, leafB));	}	else	{		// make quicker...by going through leafsets...not IthLeaves...		for (unsigned int leafA = 1; leafA < GetLeaves (); ++leafA)			for (unsigned int leafB = leafA + 1; leafB <= GetLeaves (); ++leafB)				matrix.SetDistance (IthLeaf (leafA), IthLeaf (leafB), Distance (IthLeaf (leafA), IthLeaf (leafB)));	}}void TTree::Draw (VRect rect, VFontPtr labelFont, const TTreeStyle& treeStyle, VFontPtr edgeFont) const{	CHECK_ (labelFont);	fTreePlot.SetUp (rect, labelFont, treeStyle, edgeFont);	fTreePlot.SetRooted (IsRooted ());	string s = fName.Array ();	fTreePlot.SetTreeName (s);			for (unsigned int leaf = GetLeafSet ().FirstLeaf (); leaf; leaf = GetLeafSet ().NextLeaf ())	{		TString leafName = getLeaf (leaf)->GetLabel ();		fTreePlot.SetLeafName (leafName);			}	// control the heights of nodes in the tree here	((TTree*)this)->SetNodeHeights (fTreePlot.GetTreeStyle ().GetNodeHeights ()); // JLT 010310 tunred on//	((TTree*)this)->SetNodeHeights (TTreeStyle::kCardinality);	fTreePlot.SetLeafHeight (GetMaxLeafHeight ());	calcCoordinates (fRoot);	drawTraverse (fRoot);}/*void TTree::Draw (const TTreePlot& treePlot) const{	((TTree*)this)->SetHeights ();		if (treePlot.IsDrawName () && !fName.IsNull ())		treePlot.DrawTreeName (fName);			for (unsigned int leaf = GetLeafSet ().FirstLeaf (); leaf; leaf = GetLeafSet ().NextLeaf ())	{		TString leafName = getLeaf (leaf)->GetLabel ();		treePlot.SetLeafName (leafName);			}	treePlot.SetRooted (IsRooted ());	treePlot.SetLeaves (GetLeaves ());	calcCoordinates (fRoot, treePlot);	drawTraverse (fRoot, treePlot);}*/void TTree::drawTraverse (TTreeNode* node) const{	if (node)	{		drawTraverse (node->GetChild ());		node->Draw (fTreePlot);		drawTraverse (node->GetSibling ());	}}void TTree::drawAsTextFillInAncestors (const TTreeNode* n) const{	const TTreeNode* q = n->GetAnc();	const TTreeNode* r = n;	while (q != fRoot)	{		if ((!(q->IsRightMost ()) && !(r->IsLeftMost ())) || (!(q->IsLeftMost ()) && r->IsLeftMost ()))		{			if (r == n && q->GetHeight () == q->GetAnc ()->GetHeight ())				fLine[(int)(q->GetAnc ()->GetHeight ())] = sibChar ();			else				fLine[(int)(q->GetAnc ()->GetHeight ())] = vbarChar ();						}		r = q;		q = q->GetAnc ();	}}void TTree::drawAsTextTraverse (ostream& o, const TTreeNode* n) const{	if (n)	{		drawAsTextTraverse (o, n->GetChild ());		if (n->IsLeaf ())			drawAsTextPendantEdge (o, n);		if (!n->IsRightMost ())			drawAsTextInteriorEdge (o, n);		drawAsTextTraverse (o, n->GetSibling ());	}}void TTree::drawAsTextInteriorEdge (ostream& o, const TTreeNode* n) const{	const TTreeNode* r = n->GetAnc ();	int stop = r->GetHeight();	if (n->IsLeftMost())	{		// Visiting ancestor for the first time, so draw the		// end symbol		if (r == fRoot)		{			if (IsRooted ())				fLine[stop] = rootChar (); 			else				fLine[stop] = vbarChar ();  // ³		}		else		{			fLine[stop] = teeChar ();      // ´		}		// Draw branch itself		if (r != fRoot)		{			// Line			int start = r->GetAnc()->GetHeight();						for (int i = start + 1; i < stop; i++)			{				fLine[i] = hbarChar (); // Ä			}			// Start symbol			if (start == stop)				fLine[start] = vbarChar ();     // ³			else if (r->IsLeftMost())				fLine[start] = leftmostChar ();     // Ú			else if (r->IsRightMost())				fLine[start] = rightmostChar ();      // Ã			else fLine[start] = sibChar ();  // À			//			drawAsTextFillInAncestors (r);		}	}	else	{		// Just draw nodes below		fLine[stop] = vbarChar ();		drawAsTextFillInAncestors (n->GetSibling());	}	// Output the line	fLine[stop + 1] = '\0';	o << fLine;	if (r->HasLabel () && !r->IsRoot () && n->IsLeftMost ())		o  << r->GetLabel ();	 o  << EOLN;	// Clear the line for the next pass	int j = kMaxLeaves + kMaxLeafLabelLength;	for (int i = 0; i < j; i++)		fLine[i] = ' ';}void TTree::SetLabelsInternals (void){	setLabelsInternals (fRoot);}void TTree::setLabelsInternals (TTreeNode* node){	if (node)	{		if (!node->IsLeaf ())		{			setLabelsInternals (node->GetChild ());			TString label;						switch (GetTreeType ())			{				case kMajorityRuleCladistic:					label.AddToThis ((float)((node->GetWeight () / GetWeight ()) * (float)100), 0);					node->SetLabel (label);					break;								case kDecayIndex:					label.AddToThis ((float)node->GetWeight (), 0);					node->SetLabel (label);					break;								default:					break;			}		}		setLabelsInternals (node->GetSibling ());	}}void TTree::drawAsTextPendantEdge (ostream& o, const TTreeNode* n) const{	int stop = n->GetHeight ();	int start = n->GetAnc ()->GetHeight ();	// Draw line between n and its ancestor	int i;	for (i = start + 1; i <= stop; i++)		fLine[i] = hbarChar ();	if (n->IsLeftMost ())		fLine[start] = leftmostChar ();	else	{		// n is a sibling		if (n->IsRightMost ())			fLine[start] = rightmostChar (); 		else fLine[start] = sibChar (); 	}	drawAsTextFillInAncestors (n);		// Terminate line	fLine[stop + 1] = '\0';	o << fLine << ' ' << n->GetLabel () << EOLN;	// Clear the line for the next pass	int j = kMaxLeaves + kMaxLeafLabelLength;	for (i = 0; i < j; i++)		fLine[i] = ' ';}// change name firstNonMarkedDescendantTTreeNode* TTree::firstNonMarkedDescendant (TTreeNode* n) const{	n = n->GetChild ();	if (n->IsMarked ())		n = nextNonMarkedDescendant (n);	return (n);}// read in as tree isTTree& TTree::FromAncestorFunction (const TAncestorFunction& anf){	DeleteTree (); //keeps rooting....			SetName (anf.GetName ());	SetWeight (anf.GetWeight ());	SetTreeType (anf.fTreeType);			fInternalArray.Fill (NULL);		fRoot->SetNumber (kMaxLeaves + anf.GetInternalNodes ());	getIthInternal (fRoot->GetNumber ()) = fRoot;	for (anf.fLeafSet.FirstLeaf (); anf.fLeafSet.CurLeaf (); anf.fLeafSet.NextLeaf ())	{		TTreeNode* nunode = newNode ();		++fLeaves;		nunode->SetNumber (anf.fLeafSet.CurLeaf ());		getLeaf (nunode->GetNumber ()) = nunode;				// change name of this function...		fromAncestorFunctionAddNode (nunode, anf.getAncestor (nunode->GetNumber ()));	}		for (unsigned int i = kMaxLeaves + 1; i < kMaxLeaves + fInternals; ++i)		fromAncestorFunctionAddNode (getIthInternal (i), anf.getAncestor (i));			if (anf.isWeightsInternals ())	{		SetWeightsInternals (true);		for (unsigned int i = 1; i <= fInternals; ++i)			getIthInternal (i)->SetWeight (anf.GetWeightIthInternal (i));					SetLabelsInternals (); //might want to move from here?? where to control labelling ?? maybe just set in treesblock of certain consensus types ??	}	else		SetWeightsInternals (false);			CHECK_ (IsBinaryRoot () ? anf.IsBinaryRoot () : !anf.IsBinaryRoot ());	CHECK_ (anf.getAncestor (kMaxLeaves + fInternals) == TAncestorFunction::codingRootsAncestor () && getIthInternal (kMaxLeaves + fInternals) == fRoot);	// should be even faster..	upDate (); // ?? me thinks I can cause it to update own leafsets as does leaves first and then moves through tree...		// because could have been saved as rooted and then read back as unrooted...	if (!IsRooted () && IsBinaryRoot ()) 	{		TTreeNode* nodePtr;		collapseBinaryRoot (nodePtr);		deleteNode (nodePtr);	}	return (*this);}void TTree::fromAncestorFunctionAddNode (TTreeNode* nunode, const unsigned int ancestor){	CHECK (nunode);	TTreeNode* anc = getIthInternal (ancestor);	if (!anc)	{		anc = newNode ();		++fInternals;		anc->SetNumber (ancestor);		getIthInternal (anc->GetNumber ()) = anc;	}	nunode->SetAnc (anc);	if (!anc->GetChild ())		anc->SetChild (nunode);	else		anc->GetChild ()->GetRightMostSibling ()->SetSibling (nunode);}TTree& TTree::FromTreeString (const TString& treeString){	DeleteTree ();		TStringIteratorConst& iterator = treeString.IteratorConst ();		CHECK_ (iterator.CurCharRef () == '(');					fCurNode = fRoot;		fInternals = 0;	fLeaves = 0;	readComponentFromTreeString (iterator);		delete (&iterator);		upDate ();		CHECK_ (3 < GetLeaves () || (IsRooted () && GetLeaves () == 3));		if (!IsRooted () && IsBinaryRoot ())	{		TTreeNode* nodePtr;		collapseBinaryRoot (nodePtr);		deleteNode (nodePtr);	}			return (*this); }unsigned long TTree::GetImbalance (void) const{	CHECK_ (IsBinary () && IsRooted ()); // as undefined for polytomies and unrooted trees...	CHECK (3 < GetLeaves ());	unsigned long imbalance = 0;	getImbalanceTraverse (fRoot, imbalance);	return (imbalance);}unsigned long TTree::getMinImbalance (const unsigned int leaves){	if (2 < leaves)	{		if (!IsEven (leaves))			return (1 + getMinImbalance ((leaves + 1) / 2) + getMinImbalance ((leaves - 1) / 2));		return (getMinImbalance (leaves / 2) * 2);	}	return (0);}void TTree::getImbalanceTraverse (const TTreeNode* node, unsigned long& imbalance) const{	CHECK (IsBinary () && IsRooted ());	CHECK (3 < GetLeaves ());		if (node)	{		if (!node->IsLeaf ())		{			CHECK (getDegreeNode (*node) == 2);						const int leftLeaves = node->GetChild ()->GetLeaves ();			const int rightLeaves = node->GetChild ()->GetSibling ()->GetLeaves ();			imbalance += (leftLeaves < rightLeaves ? rightLeaves - leftLeaves : leftLeaves - rightLeaves); 			getImbalanceTraverse (node->GetChild (), imbalance);		}		getImbalanceTraverse (node->GetSibling (), imbalance);	}}unsigned int TTree::getDegreeNode (const TTreeNode& node) const{	unsigned int degree = 0;	for (const TTreeNode* child = node.GetChild (); child; child = child->GetSibling ())		++degree;	return (degree);}TTreeNode* TTree::getInternal (const TLeafSet& cluster) const{	TTreeNode* node = (TTreeNode*)MRCA (cluster);	return (node->IsEqual (cluster) ? node : NULL);}double TTree::GetResolutions (void) const{	CHECK_ (fTreeType == kStrictCladistic || fTreeType == kDecayIndex); // JLT 010315 allowed calculation of CIC for DDA support trees		double resolutions = 1;	if (!IsBinary ())		getResolutionsTraverse (GetRoot (), resolutions);		CHECK_ (isfinite (resolutions));	return (resolutions);}void TTree::getResolutionsTraverse (const TTreeNode* node, double& resolutions) const{	if (node)	{		getResolutionsTraverse (node->GetChild (), resolutions);		getResolutionsTraverse (node->GetSibling (), resolutions);		if (!node->IsLeaf ())		{			if (!node->IsRoot ())				resolutions *= calcB (node->GetDegree () - 1);			else				resolutions *= calcB (node->GetDegree () - (IsRooted () ? 0 : 1));		}	}}TTreeNode* TTree::getIthInternalTraversal (const unsigned int i){	CHECK_ (i <= fInternals); // 	TTreeNode* internal = NULL;	unsigned int count = i;	ithInternalTraverse (count, fRoot, internal);	CHECK_ (internal);	return (internal);}// 1500 * 1499 * 1498 / 6 = 5.6 * 10^8// ULONG_MAX = 4.2 * 10^9unsigned long TTree::GetResolvedTriplets (void) const{	CHECK_ (IsRooted ());	CHECK_ (2 < GetLeaves () && GetLeaves () <= 1500);	unsigned long triplets = 0;	traverseTriplets (GetRoot (), triplets);		return (triplets);}void TTree::traverseTriplets (const TTreeNode* node, unsigned long& triplets) const{	CHECK (IsRooted ());	CHECK (2 < GetLeaves () && GetLeaves () <= 1500);	if (node)	{		traverseTriplets (node->GetChild (), triplets);		traverseTriplets (node->GetSibling (), triplets);				if (!node->IsRoot () && !node->IsLeaf ())		{			const TTreeNode* child1 = node->GetChild (); 				const TTreeNode* child2 = child1->GetSibling ();						TLeafSet leafSet (*GetRoot () - *node);			unsigned long combinations = 0;						while (1)			{								combinations += (unsigned long)child1->GetLeaves () * (unsigned long)child2->GetLeaves ();						if ((child2 = child2->GetSibling ()) == NULL)				{					child1 = child1->GetSibling ();					if ((child2 = child1->GetSibling ()) == NULL)						break;				}			}			triplets += combinations * (unsigned long)leafSet.GetLeaves ();		}	}}	// 500 * 499 * 498 * 497 / 24 = 2.5 * 10^9// ULONG_MAX = 4.2 * 10^9unsigned long TTree::GetResolvedQuartets (void) const{	CHECK_ (!IsRooted ());	CHECK_ (3 < GetLeaves () && GetLeaves () <= 500);			unsigned long quartets = 0;	traverseQuartets (GetRoot (), quartets);	return (quartets);}void TTree::traverseQuartets (const TTreeNode* node, unsigned long& quartets) const{		CHECK (!IsRooted ());	CHECK (3 < GetLeaves () && GetLeaves () <= 500);	if (node)	{		traverseQuartets (node->GetChild (), quartets);		traverseQuartets (node->GetSibling (), quartets );				if (!node->IsRoot () && !node->IsLeaf ())		{			const TTreeNode* child1 = node->GetChild (); 				const TTreeNode* child2 = child1->GetSibling ();			TLeafSet leafSet (*GetRoot () - *node);			unsigned long combinations = 0;						while (1)			{				combinations += ((unsigned long)child1->GetLeaves () * (unsigned long)child2->GetLeaves ());																	if ((child2 = child2->GetSibling ()) == NULL)				{					child1 = child1->GetSibling ();					if ((child2 = child1->GetSibling ()) == NULL)						break;				}			}			quartets += combinations * (unsigned long)leafSet.GetLeaves () * (unsigned long)(leafSet.GetLeaves () - 1) / (unsigned long)2;						// accounts for multiple counting of the same quartet uses the inherent directionality of the node and its siblings			const TTreeNode* anc = NULL;			for (anc = node; anc; anc = anc->GetAnc ())			{				const TTreeNode* sib = NULL;				for (sib = anc->GetSibling (); sib; sib = sib->GetSibling ())				{					if (!sib->IsLeaf ())					{						quartets -= combinations * (unsigned long)sib->GetLeaves () * (unsigned long)(sib->GetLeaves () - 1) / (unsigned long)2;					}				}			}		}	}}void TTree::GraftLeaf (const unsigned int leaf, unsigned int position){	CHECK_ (!IsLeaf (leaf));	if (!IsRooted () && fLeaves < position)		++position;			CHECK_ ((position <= fLeaves + fInternals));		ReArrange (); // this might slow the whole shebang down..could alwyas have conditional rearranging but quite complicated...				TTreeNode* leafPtr;	TTreeNode* internalPtr;	TTreeNode* nodePtr;	if (IsFlag (kBranchAndBound))		{		CHECK_ (getLeaf (leaf) && !(getLeaf (leaf)->IsLeaf ()) && getLeaf (leaf)->GetNumber () == leaf);				leafPtr = getLeaf (leaf);		internalPtr = leafPtr->GetChild ();		leafPtr->SetChild (NULL);		}	else	{		leafPtr = newNode ();		leafPtr->SetNumber (leaf);		leafPtr->SetDegree (1);		leafPtr->AddToThis (leafPtr->GetNumber ());				internalPtr = newNode ();	}		if (position <= fLeaves)		nodePtr = getLeaf (GetLeafSet ().IthLeaf (position));	else		nodePtr = getIthInternalTraversal (position - fLeaves);		graftLeaf (leafPtr, nodePtr, internalPtr); //swap order}void TTree::graftLeaf (TTreeNode* leafPtr, TTreeNode* nodePtr, TTreeNode* internalPtr){	CHECK_ (internalPtr &&  !internalPtr->IsConnected ()); //rewrite so if NULL then add at the node...note can't then be a leaf...	CHECK_ (leafPtr && nodePtr && !leafPtr->IsConnected () && nodePtr->IsConnected ());	CHECK_ (leafPtr->GetLeaves () == 1 && leafPtr->IsLeaf (leafPtr->GetNumber ()) && leafPtr->GetDegree () == 1);	CHECK_ (IsRooted () || nodePtr != fRoot);				TTreeNode* n;	internalPtr->SetAnc (nodePtr->GetAnc ());	internalPtr->SetChild (leafPtr);	*internalPtr = *nodePtr;	internalPtr->SetDegree (3);	leafPtr->SetAnc (internalPtr);	leafPtr->SetSibling (nodePtr);	internalPtr->SetSibling (nodePtr->GetSibling ());	nodePtr->SetSibling (NULL);			if (fRoot == nodePtr)	{		internalPtr->DecrDegree ();		nodePtr->IncrDegree ();		fRoot = internalPtr;	}	else		replaceNode (nodePtr, internalPtr);	nodePtr->SetAnc (internalPtr);	for (n = leafPtr; n->GetAnc (); n = n->GetAnc ())		n->GetAnc ()->AddToThis (leafPtr->GetNumber ());			++fLeaves;	++fInternals;	}void TTree::GraftLeafAsOutgroup (const unsigned int leaf){	CHECK_ (!IsLeaf (leaf) && IsRooted ());		GraftLeaf (leaf, fLeaves + 1);	upDateLeafArray (); // this seems to be needed shouldn't be!!!	// have a look at the graft leaf function sometime...}bool TTree::IsAdamsResolution (const TTree& tree) const{	CHECK_ (IsRooted () && tree.IsRooted ());	CHECK_ (2 < tree.GetLeaves ());	CHECK_ (tree.GetLeafSet ().IsSubset (GetLeafSet ()));	CHECK_ (tree.IsBinary ());	CHECK_ (GetTreeType () == kStrictNestings && tree.GetTreeType () == kStrictCladistic);		upDateInternalArray ();	TTreeNode* internalPtr;			if (GetLeafSet () != tree.GetLeafSet ())	{		for (unsigned int i = 1; i < fInternals; ++i)		{			internalPtr = getIthInternal (i);			CHECK_ (internalPtr);			if (((*(internalPtr->GetAnc ()) - *(internalPtr)).IsSubset (tree.GetLeafSet ())) && (1 < (*internalPtr * tree.GetLeafSet ()).GetLeaves ()) && (tree.MRCA (*internalPtr * tree.GetLeafSet ()) == tree.MRCA (*internalPtr->GetAnc ()  * tree.GetLeafSet ())))				return (false);		}		return (true);	}	for (unsigned int i = 1; i < fInternals; ++i)	{		internalPtr = getIthInternal (i);		CHECK_ (internalPtr);		if (tree.MRCA (*internalPtr) == tree.MRCA (*internalPtr->GetAnc ()))			return (false);	}	return (true);}bool TTree::IsCompatible (const TLeafSet& cluster) const{	CHECK_ (cluster.IsSubset (GetLeafSet ()));	CHECK_ (1 < cluster.GetLeaves () && cluster != GetLeafSet ());	const TTreeNode* node = fRoot;		// locate insertion point	while (node)	{		switch (cluster.Relationship (*node))		{			case disjoint:				node = node->GetSibling ();				break;			case subset:				node = node->GetChild ();				break;			case superset:	// even if the cluster is a superset of one of the siblings (note: it must have been a subset of the GetAnc ())							// it may still be overlapping with another of the siblings consider cluster = 1235  tree = ((12),(435));				node = node->GetSibling ();				break;									case identity:				return (true);						case overlapping:				return (false);											default:				CHECK_ (0);				return (false);		}	}	return (true);}bool TTree::IsCompatible (const TSplit& split) const{	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());	CHECK_ (GetLeafSet () == split.GetLeafSet ());	CHECK_ (split.IsInformative ());		if (IsCompatible (split.GetLeafSet (true)))		return (true);	return (IsRooted () ? false : IsCompatible (split.GetLeafSet (false)));}bool TTree::IsCompatible (const TTree& tree) const{	CHECK_ ((IsRooted () ? tree.IsRooted () : !tree.IsRooted ()));	CHECK_ (GetLeafSet () == tree.GetLeafSet ());	CHECK_ (IsRooted () || isOutGroup (tree.getOutGroup ()));	return (isCompatibleTraverse (tree.GetRoot ()));}bool TTree::isCompatibleTraverse (const TTreeNode* node) const{	if (node)	{		if (!node->IsLeaf () && !node->IsRoot () && !IsCompatible (*node))			return (false);		if (!isCompatibleTraverse (node->GetChild ()))			return (false);		if (!isCompatibleTraverse (node->GetSibling ()))			return (false);	}	return (true);}// returns true if tree is a contraction of TTree::thisbool TTree::IsContraction (const TTree& tree) const{	CHECK_ (IsRooted () ? tree.IsRooted () : !tree.IsRooted ());	CHECK_ (GetTreeType () == kStrictCladistic && tree.GetTreeType () == kStrictCladistic);	CHECK_ (GetLeafSet () == tree.GetLeafSet ());		CHECK_ (IsRooted () || isOutGroup (tree.getOutGroup ()));	return (tree.InternalBranches () < InternalBranches () && isContractionTraverse (tree.GetRoot ()));}bool TTree::isContractionTraverse (const TTreeNode* node) const{	if (node)	{		if (!node->IsLeaf () && !node->IsRoot () && !IsDisplays (*node))			return (false);		if (!isContractionTraverse (node->GetChild ()))			return (false);		if (!isContractionTraverse (node->GetSibling ()))			return (false);	}	return (true);}//change so that does with subset of leaves...bool TTree::IsDisplays (const TSplit& split) const{	CHECK_ (IsRooted () ? split.IsRooted () : !split.IsRooted ());	CHECK_ (GetLeafSet () == split.GetLeafSet ());	CHECK_ (split.IsInformative ());		if (IsDisplays (split.GetLeafSet (true)))		return (true);	if (!IsRooted ())		return (IsDisplays (split.GetLeafSet (false)));	return (false);}bool TTree::IsEqual (const TObject& obj) const{	CHECK_ (Class () == obj.Class ());	const TTree& tree = (const TTree&)obj;		CHECK_ (IsRooted () ? tree.IsRooted () : !tree.IsRooted ());		if (InternalBranches () == tree.InternalBranches () && GetLeafSet () == tree.GetLeafSet ())		return (isEqual (fRoot, tree));	return (false);}bool TTree::isEqual (const TTreeNode* node, const TTree& tree) const{	if (node)	{		if (!node->IsRoot () && !node->IsLeaf ())		{			TSplit split (*node, *fRoot, IsRooted ());			CHECK_ (split.IsInformative ());			if (!tree.IsDisplays (split))				return (false);				}		if (isEqual (node->GetSibling (), tree) && isEqual (node->GetChild (), tree))			return (true);		return (false);	}	return (true);}bool TTree::isNodeBinary (TTreeNode* n) const{ 	unsigned int degree = 0;	for (n = n->GetChild (); n; n = n->GetSibling ())		if (2 < ++degree)			return (false);	return ((bool)(degree == 2));}void TTree::ithInternalTraverse (unsigned int& i, TTreeNode* n, TTreeNode*& internal){	if (n)	{		if (!n->IsLeaf () && !(--i))			internal = n;		else		{			ithInternalTraverse (i, n->GetChild (), internal);			if (i)				ithInternalTraverse (i, n->GetSibling (), internal);		}	}}bool TTree::IthInternalNode (const unsigned int i, const TTreeNode*& node) const { 	if (i <= fInternals)	{		node = ((TTree*)this)->getIthInternalTraversal (i);		return (true);	}	return (false);} //change so that uses nodearray ??void TTree::LabelLeaves (const TTaxaBlock& taxaLabels){	CHECK (!(IsFlag (kLeavesLabelled)));	for (FirstLeaf (); CurLeaf (); NextLeaf ())	{		getLeaf (CurLeaf ())->SetLabel (taxaLabels.GetLeafName (CurLeaf ())); // use leaf instead...	}}void TTree::LabelCluster (const TLeafSet& cluster, const TString label){	CHECK_ (IsDisplays (cluster));	getInternal (cluster)->SetLabel (label);}void TTree::listOtherDescendants (TTreeNode* n) const{	TTreeNode* nonOGDescendant = firstNonMarkedDescendant (n);	// Add descendant	if (n != fRoot)	{		fAddThere->SetChild (nonOGDescendant);		nonOGDescendant->SetAnc (fAddThere);	}	else	{		// descendant of root must be siblings of AddThere		fAddThere->SetSibling (nonOGDescendant);		nonOGDescendant->SetAnc (fAddThere->GetAnc ());	}	fAddThere = nonOGDescendant;	// Go through remaining descendants	for (nonOGDescendant = nextNonMarkedDescendant (nonOGDescendant); nonOGDescendant; nonOGDescendant = nextNonMarkedDescendant (nonOGDescendant))	{		fAddThere->SetSibling (nonOGDescendant);		nonOGDescendant->SetAnc (fAddThere->GetAnc ());		fAddThere = nonOGDescendant;	}	fAddThere->SetSibling (NULL);}// Return least upper bound (node where set of leaves partitioned) in treeconst TTreeNode* TTree::LUB (const TLeafSet& leafSet) const{ // what is the difference between this and mrca ??	CHECK_ (!leafSet.IsEmpty () && leafSet.IsSubset (GetLeafSet ()));		const TTreeNode* n = fRoot;	while (n)	{		switch (n->Relationship (leafSet))		{			case identity:               	// we've found it exactly				return (n);			case subset:				// n's ancestor was lub				return (n->GetAnc ());			case disjoint:               	// look at sibling				n = n->GetSibling ();				break;			case superset:               	// n is too big, go left up tree				n = n->GetChild ();				break;			case overlapping:				// n's ancestor was lub				return (n->GetAnc ());		}	}	return (NULL);}void TTree::makeAncestor (void){	CHECK_ (!fNodeStack.IsEmpty ());	fNodeStack.Pop (fCurNode);		CHECK_ (1 < getDegreeNode (*fCurNode));}void TTree::makeChild (void){	// imagine kMaxLeaves == 3 and TreeString = ((1,2),3) if number of items on fNodeStack exceeds 1 then TTreeString must be incorrect	// i.e. (((1,2),3)). Note does not do makeChild for first '('	CHECK_ (fNodeStack.GetItems () < kMaxLeaves - 1);		fNodeStack.Push (fCurNode);		TTreeNode* nunode = newNode ();	fCurNode->SetChild (nunode);	nunode->SetAnc (fCurNode);	fCurNode = nunode;}void TTree::makeRootBinary (void) const{	CHECK_ (!IsFlag (kBranchAndBound));	CHECK_ (!IsBinaryRoot () && 2 < GetLeaves ());		TTreeNode* nRoot = newNode ();	((TTree*)this)->fInternals += 1;	nRoot->AddToThis (*fRoot);	nRoot->SetDegree (2);		nRoot->SetChild (fRoot->GetChild ());	fRoot->GetChild ()->SetAnc (nRoot);	fRoot->SetChild (fRoot->GetChild ()->GetSibling ());	fRoot->SubtractFromThis (*nRoot->GetChild ());	nRoot->GetChild ()->SetSibling (fRoot);	fRoot->SetAnc (nRoot);	((TTree*)this)->fRoot = nRoot;}void TTree::makeSibling (void){		TTreeNode* nunode = newNode ();	fCurNode->SetSibling (nunode);	nunode->SetAnc (fCurNode->GetAnc ());	fCurNode = nunode;}void TTree::MapLeaves (const TLeafMap& leafMap){	CHECK_ (!IsFlag (kBranchAndBound));// don't understand how this works!!!		//	unsigned int leaf;//	for (leafMap.FirstMapping (); (leaf = leafMap.CurMapping ()) != 0; leafMap.NextMapping ())//		if (getLeaf (leaf))//			getLeaf (leaf)->SetNumber (leafMap.Map (leaf));//	upDateLeafArray ();//	upDate (); 		CHECK_ (GetLeafSet ().IsSubset (leafMap.GetLeafSet ()));	for (unsigned int leaf = FirstLeaf (); leaf; leaf = NextLeaf ())		getLeaf (leaf)->SetNumber (leafMap.GetMapping (leaf));	upDateLeafArray ();	upDate (); }void TTree::mark (TTreeNode* n, const bool bmark){	if (n)	{		n->SetMarked (bmark);		mark (n->GetChild (), bmark);		mark (n->GetSibling (), bmark);		}}void TTree::markPath (TTreeNode* n) const{	while (n)	{		n->SetMarked ();		n = n->GetAnc ();	}}const TTreeNode* TTree::MRCA (const TLeafSet& leafSet) const{	CHECK_ (leafSet.IsSubset (GetLeafSet ()));			const TTreeNode* n = getLeaf (leafSet.FirstLeaf ());		while (!leafSet.IsSubset (*n))		n = n->GetAnc ();		return (n);}// Return next desc of p that is not on the path OG..Root.TTreeNode* TTree::nextNonMarkedDescendant (TTreeNode* n) const{	n = n->GetSibling (); 	while (n && n->IsMarked ())		 n = n->GetSibling ();	return (n);}TTree& TTree::operator = (const TTree& tree) {	SetFlag (kRooted, tree.IsRooted ());		TAncestorFunction anf;	tree.AncestorFunction (anf);	FromAncestorFunction (anf);	return (*this);}void TTree::PruneLeaves (const TLeafSet& toPrune){		for (unsigned int leaf = toPrune.FirstLeaf (); leaf; leaf = toPrune.NextLeaf ())		PruneLeaf (leaf);}void TTree::PruneLeaf (const unsigned int leaf){			if (IsLeaf (leaf))	{		CHECK_ ((3 < GetLeaves ()) || (IsRooted () && GetLeaves () == 3));		TTreeNode* leafPtr = getLeaf (leaf);		TTreeNode* internalPtr = NULL;		pruneLeaf (leafPtr, internalPtr);				if (IsFlag (kBranchAndBound))		{			CHECK_ (internalPtr);			leafPtr->SetChild (internalPtr);		}		else		{			deleteNode (leafPtr);			if (internalPtr)				deleteNode (internalPtr);		}	}	}// internal NULL if no internal// leaf and internal should be disconnected by this function// this should handle collapsing binary root and also updating...void TTree::pruneLeaf (TTreeNode* leafPtr, TTreeNode*& internal){	CHECK_ ((3 < GetLeaves ()) || (IsRooted () && GetLeaves () == 3));	CHECK_ (leafPtr && leafPtr->IsLeaf () && leafPtr->IsConnected ());		TTreeNode* anc = leafPtr->GetAnc ();	TTreeNode* n;		for (n = leafPtr; n->GetAnc (); n = n->GetAnc ())		n->GetAnc ()->SubtractFromThis (leafPtr->GetNumber ());		replaceNode (leafPtr, leafPtr->GetSibling ());	--fLeaves;	leafPtr->Disconnect ();		anc->DecrDegree ();		if (anc == fRoot)	{		if (anc->GetDegree () == 1)		{			CHECK_ (IsRooted ());			internal = fRoot;			fRoot = fRoot->GetChild ();			fRoot->SetAnc (NULL);			fRoot->DecrDegree ();			--fInternals;			internal->Disconnect ();		}		else if (anc->GetDegree () == 2 && !IsRooted ())			collapseBinaryRoot (internal);	}	else if (anc->GetDegree () == 2)	{			internal = anc;			anc->GetChild ()->SetAnc (anc->GetAnc ());			anc->GetChild ()->SetSibling (anc->GetSibling ());			replaceNode (anc, anc->GetChild ());			--fInternals;			internal->Disconnect ();	}	else		internal = NULL;}void TTree::readComponentFromTreeString (TStringIteratorConst& iterator){	++fInternals;		makeChild ();	bool isNodeExpected = true;			iterator.NextCharRef ();	while (iterator.CurCharRef () != ')')	{		if (!isNodeExpected)		{			CHECK_ (iterator.CurCharRef () == ',');					makeSibling ();						iterator.NextCharRef ();			isNodeExpected = true;		}		else // if (isNodeExpected)		{			if (iterator.CurCharRef () == '(')			{				readComponentFromTreeString (iterator);				iterator.NextCharRef ();			}			else			{				CHECK_ (isdigit (iterator.CurCharRef ()));				TString string;				string += iterator.CurCharRef ();				while (isdigit (iterator.NextCharRef ()))					string += iterator.CurCharRef ();								unsigned int leaf = string.ToInteger ();									CHECK_ (!IsLeaf (leaf));				fRoot->AddToThis (leaf);								fCurNode->SetNumber (leaf);				getLeaf (fCurNode->GetNumber ()) = fCurNode;				++fLeaves;			}			isNodeExpected = false;				}		}	makeAncestor ();}unsigned int TTree::readNodeNumber (char** p) const{	CHECK_ (isdigit (**p));		unsigned int n = atoi(*p);		while(**p && isdigit(**p))		++(*p);	--(*p);	return(n);}void TTree::reArrangeComponent (TTreeNode* node) const{	CHECK_ (node);	TTreeNode* child = node->GetChild ();	while (child)	{		TTreeNode* sib = child->GetSibling ();		while (sib)		{			if (*sib < *child )			{				switchNodes (child, sib);				child = sib;				break;			}			sib = sib->GetSibling ();		}		if (!sib)			child = child->GetSibling ();	}}void TTree::reArrangeTraverse (TTreeNode* node) const{	if (node)	{		reArrangeComponent (node);		reArrangeTraverse (node->GetChild ());		reArrangeTraverse (node->GetSibling ());	}}void TTree::replaceNode (TTreeNode* node, TTreeNode* replacement){	CHECK_ (node);	TTreeNode* n = node->GetAnc ();	CHECK_ (n && n->GetChild ());		if (n->GetChild () == node)		n->SetChild (replacement);	else	{		for (n = n->GetChild (); 1; n = n->GetSibling ())		{			CHECK_ (n->GetSibling ());			if (n->GetSibling () == node)			{				n->SetSibling (replacement);				break;			}		}	}}void TTree::Root (const bool binaryRoot) {	if (!IsRooted ())	{		if (binaryRoot && !IsBinaryRoot () && 2 < GetLeaves ())			makeRootBinary ();		SetFlag (kRooted, true); 	}}void TTree::SetNodeHeights (const TTreeStyle::NodeHeights nodeHeights) { 		fMaxLeafHeight = 0;	switch (nodeHeights)	{		case TTreeStyle::kZero:			setNodeHeights_Height (fRoot, 0);			break;		case TTreeStyle::kDepth:			setNodeHeights_Depth (fRoot);			break;		case TTreeStyle::kCardinality:			setNodeHeights_Cardinality (fRoot);			fMaxLeafHeight = (GetLeaves () - 1);			break;		case TTreeStyle::kTopDown:			setNodeHeights_Depth (fRoot);			setNodeHeights_Height (fRoot, fMaxLeafHeight);			setNodeHeights_TopDown (fRoot);			break;		case TTreeStyle::kBottomUp:			setNodeHeights_Depth (fRoot);			setNodeHeights_Height (fRoot, 0);			setNodeHeights_BottomUp (fRoot);			break;						default:			CHECK_ (0);			break;	}}void TTree::setNodeHeights_Height (TTreeNode* node, const unsigned int height){	if (node)	{		node->SetHeight (height);		setNodeHeights_Height (node->GetSibling (), height);		setNodeHeights_Height (node->GetChild (), height);	}}void TTree::setNodeHeights_Depth (TTreeNode* node){	if (node)	{		node->SetHeight (node->IsRoot () ? 0 : node->GetAnc ()->GetHeight () + 1);		if (fMaxLeafHeight < node->GetHeight ())			fMaxLeafHeight = node->GetHeight ();					setNodeHeights_Depth (node->GetSibling ());		setNodeHeights_Depth (node->GetChild ());	}}void TTree::setNodeHeights_Cardinality (TTreeNode* node){	if (node)	{		node->SetHeight (GetLeaves () - node->GetLeaves ());		setNodeHeights_Cardinality (node->GetSibling ());		setNodeHeights_Cardinality (node->GetChild ());	}}// assumes that all nodes set to fMaxLeafHeight// pushes down but only as far as needs tovoid TTree::setNodeHeights_TopDown (TTreeNode* node){	if (node)	{		setNodeHeights_TopDown (node->GetChild ());		setNodeHeights_TopDown (node->GetSibling ());		if (node->IsRoot ())			node->SetHeight (0);		else if (node->GetHeight ())		{			if (node->GetHeight () - 1 < node->GetAnc ()->GetHeight ())				node->GetAnc ()->SetHeight (node->GetHeight () - 1);		}		else			node->GetAnc ()->SetHeight (0);	}}// assumes that all nodes set to 0// pushes up but only as far as need tovoid TTree::setNodeHeights_BottomUp (TTreeNode* node){	if (node)	{				if (!node->IsRoot ())		{			if (node->IsLeaf ())				node->SetHeight (fMaxLeafHeight);			else if (node->GetAnc ()->GetHeight () + 1 < fMaxLeafHeight)				node->SetHeight (node->GetAnc ()->GetHeight () + 1);			else				node->SetHeight (fMaxLeafHeight);		}		setNodeHeights_BottomUp (node->GetSibling ());		setNodeHeights_BottomUp (node->GetChild ());	}}void TTree::ReRoot (const unsigned int leaf) { 	CHECK_ (!IsFlag (kBranchAndBound));	CHECK_ (GetLeafSet ().IsLeaf (leaf)); 	CHECK_ (IsRooted ());		reRoot (getLeaf (leaf)); }void TTree::reRoot (TTreeNode* leaf){	CHECK_ (!IsFlag (kBranchAndBound));	CHECK_ (IsRooted () && 1 < GetLeaves ());	CHECK_ (leaf && leaf->IsLeaf () && leaf->IsConnected ());		if (!isOutGroup (leaf))	{				if (leaf->GetAnc () == fRoot)		{			if (fRoot->GetChild () != leaf)				switchNodes (fRoot->GetChild (), leaf);			((TTree*)this)->makeRootBinary ();			return;					}			markPath (leaf); // markPath from leaf to root		// ?? just have to sort out this...then try and compile and run...		TTreeNode* inGroup = newNode ();		++fInternals;				inGroup->SetAnc (leaf->GetAnc ());		fAddThere = inGroup;		TTreeNode* n = leaf->GetAnc ();		while (n)		{			listOtherDescendants (n);			TTreeNode* t = n;			n = n->GetAnc ();			if (n && n != fRoot) // is both tests needed ??			{				TTreeNode* p = newNode ();				++fInternals;				fAddThere->SetSibling (p);				p->SetAnc (fAddThere->GetAnc ());				fAddThere = p;			}		}		leaf->GetAnc ()->SetChild (leaf);		leaf->SetSibling (inGroup);		((TTree*)this)->fRoot = leaf->GetAnc ();		n = fRoot->GetAnc ();		while (n)		{			TTreeNode* p = n;			n = n->GetAnc ();			deleteNode (p);			--fInternals;		}		fRoot->SetAnc (NULL);		fRoot->SetSibling (NULL);		fRoot->SetMarked (false);		leaf->SetMarked (false);		upDate ();	}}void TTree::StarTree (const unsigned int leaves){	TLeafSet leafSet (leaves);	StarTree (leafSet);}void TTree::StarTree (const TLeafSet& leafSet){	CHECK_ (!IsFlag (kBranchAndBound));	CHECK_ (!leafSet.IsEmpty ());	DeleteTree ();	TTreeNode* nunode = newNode ();	++fLeaves;	nunode->SetNumber (leafSet.FirstLeaf ());	getLeaf (nunode->GetNumber ()) = nunode;	nunode->AddToThis (nunode->GetNumber ());	nunode->SetDegree (1);		nunode->SetAnc (fRoot);	fRoot->SetChild (nunode);	fRoot->IncrDegree ();	fRoot->AddToThis (nunode->GetNumber ());		while (leafSet.NextLeaf ())	{		TTreeNode* nextnode = newNode ();		++fLeaves;		nextnode->SetNumber (leafSet.CurLeaf ());		getLeaf (nextnode->GetNumber ()) = nextnode;		nextnode->AddToThis (nextnode->GetNumber ());		nextnode->SetDegree (1);				nextnode->SetAnc (fRoot);		nunode->SetSibling (nextnode);				fRoot->IncrDegree ();		fRoot->AddToThis (nextnode->GetNumber ());				nunode = nextnode;		}}// note must be in the same component and this occurs to the left of pvoid TTree::switchNodes (TTreeNode* node, TTreeNode* p) const{	CHECK_ (node && p && node != p && node->IsConnected () && p->IsConnected ());		TTreeNode* q = node->GetLeftMostSibling ();		while (q != node && q->GetSibling () != node)		q = q->GetSibling ();		TTreeNode* r = q;		while (r->GetSibling () != p)		r = r->GetSibling ();		if (q == node)		q->GetAnc ()->SetChild (p);	else		q->SetSibling (p);		r->SetSibling (node);		q = node->GetSibling ();	node->SetSibling (p->GetSibling ());	p->SetSibling (q);}void TTree::ThreeLeafTree (const unsigned int leaves){	TLeafSet leafSet (leaves);	ThreeLeafTree (leafSet);}void TTree::ThreeLeafTree (const TLeafSet& leafSet){	CHECK_ (!IsRooted ());	CHECK_ (3 < leafSet.GetLeaves ());	DeleteTree ();	TLeafSet threeLeaves;	threeLeaves.AddToThis (leafSet.FirstLeaf ());	threeLeaves.AddToThis (leafSet.NextLeaf ());	threeLeaves.AddToThis (leafSet.NextLeaf ());	StarTree (threeLeaves);     // Set up leaves 4..n  	for (unsigned int i = leafSet.NextLeaf (); i; i = leafSet.NextLeaf ())	{     	TTreeNode* node1 = getLeaf (i) = newNode ();		node1->SetNumber (i);		node1->AddToThis (i);		node1->SetChild (newNode ());		node1->SetDegree (1);	}		SetFlag (kBranchAndBound, true);}TTree::TTree (const bool rooted)	: fLeafArray (kMaxLeaves)	, fInternalArray (kMaxInternals){	SetFlag (kRooted, rooted);	SetFlag (kBranchAndBound, false);		fWeight = kDefaultWeight;	fTreeType = kStrictCladistic;	fLeafArray.Fill (NULL);	fRoot = newNode ();	fInternals = 1;	fLeaves = 0;	fMaxLeafHeight = 0;}TTree::TTree (const TTree& tree)	: fLeafArray (kMaxLeaves)	, fInternalArray (kMaxInternals){	SetFlag (kRooted, tree.IsRooted ());	SetFlag (kBranchAndBound, false);	fWeight = kDefaultWeight;		fLeafArray.Fill (NULL);	fRoot = newNode ();	fInternals = 1;	fLeaves = 0;	fTreeType = tree.fTreeType;	fMaxLeafHeight = 0;	TAncestorFunction anf;	tree.AncestorFunction (anf);	FromAncestorFunction (anf);}void TTree::TwoLeafTree (const unsigned int leaves){	TLeafSet leafSet (leaves);	TwoLeafTree (leafSet);}void TTree::TwoLeafTree (const TLeafSet& leafSet){	CHECK_ (IsRooted ());	CHECK_ (2 < leafSet.GetLeaves ());	DeleteTree ();	TLeafSet twoLeaves;	twoLeaves.AddToThis (leafSet.FirstLeaf ());	twoLeaves.AddToThis (leafSet.NextLeaf ());	StarTree (twoLeaves);	  	for (unsigned int i = leafSet.NextLeaf (); i;  i = leafSet.NextLeaf ())	{     	TTreeNode* node1 = getLeaf (i) = newNode ();		node1->SetNumber (i);		node1->AddToThis (i);		node1->SetChild (newNode ());		node1->SetDegree (1);   	}		SetFlag (kBranchAndBound, true);}void TTree::UnRoot (void) { 	CHECK_ (fTreeType != kStrictNestings);		if (IsRooted ())	{		if (IsBinaryRoot ())		{			TTreeNode* nodePtr;			collapseBinaryRoot (nodePtr);			deleteNode (nodePtr);		}		SetFlag (kRooted, false); 	}}void TTree::upDateInternalArray (void) const{	((TTree*)this)->fInternalArray.Fill (NULL); 	unsigned int count = kMaxLeaves;	upDateInternalArrayTraverse (fRoot, count);	CHECK_ (count - kMaxLeaves == fInternals);}	void TTree::upDateInternalArrayTraverse (TTreeNode* n, unsigned int& count) const{	if (n)	{		upDateInternalArrayTraverse (n->GetChild (), count);		upDateInternalArrayTraverse (n->GetSibling (), count);		if (!n->IsLeaf ())		{			n->SetNumber (++count);			getIthInternal (n->GetNumber ()) = n;		}	}}void TTree::upDateLeafArray (void) const{	CHECK_ (!IsFlag (kBranchAndBound));	((TTree*)this)->fLeafArray.Fill (NULL);	upDateLeafArrayTraverse (fRoot);}void TTree::upDateLeafArrayTraverse (TTreeNode* n) const{	if (n)	{		upDateLeafArrayTraverse (n->GetChild ());		upDateLeafArrayTraverse (n->GetSibling ());		if (n->IsLeaf ())			getLeaf (n->GetNumber ()) = n;	}}void TTree::upDateTraverse (TTreeNode* n) const{	if (n)	{		n->SetEmpty ();      	n->SetDegree (0);		upDateTraverse (n->GetChild ());		upDateTraverse (n->GetSibling ());		if (n->IsLeaf () && !(n->IsRoot ()))			n->AddToThis (n->GetNumber ());		if (!(n->IsRoot ()))		{			n->GetAnc ()->AddToThis (*n);			n->GetAnc ()->IncrDegree ();			n->IncrDegree ();		}	}}// boolean cmf determines whether PAUP Font File or ASCII font charactes used to draw tree as textostream& TTree::WriteAsText (ostream &o, const bool showTreeName, const bool cmf) const{// JLT 000624//	CHECK_ (GetLeaves () <= 100); // RadCon has serious problems with more than 100 leaves		SetFlag (kCMF, cmf);	((TTree*)this)->SetNodeHeights (TTreeStyle::kCardinality);	if (fRoot)	{		// Allocate memory for line buffer		fLine = new char[kMaxLeaves + kMaxLeafLabelLength + 1];     	for (unsigned int i = 0; i < kMaxLeaves + kMaxLeafLabelLength; i++)      	fLine[i] = ' ';		fLine[kMaxLeaves + kMaxLeafLabelLength] = '\0';				if (showTreeName)		{			if	(!fName.IsNull ())				o << fName << EOLN;//			else//				o << "radc" << EOLN;		}		   		if (!GetLeaves ()) // change lonenode so even smaller.. other wise spot on   		{			if (IsRooted ())				o << EOLN << lonenodeChar  () << EOLN;			else				o << EOLN << EOLN;   		}   		else if (GetLeaves () == 1)   		{   			if (IsRooted ())				o << EOLN << hbarChar () << ' ' << getLeaf (FirstLeaf ())->GetLabel () << EOLN;			else				o << EOLN << lonenodeChar () << ' ' << getLeaf (FirstLeaf ())->GetLabel () << EOLN; 		}	   	else			drawAsTextTraverse (o, fRoot);		o << EOLN;		      	delete [] fLine;	}	else 		o << "(No tree)" << EOLN;	return (o);}// JLT 000624void TTree::WriteToLog (const bool name) const{	#ifdef VCLASS 		Write (*logStream, name);		logStream->flush();	#else		Write (cout, name);	#endif}ostream& TTree::WriteAsNexus (ostream &o, const int fileWidth) const{	((TTree*)this)->fOStream = &o;	*fOStream << (IsRooted () ? "tree " : "utree ");	fCharacterNumber = (IsRooted () ? 5 : 6);		if (fName.IsNull ())	{		*fOStream << "tree";		fCharacterNumber += 4;	}	else	{		fName.WriteQuoted (*fOStream);		fCharacterNumber += fName.Length () + (fName.IsQuoted () ? 2 : 0);	}		*fOStream << (IsRooted () ? " = [&R] " : " = [&U] ");	fCharacterNumber += 8;	o << "[&W " << GetWeight () << "] "; 	fCharacterNumber += 12;		writeAsNewickTreeDescription (fRoot, fileWidth);	return (*fOStream);}ostream& TTree::WriteAsNewickTreeDescription (ostream &o, const int fileWidth) const{	((TTree*)this)->fOStream = &o;		fCharacterNumber = 0;	writeAsNewickTreeDescription (fRoot, fileWidth);	return (o);}void TTree::writeAsNewickTreeDescription (TTreeNode* n, const int fileWidth) const{	if (n)	{		if (n->IsLeaf())		{			TLeafName leafName = n->GetLabel ();			if (fileWidth && fCharacterNumber + leafName.Length () + (leafName.IsQuoted () ? 2 : 0) > fileWidth)			{				*fOStream << EOLN <<"\t\t";				fCharacterNumber = (kTabSize * 2);			}			fCharacterNumber += n->GetLabel ().Length () + (leafName.IsQuoted () ? 2 : 0);			leafName.WriteQuoted (*fOStream);		}		else		{			if (fileWidth && fCharacterNumber == fileWidth)			{				*fOStream << EOLN <<"\t\t";   				fCharacterNumber = (kTabSize * 2);			}			++fCharacterNumber;			*fOStream << "(";				}		writeAsNewickTreeDescription (n->GetChild (), fileWidth);		if (fileWidth && fCharacterNumber == fileWidth)		{			*fOStream << EOLN << "\t\t";			fCharacterNumber = (kTabSize * 2);		}		++fCharacterNumber;		if (n->GetSibling())			*fOStream << ",";		else if (n != fRoot)			*fOStream << ")";		else			*fOStream << ";";					writeAsNewickTreeDescription (n->GetSibling (), fileWidth);	}}TTree::~TTree (void) { 	deleteTree ();  // what to do with virtual and constructors...destructors etc etc}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif