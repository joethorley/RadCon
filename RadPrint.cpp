#include "RadPrint.h"//------------------------------------------------------------------------------VPrintTreeDialog::VPrintTreeDialog (){	rows = 1;	cols = 1;	fDrawTreeNames = true;	fTreeStyle.SetDrawName ();//	TreeStyle = TS_LEFT | TS_SLANT | TS_CLADOGRAM | TS_SHOWNAME;	fTreesFile = NULL;//	treeItem = id_cladogram;//	font = Port.ParseFont ("Geneva,10");//	edgeFont = font;//	ladder = Ladder_Default;	// Line style////	lineWidth = 1;//	lineItem = id_1pt;	// How are trees arranged?	arrangementItem = id_left_right;		// Line style//	lineWidth = 1;//	lineItem = id_1pt;			// Fonts	font = Port.GetFont ("Geneva", 12, FALSE, FALSE, FALSE);//	edgeFont = Port.GetFont ("Geneva", 10, TRUE, FALSE, FALSE);}//------------------------------------------------------------------------------VPrintTreeDialog::~VPrintTreeDialog (){}//------------------------------------------------------------------------------// Return a picture of the trees on the current pagevoid VPrintTreeDialog::GetPicture (PictureTool &pic){	VRect r;	GrafPtr oldPort;		::GetPort (&oldPort);		VRect pageRect;	Port.PhysPageRect (pageRect);	Port.PrintingRect (r);		// Inflate printing rect to half the margin around the printable area.	// This allows us to later shrink each cell by this amount to ensure consistent	// spacing between each cell.	int w = (pageRect.GetWidth () - r.GetWidth ()) / 4;	int h = (pageRect.GetHeight () - r.GetHeight()) / 4;	r.Inset (-w, -h);				Rect sr = r.GetRectTool();	// Picture data	OpenCPicParams picParams;	picParams.srcRect 	= sr;	picParams.hRes 		= 0x00480000; // 72 dpi	picParams.vRes 		= 0x00480000;	picParams.version 	= -2;	picParams.reserved1 = 0;	picParams.reserved2 = 0;		// Get picture	pic = ::OpenCPicture (&picParams); // 5/1/96	Printing = TRUE;		// Draw trees here...to do: compute trees based on r x c values	Port.Black ();	Port.WidePen (2);		// Shrink r to the size of one cell	r.SetRight (r.GetLeft () + (r.GetWidth() / cols));	r.SetBottom (r.GetTop () + (r.GetHeight() / rows));		int trees_per_page = rows * cols; // trees per page	int start = trees_per_page * (CurrentPage - 1) + 1;	int count = start;			int x;	int y;	if (arrangementItem == id_left_right)	{		x = rows;		y = cols;	}	else	{		x = cols;		y = rows;	}			for (int i = 0; i < x; i++)	{		for (int j = 0; j < y; j++)		{			if (count <= fTreesFile->GetTrees (true))			{				VRect there = r;								if (arrangementItem == id_left_right)				{					there.Offset (there.GetWidth () * j, there.GetHeight () * i);				}				else				{					there.Offset (there.GetWidth () * i, there.GetHeight () * j);				}				there.Inset (w, h);								//Port.WidePen (lineWidth);				Port.WidePen (1);					// Draw tree				TTree tree;				fTreesFile->GetIthTree (count, tree, true, 0);				tree.Draw (there, font, fTreeStyle, NULL); 				count++;			}		}	}			Printing = FALSE;	::ClosePicture();	::SetPort (oldPort);}	//------------------------------------------------------------------------------// Test code for printingvoid VPrintTreeDialog::Print (){	Printing = TRUE;		GrafPtr oldPort;	::GetPort (&oldPort);	if (Port.StartDoc ())	{		int oldCurrentPage = CurrentPage;		int from = Port.GetPageFrom ();		int to = MIN (NumberOfPages, Port.GetPageTo ());		BOOL ok = TRUE;		while (CurrentPage <= to && ok)		{			ok = Port.StartPage();			if (ok)			{				VRect r;				Port.PrintingRect (r);				Rect rtool = r.GetRectTool ();				// 25/1/97				PictureTool pic;				GetPicture  (pic);				::DrawPicture (pic, &rtool);				ok = Port.EndPage();			}			CurrentPage++;		}		Port.EndDoc();		CurrentPage = oldCurrentPage;			}	::SetPort (oldPort);}/*//------------------------------------------------------------------------------BOOL VPrintTreeDialog::DoLineStyle (int item){	Changed = FALSE;	if (item != lineItem)	{		SetItemState (lineItem, FALSE);		SetItemState (item, TRUE);		lineItem = item;		switch (item)		{			case id_1pt:				lineWidth = 1;				break;			case id_2pt:				lineWidth = 2;				break;			case id_3pt:				lineWidth = 3;				break;			default:				lineWidth = 1;				break;		}		// Update display...		Changed = TRUE;	}	return (Changed);}//------------------------------------------------------------------------------BOOL VPrintTreeDialog::DoInternals (){	(GetItemState (id_internals) ? TreeStyle |= TS_USEINTERNALLABEL		: TreeStyle &= ~ TS_USEINTERNALLABEL);	return TRUE;}*///------------------------------------------------------------------------------BOOL VPrintTreeDialog::DoFont (int item){	BOOL Changed = FALSE;	// Store current dialog pointer	VDialogPtr oldDlg = this;		VFontPtr oldFont;//	((item == id_leaf_font) ? oldFont = font : oldFont = edgeFont);	oldFont = font;		VFontPtr newfont = Port.ChooseAFont (oldFont);	if (newfont)	{//		((item == id_leaf_font) ? font = newfont : edgeFont = newfont);		font = newfont;		Changed = TRUE;	}		TheApp->SetDialog (oldDlg);	return Changed;}/*//------------------------------------------------------------------------------// Alter tree order for preview dialog// @mfunc void | VPrintTreeDialog | DoOrder | Handle Tree Order dialog.// @comm Displays dialog, handles user input, then ensures// VPrintTreeDialog has the focus again.BOOL VPrintTreeDialog::DoOrder (){#ifdef Macintosh	BOOL state;#endif	Changed = FALSE;	// Store current dialog pointer	VDialogPtr oldDlg = this;	// Create Trees Order dialog	VDialogPtr dialog = new VDialog;	TheApp->CreateDialog (dialog, 302, TRUE);	switch (ladder)	{		case Ladder_Default:			dialog->CheckRadioButton (id_default_order, id_right_order, id_default_order);			break;		case Ladder_Left:			dialog->CheckRadioButton (id_default_order, id_right_order, id_left_order);			break;		case Ladder_Right:			dialog->CheckRadioButton (id_default_order, id_right_order, id_right_order);			break;	}	dialog->Show ();   	int item;	do {		item = TheApp->DialogItemHit();#ifdef Macintosh		if (item > 3)			dialog->CheckRadioButton (id_default_order, id_right_order, item);#endif	} while (item > 2);	if (item == 1)	{		// handle order here		if (dialog->GetItemState (id_default_order))			ladder = Ladder_Default;		if (dialog->GetItemState (id_left_order))			ladder = Ladder_Left;		if (dialog->GetItemState (id_right_order))			ladder = Ladder_Right;		P->SetLadderType (ladder);		Changed = TRUE;	}	TheApp->DestroyDialog();	// Restore preview dialog	TheApp->SetDialog (oldDlg);#ifdef Windows	// Ensure preview dialog appears to be modal	::SetFocus (GetHandle ());	::EnableWindow (_hWndFrame, FALSE);#endif	return (Changed);}*///------------------------------------------------------------------------------BOOL VPrintTreeDialog::DoTreesPerPage (){	BOOL state;		Changed = FALSE;		// Store current dialog	VDialogPtr oldDlg = this;		// Create Trees Per Page dialog	VDialogPtr dialog = new VDialog;	TheApp->CreateDialog (dialog, id_layout_dialog, TRUE);			// Tree arrangment on page	dialog->CheckRadioButton (id_left_right, id_top_bottom, arrangementItem);	dialog->EnableItem (id_left_right, BOOL (rows > 1 && cols > 1));	dialog->EnableItem (id_top_bottom, BOOL (rows > 1 && cols > 1));		// draw names?		dialog->SetItemState (id_shownames, fDrawTreeNames);				// Initialise grid display with current values	ControlTool c = dialog->GetControl (id_grid);	::SetControlMaximum (c, rows);	::SetControlMinimum (c, cols);	dialog->SetItemInt (id_rows, rows);	dialog->SetItemInt (id_cols, cols);	dialog->SetItemInt (id_total, rows * cols);								// Keep track of user's current values	int rr;	int cc;				dialog->Show ();			short item;		do		{			item = TheApp->DialogItemHit();			switch (item)			{							case id_grid:					ControlTool c = dialog->GetControl (id_grid);					rr = GetControlMaximum (c);					cc = GetControlMinimum (c);					// Update display of current values					dialog->SetItemInt (id_rows, rr);					dialog->SetItemInt (id_cols, cc);					dialog->SetItemInt (id_total, rr * cc);										// Enable arrangment buttons only if relevant					dialog->EnableItem (id_left_right, BOOL (rr > 1 && cc > 1));					dialog->EnableItem (id_top_bottom, BOOL (rr > 1 && cc > 1));					break;									case id_left_right:				case id_top_bottom:					dialog->CheckRadioButton (id_left_right, id_top_bottom, item);					break;									case id_shownames:					state =  dialog->GetItemState (item);					dialog->SetItemState (item, !state);										break;														default:					break;			}		} while (item > cancel);			// process user's choices here	if (item == ok)	{		fDrawTreeNames = dialog->GetItemState (id_shownames);		fTreeStyle.SetDrawName (fDrawTreeNames);		c = dialog->GetControl (id_grid);		rows = ::GetControlMaximum (c);		cols = ::GetControlMinimum (c);				// How shall we draw the trees, left-to-right or top-to-bottom?		(dialog->GetItemState (id_left_right) ? arrangementItem = id_left_right			: arrangementItem = id_top_bottom);				// Update display...		int n = rows * cols;				SetNumPages (((int)fTreesFile->GetTrees (true) - 1) / n + 1);				Changed = TRUE;		}			TheApp->DestroyDialog();			// Restore dialog	TheApp->SetDialog (oldDlg);		return (Changed);}/*//------------------------------------------------------------------------------// Handle the user clicking on the four tree style buttonsBOOL VPrintTreeDialog::DoTreeStyle (int item){	Changed = FALSE;		if (item != treeItem)	{		SetItemState (treeItem, FALSE);		SetItemState (item, TRUE);		treeItem = item;				switch (item)		{			case id_radialtree:				TreeStyle = TreeStyle |= TS_RADIAL;				break;			case id_cladogram:				TreeStyle = TreeStyle & ~(TS_ANGLE | TS_PHYLOGRAM | TS_RADIAL);				TreeStyle |= TS_SLANT | TS_CLADOGRAM;				break;			case id_rectangle:				TreeStyle = TreeStyle & ~(TS_SLANT | TS_PHYLOGRAM | TS_RADIAL);				TreeStyle |= TS_ANGLE | TS_CLADOGRAM;				break;			case id_phylogram:				TreeStyle = TreeStyle & ~(TS_SLANT | TS_CLADOGRAM | TS_RADIAL);				TreeStyle |= TS_ANGLE | TS_PHYLOGRAM;				break;		}				// Update display...		Changed = TRUE;	}	return (Changed);}*///------------------------------------------------------------------------------// Set initial valuesvoid VPrintTreeDialog::Setup (TTreesFile* treesFile, const TTreeStyle& treeStyle){	fTreeStyle = treeStyle;	fTreesFile = treesFile;		// Pages	SetNumPages((int)fTreesFile->GetTrees (true));	/*	// Tree style	SetItemState (id_cladogram, TRUE);		// Disable phylogram button is no branch lengths	EnableItem (id_phylogram, P->IsSomeWithEdges ());	// Have we any internal labels	EnableItem (id_internals, P->IsInternalLabels ());	// Tree order	SavedLadder = P->GetLadderType ();	ladder = SavedLadder;	// Line width	SetItemState (id_1pt, TRUE);*/}