#include "TSList.h"TCounter TSListBlockInitializer::fCount;TMemBlocks* TSList::TSListElement::fMgr = NULL;void TSList::AddItem (TObject* item){		CHECK (item);    TSListElement* newElement = new TSListElement (item, fHead->fNext);    fHead->fNext = newElement;	fItems.Incr ();}void TSList::Copy (const TObject& list){	CHECK (Class () == list.Class ());	DeleteAll ();		TSListIteratorConst& iteratorConst = ((TSListIteratorConst&)((const TSList&)list).IteratorConst ());	const TObject* item = NULL;	for (iteratorConst.FirstItem (); iteratorConst.CurItem (item); iteratorConst.NextItem ())		AddItem (*item);	delete &iteratorConst;}bool TSList::CurItem (TObject*& item){	if (CurItem ())	{		item = fCurItem->fData;		return (true);	}	return (false);}bool TSList::CurItem (const TObject*& item) const{	if (CurItem ())	{		item = fCurItem->fData;		return (true);	}	return (false);}void TSList::DetachItem (TObject*& item){    if (fHead->fNext != fTail)    {    	if (fCurItem == fHead->fNext)    		fCurItem = fCurItem->fNext;    	    	TSListElement* element = fHead->fNext;    	fHead->fNext = element->fNext;    	item = element->fData;    	delete element;    	fItems.Decr ();    }}bool TSList::FirstItem (void) const{	((TSList*)this)->fCurItem = fHead->fNext;	return (CurItem ());}bool TSList::FirstItem (TObject*& item){	fCurItem = fHead->fNext;	return (CurItem (item));}bool TSList::FirstItem (const TObject*& item) const{	((TSList*)this)->fCurItem = fHead->fNext;	return (CurItem (item));}bool TSList::NextItem (void) const{	((TSList*)this)->fCurItem = fCurItem->fNext;	return (CurItem ());}bool TSList::NextItem (TObject*& item){	fCurItem = fCurItem->fNext;	return (CurItem (item));}bool TSList::NextItem (const TObject*& item) const{	((TSList*)this)->fCurItem = fCurItem->fNext;	return (CurItem (item));}TSList& TSList::operator = (const TSList& list){	Copy (list);	return (*this);}     TSList::TSList (void) :        fHeadEntry (NULL, &fTailEntry ),        fTailEntry (NULL, &fTailEntry ),        fHead (&fHeadEntry),        fTail (&fTailEntry),         TContainer (){	fCurItem = fHead;}     TSList::TSList (const TSList& list) :        fHeadEntry (NULL, &fTailEntry ),        fTailEntry (NULL, &fTailEntry ),        fHead (&fHeadEntry),        fTail (&fTailEntry),         TContainer (list){	fCurItem = fHead;	CHECK_ (0); // need way of copying ??}TSList::~TSList (void){       	DeleteAll ();}     TSListBlockInitializer::TSListBlockInitializer (void){	if (fCount.GetCount () == 0)		TSList::TSListElement::fMgr = new TMemBlocks (sizeof(TSList::TSListElement), 20);	fCount.Incr ();}TSListBlockInitializer::~TSListBlockInitializer (void){    fCount.Decr();    if (fCount.GetCount () == 0)    {        delete TSList::TSListElement::fMgr;        TSList::TSListElement::fMgr = NULL;    }}void* TSList::TSListElement::operator new (size_t sz){	CHECK (fMgr);	return (fMgr->Allocate (sz));}void TSList::TSListElement::operator delete (void* b){	CHECK (fMgr);	fMgr->Free (b);}	            TSList::TSListElement::TSListElement (TObject* d, TSList::TSListElement* n){	fData = d;	fNext = n;}bool TSListIterator::CurItem (TObject*& item) const{	if (CurItem())	{		item = fCurItem->fData;		return (true);	}	return (false);}bool TSListIterator::FirstItem (void){	fCurItem = fContainer.fHead->fNext;	return (CurItem ());}bool TSListIterator::FirstItem (TObject*& item){	fCurItem = fContainer.fHead->fNext;	return (CurItem (item));}bool TSListIterator::NextItem (void){	fCurItem = fCurItem->fNext;	return (CurItem ());}bool TSListIterator::NextItem (TObject*& item){	fCurItem = fCurItem->fNext;	return (CurItem (item));}TSListIterator::TSListIterator (TSList& list)	: fContainer (list){	fCurItem = list.fCurItem;}TSListIterator::TSListIterator (const TSListIterator& iterator)	: fContainer (iterator.fContainer){	fCurItem = iterator.fCurItem;}TSListIterator::~TSListIterator (void){}bool TSListIteratorConst::CurItem (const TObject*& item) const{	if (CurItem())	{		item = fCurItem->fData;		return (true);	}	return (false);}bool TSListIteratorConst::FirstItem (void){	fCurItem = fContainer.fHead->fNext;	return (CurItem ());}bool TSListIteratorConst::FirstItem (const TObject*& item){	fCurItem = fContainer.fHead->fNext;	return (CurItem (item));}bool TSListIteratorConst::NextItem (void){	fCurItem = fCurItem->fNext;	return (CurItem( ));}bool TSListIteratorConst::NextItem (const TObject*& item){	fCurItem = fCurItem->fNext;	return (CurItem (item));}TSListIteratorConst::TSListIteratorConst (const TSList& list)	: fContainer (list){	fCurItem = list.fCurItem;}TSListIteratorConst::TSListIteratorConst (const TSListIterator& iterator)	: fContainer (iterator.fContainer){	fCurItem = iterator.fCurItem;}TSListIteratorConst::TSListIteratorConst (const TSListIteratorConst& iterator)	: fContainer (iterator.fContainer){	fCurItem = iterator.fCurItem;}TSListIteratorConst::~TSListIteratorConst (void){}