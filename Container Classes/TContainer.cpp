#include "TContainer.h"void TContainer::DeleteAll (void){	while (!IsEmpty ())		DeleteItem ();}void TContainer::DeleteItem (void){	TObject* item = NULL;	DetachItem (item);	delete item;}bool TContainer::FindItem (const TObject& toFind) const{	const TObject* item = NULL;	for (FirstItem (); CurItem (item); NextItem ())	{		if (*item == toFind)			return (true);	}	return (false);}bool TContainer::FindItem (const TObject& toFind, TObject*& item){	for (FirstItem (); CurItem (item); NextItem ())	{		if (*item == toFind)			return (true);	}	return (false);}bool TContainer::FindItem (const TObject& toFind, const TObject*& item) const{	for (FirstItem (); CurItem (item); NextItem ())	{		if (*item == toFind)			return (true);	}	return (false);}void TContainer::ForEach (IterFuncType actionPtr, void* paramListPtr){        TContainerIterator& containerIterator = Iterator ();    TObject* curItem = NULL;    for (containerIterator.FirstItem (); containerIterator.CurItem (curItem); containerIterator.NextItem ())        curItem->ForEach (actionPtr, paramListPtr);    delete &containerIterator;}bool TContainer::IsEqual (const TObject& obj) const{	CHECK (Class () == obj.Class ());		const TContainer& container = (const TContainer&) obj;		if (GetItems () != container.GetItems ())		return (false);			bool isequal = true;	TContainerIteratorConst& thisIterator = IteratorConst ();    TContainerIteratorConst& containerIterator = container.IteratorConst ();		const TObject* thisItem = NULL;	const TObject* containerItem = NULL;	for (thisIterator.FirstItem (), containerIterator.FirstItem ();thisIterator.CurItem (thisItem) && containerIterator.CurItem (containerItem);thisIterator.NextItem (), containerIterator.NextItem ())    {    	if (*thisItem != *containerItem)    	{    		isequal = false;    		break;    	}    }        if ((thisIterator.CurItem () && !containerIterator.CurItem ()) || (!thisIterator.CurItem () && containerIterator.CurItem ()))    	isequal = false;    	    delete &thisIterator;    delete &containerIterator;    return (isequal);}bool TContainer::GetIthItem (const unsigned int i, TObject*& item){	if (GetIthItem (i))	{		TContainerIterator& iterator = Iterator ();		unsigned int count = 1;		iterator.FirstItem ();		while (count++ < i)			iterator.NextItem ();		CHECK_ (iterator.CurItem ());			return (iterator.CurItem (item));	}	return (false);}bool TContainer::GetIthItem (const unsigned int i, const TObject*& item) const{	if (GetIthItem (i))	{		TContainerIteratorConst& iteratorConst = IteratorConst ();		unsigned int count = 1;		iteratorConst.FirstItem ();		while (count++ < i)			iteratorConst.NextItem ();		CHECK_ (iteratorConst.CurItem ());			return (iteratorConst.CurItem (item));	}	return (false);}static void getHashValue (TObject& object, void* valPtr ){    HashValue* val = (HashValue*)valPtr;    *val += object.Hash ();}HashValue TContainer::Hash (void) const{    HashValue val = 0;    ((TContainer*)this)->ForEach (getHashValue, &val);    return (val);}TContainer::TContainer (void)	:	fItems (){}TContainer::TContainer (const TContainer& container)	:	fItems (){}TContainer::~TContainer (void){}ostream& TContainer::Write (ostream& o) const{	TContainerIteratorConst& thisIterator = IteratorConst ();		const TObject* item = NULL;	for (thisIterator.FirstItem (); thisIterator.CurItem (item); thisIterator.NextItem ())		o << *item << EOLN;		delete &thisIterator;	return (o);}