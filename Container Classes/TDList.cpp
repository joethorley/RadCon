#include "TDList.h"TCounter TDListBlockInitializer::fCount;TMemBlocks* TDList::TDListElement::fMgr = NULL;// if direction == true adds item after element// if direction == false adds item before element// (where the head occurs before the tail)void TDList::addItem (TObject* item, TDListElement* element, const bool direction){	CHECK_ (item != NULL && element != NULL && element != fHead && element != fTail);	TDListElement* newElement = NULL;	if (direction) // adds item after element	{ 		newElement = new TDListElement (item, element, element->fNext);		element->fNext->fPrev = newElement;		element->fNext = newElement;	}	else // adds item before element	{		newElement = new TDListElement (item, element->fPrev, element);		element->fPrev->fNext = newElement;		element->fPrev = newElement;	}	fItems.Incr ();}// if direction == true adds item at tail// if direction == false adds item at headvoid TDList::AddItem (TObject* item, const bool direction){	CHECK_ (item != NULL);		TDListElement* newElement;	if (direction) // adds item at tail	{ 	    newElement = new TDListElement (item, fTail->fPrev, fTail);	    fTail->fPrev->fNext = newElement;	    fTail->fPrev = newElement;	}	else // adds item at head	{ 	    newElement = new TDListElement (item, fHead, fHead->fNext);	    fHead->fNext->fPrev = newElement;	    fHead->fNext = newElement;	}	fItems.Incr ();}void TDList::Copy (const TObject& obj){	CHECK_ (Class () == obj.Class ());		const TDList& dList = (const TDList&)obj;		DeleteAll ();	const TObject* item;	TDListIteratorConst& iteratorConst = ((TDListIteratorConst&)dList.IteratorConst ());	for (iteratorConst.FirstItem (); iteratorConst.CurItem (item); iteratorConst.NextItem ())		AddItem (*item);	delete &iteratorConst;}bool TDList::CurItem (TObject*& item){	if (CurItem ())	{		item = fCurItem->fData;		return (true);	}	return (false);}bool TDList::CurItem (const TObject*& item) const{	if (CurItem ())	{		item = fCurItem->fData;		return (true);	}	return (false);}void TDList::DeleteCurItem (void){	TObject* item = NULL;	DetachCurItem (item);	delete item;}void TDList::DeleteItem (const bool direction){	TObject* item = NULL;	DetachItem (item, direction);	delete item;}void TDList::DetachItem (TObject*& item, const bool direction){	if (direction) //detach from tail	{   	    if (fTail->fPrev->fData != NULL ) 	    	detachItem(item, fTail->fPrev);	}	else  // detach from head	{	    if (fHead->fNext->fData != NULL )	    	detachItem(item,fHead->fNext);	}}void TDList::detachItem (TObject*& item, TDListElement* element){	CHECK_ (element != NULL && element->fData != NULL && element != fHead && element != fTail);	if (fCurItem == element)		fCurItem = fCurItem->fNext;			element->fPrev->fNext = element->fNext;	element->fNext->fPrev = element->fPrev;	item = element->fData;	delete element;	fItems.Decr ();}bool TDList::FirstItem (void) const{	((TDList*)this)->fCurItem = fHead->fNext;	return (CurItem ());}bool TDList::FirstItem (TObject*& item){	fCurItem = fHead->fNext;	return (CurItem (item));}bool TDList::FirstItem (const TObject*& item) const{	((TDList*)this)->fCurItem = fHead->fNext;	return (CurItem (item));}bool TDList::LastItem (void) const{	((TDList*)this)->fCurItem = fTail->fPrev;	return (CurItem ());}bool TDList::LastItem (TObject*& item){	fCurItem = fTail->fPrev;	return (CurItem (item));}bool TDList::LastItem (const TObject*& item) const{	((TDList*)this)->fCurItem = fTail->fPrev;	return (CurItem (item));}bool TDList::NextItem (void) const{	((TDList*)this)->fCurItem = fCurItem->fNext;	return (CurItem ());}bool TDList::NextItem (TObject*& item){	fCurItem = fCurItem->fNext;	return (CurItem (item));}bool TDList::NextItem (const TObject*& item) const{	((TDList*)this)->fCurItem = fCurItem->fNext;	return (CurItem (item));}TDList& TDList::operator = (const TDList& dList){	DeleteAll ();	const TObject* item;	TDListIteratorConst& iteratorConst = (TDListIteratorConst&)dList.IteratorConst ();	for (iteratorConst.FirstItem (); iteratorConst.CurItem (item); iteratorConst.NextItem ())		AddItem (*item);	delete &iteratorConst;	return (*this);}bool TDList::PrevItem (void) const{	((TDList*)this)->fCurItem = fCurItem->fPrev;	return (CurItem ());}bool TDList::PrevItem (TObject*& item){	fCurItem = fCurItem->fPrev;	return (CurItem (item));}bool TDList::PrevItem (const TObject*& item) const{	((TDList*)this)->fCurItem = fCurItem->fPrev;	return (CurItem (item));}     TDList::TDList (void) :        fHeadEntry (NULL, &fHeadEntry, &fTailEntry ),        fTailEntry(NULL, &fHeadEntry, &fTailEntry ),        fHead(&fHeadEntry),        fTail(&fTailEntry), TReversibleContainer (){	fCurItem = fHead;}     TDList::TDList (const TDList& dList) :        fHeadEntry (NULL, &fHeadEntry, &fTailEntry ),        fTailEntry (NULL, &fHeadEntry, &fTailEntry ),        fHead (&fHeadEntry),        fTail (&fTailEntry), TReversibleContainer (dList){	fCurItem = fHead;		const TObject* item;	TDListIteratorConst& iteratorConst = (TDListIteratorConst&)dList.IteratorConst ();	for (iteratorConst.FirstItem (); iteratorConst.CurItem (item); iteratorConst.NextItem ())		AddItem (*item);	delete &iteratorConst;}TDList::~TDList (void){       	DeleteAll ();}     TDListBlockInitializer::TDListBlockInitializer (void){	if (fCount.GetCount () == 0)		TDList::TDListElement::fMgr = new TMemBlocks (sizeof(TDList::TDListElement), 20);	fCount.Incr ();}TDListBlockInitializer::~TDListBlockInitializer (void){    fCount.Decr();    if (fCount.GetCount () == 0)    {        delete TDList::TDListElement::fMgr;        TDList::TDListElement::fMgr = NULL;    }}void* TDList::TDListElement::operator new (size_t sz){	CHECK_ (fMgr != NULL);	return (fMgr->Allocate (sz));}void TDList::TDListElement::operator delete (void* b){	CHECK_ (fMgr != NULL);	fMgr->Free (b);}TDList::TDListElement::TDListElement (TObject* d, TDList::TDListElement* p, TDList::TDListElement* n){	fData = d;	fPrev = p;	fNext = n;}bool TDListIterator::CurItem (TObject*& item) const{	if (CurItem())	{		item = fCurItem->fData;		return (true);	}	return (false);}bool TDListIterator::FirstItem (void){	fCurItem = fContainer.fHead->fNext;	return (CurItem ());}bool TDListIterator::FirstItem (TObject*& item){	fCurItem = fContainer.fHead->fNext;	return (CurItem (item));}bool TDListIterator::LastItem (void){	fCurItem = fContainer.fTail->fPrev;	return (CurItem ());}bool TDListIterator::LastItem (TObject*& item){	fCurItem = fContainer.fTail->fPrev;	return (CurItem (item));}bool TDListIterator::NextItem (void){	fCurItem = fCurItem->fNext;	return (CurItem ());}bool TDListIterator::NextItem (TObject*& item){	fCurItem = fCurItem->fNext;	return (CurItem (item));}bool TDListIterator::PrevItem (void){	fCurItem = fCurItem->fPrev;	return (CurItem ());}bool TDListIterator::PrevItem (TObject*& item){	fCurItem = fCurItem->fPrev;	return (CurItem (item));}TDListIterator::TDListIterator (TDList& list)	:	fContainer (list){	fCurItem = list.fCurItem;}TDListIterator::TDListIterator (const TDListIterator& iterator)	: fContainer (iterator.fContainer){	fCurItem = iterator.fCurItem;}TDListIterator::~TDListIterator (void){}bool TDListIteratorConst::CurItem (const TObject*& item) const{	if (CurItem())	{		item = fCurItem->fData;		return (true);	}	return (false);}bool TDListIteratorConst::FirstItem (void){	fCurItem = fContainer.fHead->fNext;	return (CurItem ());}bool TDListIteratorConst::FirstItem (const TObject*& item){	fCurItem = fContainer.fHead->fNext;	return (CurItem (item));}bool TDListIteratorConst::LastItem (void){	fCurItem = fContainer.fTail->fPrev;	return (CurItem ());}bool TDListIteratorConst::LastItem (const TObject*& item){	fCurItem = fContainer.fTail->fPrev;	return (CurItem (item));}bool TDListIteratorConst::NextItem (void){	fCurItem = fCurItem->fNext;	return (CurItem( ));}bool TDListIteratorConst::NextItem (const TObject*& item){	fCurItem = fCurItem->fNext;	return (CurItem (item));}bool TDListIteratorConst::PrevItem (void){		fCurItem = fCurItem->fPrev;		return (CurItem ());}bool TDListIteratorConst::PrevItem (const TObject*& item){	fCurItem = fCurItem->fPrev;	return (CurItem (item));}TDListIteratorConst::TDListIteratorConst (const TDList& list)	:	fContainer (list){	fCurItem = list.fCurItem;}TDListIteratorConst::TDListIteratorConst (const TDListIterator& iterator)	: fContainer (iterator.fContainer){	fCurItem = iterator.fCurItem;}TDListIteratorConst::TDListIteratorConst (const TDListIteratorConst& iterator)	: fContainer (iterator.fContainer){	fCurItem = iterator.fCurItem;}TDListIteratorConst::~TDListIteratorConst (void){}