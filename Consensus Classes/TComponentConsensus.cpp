#include "TComponentConsensus.h"extern BOOL gAborted;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TComponentConsensus::Consensus (void){	if (!fSourceTreesBlock->GetClusterList ())	{		fClusterHashTable = new TClusterHashTable (fConsensusLeafSet);		fClusterList = new TClusterList (fConsensusLeafSet);		TConsensusTreesFile::Consensus ();				if (!gAborted)		{			const TCluster* cluster= NULL;			for (fClusterHashTable->FirstCluster (); ((const TClusterHashTable*)fClusterHashTable)->CurCluster (cluster); fClusterHashTable->NextCluster ())			{				TCluster adjustedCluster (*cluster, cluster->GetWeight () / fWeightsDone * (double)kDefaultWeight);				fClusterList->AddCluster (adjustedCluster); 			}			fSourceTreesBlock->SetClusterList (fClusterList);		}		else		{			delete fClusterList;			fClusterList = NULL;		}		delete (fClusterHashTable);		fClusterHashTable = NULL;	}	else	{		fClusterList = (TClusterList*)fSourceTreesBlock->GetClusterList (); // JLT 010412 added cast		fTreesDone = fSourceTrees;		fWeightsDone = fSourceWeights;	}}TComponentConsensus::TComponentConsensus (const TSourceTreesFile* sourceTreesFile) 	: TIntersectionConsensus (sourceTreesFile) { 	fClusterHashTable = NULL;	fClusterList = NULL;}TComponentConsensus::TComponentConsensus (const TComponentConsensus& componentConsensus)	: TIntersectionConsensus (componentConsensus){	CHECK_ (0);}void TComponentConsensus::traverseAddTree (const TTreeNode* n){	if (n)	{		traverseAddTree (n->GetChild ());		traverseAddTree (n->GetSibling ());				if (!n->IsLeaf () && !n->IsRoot ())			fClusterHashTable->AddCluster (*n);	}}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TStrictComponentConsensus::Consensus (void){	CHECK (fConsensusTree.IsStarTree () );	CHECK (IsRooted () ? fConsensusTree.IsRooted () : !fConsensusTree.IsRooted ());	TComponentConsensus::Consensus ();		if (!gAborted)	{		const TCluster* cluster = NULL; // JLT 010412 made const		for (fClusterList->FirstCluster (); ((const TStrictComponentConsensus*)this)->fClusterList->CurCluster (cluster) && cluster->GetWeight () == kDefaultWeight; fClusterList->NextCluster ())			fConsensusTree.AddToThis (*cluster);			fClusterList = NULL;		}		fConsensusTree.SetName ("STRICT_COMPONENT");	fConsensusTree.SetTreeType (kStrictCladistic);								fTreesBlock->AddTree (fConsensusTree);}TStrictComponentConsensus::TStrictComponentConsensus (const TSourceTreesFile* sourceTreesFile) 	: TComponentConsensus (sourceTreesFile) { }TStrictComponentConsensus::TStrictComponentConsensus (const TStrictComponentConsensus& strictComponentConsensus) 	: TComponentConsensus (strictComponentConsensus) { 	CHECK_ (0);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TMajorityRuleComponentConsensus::Consensus (void){	CHECK (fConsensusTree.IsStarTree () );	CHECK (IsRooted () ? fConsensusTree.IsRooted () : !fConsensusTree.IsRooted ());	TComponentConsensus::Consensus ();		if (!gAborted)	{		const TCluster* cluster = NULL; // JLT 010412 made const		for (fClusterList->FirstCluster (); ((const TMajorityRuleComponentConsensus*)this)->fClusterList->CurCluster (cluster) && (((double)kDefaultWeight / (double)2) < cluster->GetWeight ()); fClusterList->NextCluster ())			fConsensusTree.AddToThis (*cluster);		if (IsFlag (TMAJORITYRULECOMPONENTCONSENSUS_FLAG_MINORITYCOMPATIBLECOMPONENTS))		{			while (fClusterList->CurCluster (cluster) && !fConsensusTree.IsBinary ())			{				double weight = cluster->GetWeight ();				TClusterList clusterList (fClusterList->GetLeafSet ()); // stores all clusters that are compatible with the tree and of the same weight in a TClusterList 				for (; fClusterList->CurCluster (cluster) && cluster->GetWeight () == weight; fClusterList->NextCluster ())					if (fConsensusTree.IsCompatible (*cluster))						clusterList.AddCluster (*cluster);						const TCluster* item = NULL; // JLT 010412 made const				for (clusterList.FirstCluster (); clusterList.CurCluster (item); clusterList.NextCluster ())					if (clusterList.IsCompatible (*item)) // adds each stored cluster to the consensus tree only if it is compatible with all the others alternative						fConsensusTree.AddToThis (*item); // this prevents arbitrary choice of minority compatible components depending on the order encountered					}		}		fClusterList = NULL;	}	fConsensusTree.SetTreeType (kMajorityRuleCladistic);	fConsensusTree.SetWeightsInternals ();		fConsensusTree.SetName ("MAJORITY_RULE_COMPONENT");							fTreesBlock->AddTree (fConsensusTree);}TMajorityRuleComponentConsensus::TMajorityRuleComponentConsensus (const TSourceTreesFile* sourceTreesFile, const bool minorityCompatibleComponents, const bool showDifferences) 	: TComponentConsensus (sourceTreesFile) { 	SetFlag (TMAJORITYRULECOMPONENTCONSENSUS_FLAG_MINORITYCOMPATIBLECOMPONENTS, minorityCompatibleComponents);	SetFlag (TMAJORITYRULECOMPONENTCONSENSUS_FLAG_SHOWDIFFERENCES, showDifferences);}TMajorityRuleComponentConsensus::TMajorityRuleComponentConsensus (const TMajorityRuleComponentConsensus& majorityRuleComponentConsensus)	: TComponentConsensus (majorityRuleComponentConsensus) { 	CHECK_ (0);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TSemiStrictComponentConsensus::Consensus (void){	CHECK (fConsensusTree.IsStarTree () );	CHECK (IsRooted () ? fConsensusTree.IsRooted () : !fConsensusTree.IsRooted ());	TComponentConsensus::Consensus ();		if (!gAborted)	{		const TCluster* cluster = NULL; // JLT 010412 made const		for (fClusterList->FirstCluster (); ((const TSemiStrictComponentConsensus*)this)->fClusterList->CurCluster (cluster) && (kDefaultWeight == cluster->GetWeight ()); fClusterList->NextCluster ())			fConsensusTree.AddToThis (*cluster);		for (;((const TSemiStrictComponentConsensus*)this)->fClusterList->CurCluster (cluster); fClusterList->NextCluster ())			if (fClusterList->IsCompatible (*cluster))				fConsensusTree.AddToThis (*cluster);		fClusterList = NULL;		}			fConsensusTree.SetWeightsInternals ();	fConsensusTree.SetName ("SEMISTRICT_COMPONENT_CTREE");	fConsensusTree.SetTreeType (kSemiStrictCladistic);				fTreesBlock->AddTree (fConsensusTree);}TSemiStrictComponentConsensus::TSemiStrictComponentConsensus (const TSourceTreesFile* sourceTreesFile) 	: TComponentConsensus (sourceTreesFile) { }TSemiStrictComponentConsensus::TSemiStrictComponentConsensus (const TSemiStrictComponentConsensus& semiStrictComponentConsensus)	: TComponentConsensus (semiStrictComponentConsensus) { 	CHECK_ (0);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif