#include "TMRPConsensus.h"#include "TTabString.h"#include "TTime.h"#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifextern BOOL gAborted;void TMRPConsensus::addTree (void){	CHECK_ (IsRooted () || !fCurSourceTree.IsBinaryRoot ());	CHECK_ (fostream);		*fostream << "[";	TString name ("tree");	name.AddToThis (fTreesDone + 1);	name += '_';	name += fCurSourceTree.GetName ();	*fostream << name;	*fostream << "]" << EOLN;		if (IsRooted () ? 1 < fCurSourceTree.InternalBranches () : fCurSourceTree.InternalBranches ())	{		if (IsFlag (TMRPCONSENSUS_FLAG_COMPONENTS))		{			TSplitSet splitSet (IsRooted ());			splitSetTraverseTree (fCurSourceTree.GetRoot (), fCurSourceTree, splitSet);						fCharSets << "charset " << name.Array () << "=" << fCharactersDone + 1 << "-";						const TSplit* split;			for (bool b = splitSet.FirstSplit (split); b; b = splitSet.NextSplit (split))			{				++fCharactersDone;				split->WriteAsCharacter (*fostream, fConsensusLeafSet);				*fostream << EOLN;			}						fCharSets << fCharactersDone << ";" << EOLN;		}		else		{			fQuartetSet = new TQuartetSet (fConsensusLeafSet.GetLeaves (), false);			fDistanceMatrix = new TDistanceMatrix (fConsensusLeafSet.GetLeaves ());			fCurSourceTree.DistanceMatrix (*fDistanceMatrix);									fCharSets << "charset " << name.Array () << "=" << fCharactersDone + 1 << "-";						for (bool b = fQuartetSet->FirstPartition (); !gAborted && b; b = fQuartetSet->NextPartition ())			{								fQuartetSet->AddQuartets (*fDistanceMatrix);								const TQuartet* quartet;				for (fQuartetSet->FirstQuartetCurPartition (); fQuartetSet->CurQuartetCurPartition (quartet); fQuartetSet->NextQuartetCurPartition ())				{					if ((!IsRooted () || quartet->IsLeaf (1)) && quartet->IsResolved ())					{						++fCharactersDone;						quartet->WriteAsCharacter (*fostream, fConsensusLeafSet);						*fostream << EOLN;					}									}			}			fCharSets << fCharactersDone << ";" << EOLN;						delete (fQuartetSet);			fQuartetSet = NULL;			delete (fDistanceMatrix);			fDistanceMatrix = NULL;						MonitorDialog->SetItemText (4, (char*)GetProgressBarName ()); // these two added in...			MonitorDialog->SetMeter (fSourceTrees); //		}		}	else	{		*fostream << "[ " << name.Array () << " contributes no 'characters' to the matrix as it is unresolved]"  << EOLN;		fCharSets << "[ charset " << name.Array () << " is undefined as its respective tree contributes no 'characters' to the matrix ]" << EOLN;	}}void TMRPConsensus::Consensus (void){	CHECK_ (fostream);	CHECK_ (fSourceCharacters);	CHECK_ (!fCharactersDone);			*fostream << "#nexus" << EOLN;	*fostream << EOLN;	*fostream << "[!" << Time () << EOLN;	*fostream << "MRP " << (IsFlag (TMRPCONSENSUS_FLAG_COMPONENTS) ? "component " : (IsRooted () ? "triplet " : "quartet ")) << "coding " << (IsFlag (TMRPCONSENSUS_FLAG_PURVISCODING) ? "with purvis modification " : "") << "of " << fSourceTrees << ' ' << (IsRooted () ? "rooted " : "unrooted ") << (fTreesDone == 1 ? "tree " : "trees ") << "from '" << fName.Array () << "']" << EOLN;	fTaxaBlock->WriteAsNexus (*fostream);	*fostream << EOLN;		*fostream << "begin characters;" << EOLN;	*fostream << "\tdimensions nchar=" << fSourceCharacters << ";" << EOLN;	*fostream << "\tformat symbols=\"01\" missing=? transpose nolabels;" << EOLN;	*fostream << "\tmatrix" << EOLN;			TSuperTreeConsensus::Consensus ();		CHECK_ (fCharactersDone == fSourceCharacters);		if (!gAborted)	{		*fostream << "\t;" << EOLN;		*fostream << "end;" << EOLN;		*fostream << EOLN;		*fostream << "begin assumptions;" << EOLN;		*fostream << "[character sets corresponding to each source tree]" << EOLN;		string str = fCharSets.str ();		char* buf = (char *)str.c_str ();		*fostream << buf;		*fostream << "end;";	}}void TMRPConsensus::SetFile (ostream& o, const TString& name) { 	fostream = &o; 	fName = name;}void TMRPConsensus::splitSetTraverseTree (const TTreeNode* treeNode, const TTree& tree, TSplitSet& splitSet){	if (treeNode)	{		splitSetTraverseTree (treeNode->GetChild (), tree, splitSet);		splitSetTraverseTree (treeNode->GetSibling (), tree, splitSet);				if (!treeNode->IsLeaf () && !treeNode->IsRoot () && (!IsRooted () || !treeNode->GetAnc ()->IsRoot ()))		{			TSplit split (*treeNode, tree.GetLeafSet (), IsRooted ());								CHECK_ (split.GetWeight () == kDefaultWeight);			if (IsFlag (TMRPCONSENSUS_FLAG_PURVISCODING))			{				TLeafSet leafSet;				treeNode->GetAnc ()->Complement (leafSet);				leafSet -= 1;				split.PruneLeaves (leafSet);			}			CHECK_ (split.IsInformative ());			splitSet.AddSplit (split);		}	}}void TMRPConsensus::nextTree (void){	TSuperTreeConsensus::nextTree ();	if (IsRooted ())		fCurSourceTree.GraftLeafAsOutgroup (1);}bool TMRPConsensus::CalcCharacters (void){	fSourceCharacters = (IsFlag (TMRPCONSENSUS_FLAG_COMPONENTS) ? fSourceTreesBlock->GetInternalBranches (true) : (IsRooted () ? fSourceTreesBlock->GetResolvedTriplets (true) : fSourceTreesBlock->GetResolvedQuartets (true)));	return ((double)fSourceCharacters * (double)fConsensusLeafSet.GetLeaves () < (double)kMaxMatrix);}TMRPConsensus::TMRPConsensus (const TSourceTreesFile* sourceTreesFile, const bool components, const bool purvisCoding)	: 	TSuperTreeConsensus (sourceTreesFile){	fostream = NULL;	CHECK_ (!purvisCoding || (components && IsRooted ()));	CHECK_ (fConsensusLeafSet.GetLeaves () + (IsRooted () ? 1 : 0) <= kMaxLeaves);				SetFlag (TMRPCONSENSUS_FLAG_COMPONENTS, components);	SetFlag (TMRPCONSENSUS_FLAG_PURVISCODING, purvisCoding);		if (IsRooted ())	{		fLeafMap.IncrMapping (1);						fConsensusLeafSet += fConsensusLeafSet.GetLeaves () + 1;		unsigned int i = 0;		TString name;		do		{			name = "mrp_outgroup";			if (1 < ++i)				name.AddToThis (i);					} while (fTaxaBlock->IsLeaf (name));		fTaxaBlock->InsertLeaf (name, 1);	}	fQuartetSet = NULL;	fSourceCharacters = 0;	fCharactersDone = 0;}TMRPConsensus::TMRPConsensus (const TMRPConsensus& mrpConsensus)	: 	TSuperTreeConsensus (mrpConsensus){	CHECK_ (0);}TMRPConsensus::~TMRPConsensus (void) { 	if (fQuartetSet)		delete (fQuartetSet);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif