// Notes from CPCON.PAS/*{ New algorithm for Adams-2 consensus, started 14 August 1991. }{ Revised algorithm based on better understanding of  Adams' method.  1. Adams tree A = star tree.  2. Traverse A in preorder.     (a) Each time a cluster c î , where |c| > 2, is			encountered, find the partition product  (PP)			of the partitions of c induced by         lub(c) in all T î P. This is done by         computing a running partition product when			going through each T î P.	  (b) Add the sets in the PP to A.	  (c) Continue preorder traversal.  Algorithm makes use of PartObj partition data structure  for finding the partition product of a set of partitions.*/#include "TAdamsConsensus.h"#include "DialogIDs.h"extern BOOL gAborted;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif// Process a single tree in the profile.//// 1. Find lub (workset).//// 2. Create PP by getting each immediate desc of//	     lub and intersecting with the previous PP.//void TAdamsConsensus::addTree (void){	const TTreeNode* n = fCurSourceTree.LUB (fPartition.GetLeafSet ());	fPartition.Setup ();	for (n = n->GetChild (); n; n = n->GetSibling ())		fPartition.PP (*n);}void TAdamsConsensus::Consensus (void){	CHECK_ (!fCount);		MonitorDialog = TheApp->CreateMonitor (dlgProgressBar);	MonitorDialog->Show ();		consensusTraverse (fConsensusTree.GetRoot (), MonitorDialog);	TheApp->DestroyDialog ();		fConsensusTree.SetName ("ADAMS");	fConsensusTree.SetTreeType (kStrictNestings);	fTreesBlock->AddTree (fConsensusTree);}void TAdamsConsensus::consensusTraverse (const TTreeNode* n, VMonitor* monitor){	CHECK_ (monitor);		if (n)	{		if (!n->IsLeaf () && n->GetLeaves () > 2)		{				TString name = "Adams Traversal ";			name.AddToThis (++fCount);			monitor->SetItemText (4, name.Array ());						fPartition.EnterSet (fConsensusLeafSet.GetLeaves (), *n);													fTreesDone = 0;			fWeightsDone = 0;			consensus (monitor);			if (!gAborted)			{	// Partition product has been calculated. Now				// use iterator to reconstruct Partition product as				// clusters, and add to consensus tree.				TLeafSet leafSet;				for (fPartition.FirstPart (); fPartition.CurPart (leafSet); fPartition.NextPart ())					if (1 < leafSet.GetLeaves () && leafSet != fConsensusTree.GetLeafSet ())						fConsensusTree.AddToThis (leafSet); //might this fuck up the current node being pointed at being moved...			}		}		if (!gAborted)		{			consensusTraverse (n->GetChild (), monitor);			consensusTraverse (n->GetSibling (), monitor);		}	}}TAdamsConsensus::TAdamsConsensus (const TSourceTreesFile* sourceTreesFile) 	: TIntersectionConsensus (sourceTreesFile){	CHECK_ (3 <= fSourceLeafSet.GetLeaves () && fSourceLeafSet.GetLeaves () <= 500);	CHECK_ (IsRooted ());}TAdamsConsensus::~TAdamsConsensus (void){}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif