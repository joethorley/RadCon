#include "TDecayAnalysis.h"#include "TTabString.h"#include "VMsg.h"#include "DialogIDs.h"extern BOOL gAborted;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifTDecayAnalysis::TDecayAnalysis (const TSourceTreesFile* sourceTreesFile)	:	TQuartetConsensus (sourceTreesFile),		fOStream (NULL),		fReadIn (NULL),		fReadLog (NULL),		fFuse (NULL),		fSplitSet (IsRooted ())				{	CHECK_ (fSourceLeafSet.GetLeaves () >= 4);	CHECK_ (fSourceLeafSet.GetLeaves () <= (IsRooted () ? 50: 25));		fLeafStability = new TArray<double> (fSourceLeafSet.GetLeaves (), 0);	fResolvedQuartets = 0;	fLength = 0;	fOutgroupLeafNumber = 0;	setAborted (false);	fBasicTrees = 0;}TDecayAnalysis::TDecayAnalysis (const TDecayAnalysis& decayAnalysis)	:	TQuartetConsensus (decayAnalysis),		fOStream (decayAnalysis.fOStream){	CHECK_ (0);}void TDecayAnalysis::averageQuartets (void){}void TDecayAnalysis::Consensus (void){	CHECK_ (IsTypeSet ());	if (IsInput ())	{	}	else	{				*fOStream << "#nexus" << EOLN;		*fOStream << EOLN;		*fOStream << "begin paup;" << EOLN;		*fOStream << "log file = " << fFileName << ".log start replace;" << EOLN; // need log file name same as old with new name!!	}		TQuartetConsensus::Consensus ();		if (IsInput ())	{			CHECK_ (fReadIn);				delete (fReadIn);		delete (fReadLog);				// moved from average quartets what if aborted ??		const unsigned long quartets = fQuartetSet.GetQuartets (true);		unsigned short leaves = fConsensusLeafSet.GetLeaves ();		for (unsigned short leaf = 1; leaf <= leaves; ++leaf)			fLeafStability->IthItemRef (leaf) = (fLeafStability->IthItemRef (leaf) / (double)quartets);		if (gAborted)			setAborted (true);	}	else	{		}}void TDecayAnalysis::Fuse (void){	CHECK_ (IsFuse ());		fFuse->Fuse (fSplitSet);	MonitorDialog = TheApp->CreateMonitor (dlgProgressText);	MonitorDialog->SetItemText (3, "0");	MonitorDialog->SetItemText (4, "Making Basic Tree");	MonitorDialog->Show ();	makeBasicForest ();	//		if (!gAborted)//		{		//			MonitorDialog->SetItemText (3, "0");//			MonitorDialog->SetItemText (4, "Making Derivative Trees");//			//			makeDerivativeForest ();//		}	TheApp->DestroyDialog ();}void TDecayAnalysis::makeBasicForest (void){	CHECK_ (!fSplitSet.IsEmpty ());//	CHECK_ (!fSplitItemSets);	CHECK_ (!fBasicTrees);//	fSplitSet.Sort (); assume sorted	//	fSplitItemSets = new TArray<TItemSet> (fSplitSet.GetSplits ());		TItemSet itemSet;	TLeafSet leafSet;	const TSplit* curSplit;	unsigned int curSplitNumber = 0;	for (fSplitSet.FirstSplit (); fSplitSet.CurSplit (curSplit); fSplitSet.NextSplit ())	{		if (!itemSet.IsItem (++curSplitNumber))		{			MonitorDialog->ProcessExternal ();				gAborted = MonitorDialog->HasAborted ();			if (gAborted)				return;												TString string;			string.AddToThis (++fBasicTrees);			MonitorDialog->SetItemText (3, string.Array ());				leafSet = curSplit->GetLeafSet ();			const TSplit* curSplit2;							TSplitSet splitSet (IsRooted ());			TSplitSetIteratorConst&	iterator = fSplitSet.IteratorConst ();			unsigned int i = 1;			for (iterator.FirstSplit (); iterator.CurSplit (curSplit2); iterator.NextSplit (), ++i)			{				if (leafSet.IsSubset (curSplit2->GetLeafSet ()))				{					if (leafSet == curSplit2->GetLeafSet ())						itemSet.AddToThis (i);					TSplit split (*curSplit2);					split.PruneLeaves (curSplit2->GetLeafSet () - leafSet);					if (split.IsInformative ())					{//						fSplitItemSets->IthItemRef (fBasicTrees) += i;						splitSet.AddSplit (split, true);					}				}			}						CHECK_ (IsRooted () ? fConsensusTree.IsRooted () : !fConsensusTree.IsRooted ());							fConsensusTree.StarTree (leafSet);			TLeafSet rootLeafSet;			rootLeafSet += fOutgroupLeafNumber;			TSplit baseSplit (leafSet - rootLeafSet, leafSet, IsRooted ()); // what about weight ??						fConsensusTree.AddToThis (baseSplit);						for (splitSet.FirstSplit (); splitSet.CurSplit (curSplit2); splitSet.NextSplit ())			{				fConsensusTree.AddToThis (*curSplit2);						}			fConsensusTree.PruneLeaf (fOutgroupLeafNumber);						TString name = "DDA";			name.AddToThis (fBasicTrees);			name.AddToThis ("_BASIC");										fConsensusTree.SetName (name);			fConsensusTree.SetTreeType (kDecayIndex); // might have to define new type!								fConsensusTree.SetWeightsInternals ();				fTreesBlock->AddTree (fConsensusTree);			//			TItemSet itemSet;//			itemSet += fBasicTrees;//			fTreeItemSets.IthItemRef (fBasicTrees) = itemSet;		}	}//	CHECK_ (fTreeItemSets.GetItems () == fTreesBlock->GetTrees ());	CHECK_ (itemSet.GetItems () == fSplitSet.GetSplits ());}bool TDecayAnalysis::getNextBackBone (TString& name, TString& backBone){	if (fReadIn->SetToWord ("constraints"))	{		name = fReadIn->GetNextWord ();		if (fReadIn->GetNextWord () == "backbone")		{			if (fReadIn->GetNextWord () == "=")			{				backBone = fReadIn->GetNextWord ();				return (!fReadIn->IsEOF ());			}		} 	}	return (false);}bool TDecayAnalysis::getNextLength (TString& name, unsigned int& length){	if (fReadLog->SetToWord ("constraint-tree"))	{		name = fReadLog->GetNextWord ();		// better to remove "" here!!		if (fReadLog->SetToWord ("found"))		{			if (fReadLog->GetNextWord () == "=")			{				TString number = fReadLog->GetNextWord ();				if (number.IsInteger ())				{					length = number.ToInteger ();					return (true);				}			}		}			}	return (false);}void TDecayAnalysis::storeQuartets (void) {	TString nexus;	if (IsInput ())	{		MonitorDialog->SetItemText (4, (char*)(IsRooted () ? "Reading Triplets From File" : "Reading Quartets from File")); // need to update // JLT 010412 added cast				MonitorDialog->SetMeter (fQuartetSet.GetQuartetsCurPartition ());		int quartetsDone = 0;		const TQuartet* quartet;		TString constraintName;		TString constraintBackbone;		unsigned int length;		TString nom;		// need to count quartets and have as backbone...what a		CHECK_ (!fResolvedQuartets); // ULONG_MAX 4294967295U // assume rooted // maxleaves = 100 = 161700 quartets		for (fQuartetSet.FirstQuartetCurPartition (); !gAborted && fQuartetSet.CurQuartetCurPartition (quartet); fQuartetSet.NextQuartetCurPartition ())		{					if (quartet->IsResolved ())			{				writeAsNexusNames (*quartet, nexus);					if (getNextBackBone (constraintName, constraintBackbone))				{					nom = "ddecay";					nom.AddToThis (++fResolvedQuartets);					if (nom != constraintName)					{						gAborted = true;						Message (MSG_ERROR, "Input error: Incorrect constraint name in PAUP input file");			  			*Log << EOLN << "Input Error: Incorrect constraint name in PAUP input file" << EOLN;					}					if (!gAborted && nexus != constraintBackbone)					{						gAborted = true;						Message (MSG_ERROR, "Input error: Incorrect backbone constraint in PAUP input file");			  			*Log << EOLN << "Input Error: Incorrect backbone constraint in PAUP input file" << EOLN;					}					if (!gAborted)					{						if (getNextLength (constraintName, length))						{							TString nom2 = "\"";							nom2 += nom;							nom2 += "\"";							if (nom2 != constraintName)							{								gAborted = true;								Message (MSG_ERROR, "Input error: Incorrect constraint name in PAUP log file");					  			*Log << EOLN << "Input Error: Incorrect constraint name in PAUP log file" << EOLN;							}							if (!gAborted && length <= fLength)							{								gAborted = true;								Message (MSG_ERROR, "Input error: Length in PAUP log file is less than or equal to length MPTs");					  			*Log << EOLN << "Input Error: Length in PAUP log file is less than or equal to length MPTs" << EOLN;							}							if (!gAborted)							{								length -= fLength;																					fLeafStability->IthItemRef (quartet->A ()) += length;								fLeafStability->IthItemRef (quartet->B ()) += length;								fLeafStability->IthItemRef (quartet->C ()) += length;								if (!IsRooted ())									fLeafStability->IthItemRef (quartet->D ()) += length;																if (IsFuse ())								{									TLeafSet leafSet  = quartet->GetLeafSet ();									if (IsRooted ())										leafSet += fOutgroupLeafNumber; 									TSplit split (quartet->LeafSet_InsideSet (quartet->GetQuartetType ().GetQuartetType ()), leafSet, IsRooted (), (double)length);									fFuse->AddSplit (split);									}							}						}						else						{							gAborted = true;							Message (MSG_ERROR, "Input error: Expecting a length in PAUP log file");				  			*Log << EOLN << "Input Error: Expecting a length in PAUP log file" << EOLN;						}					}				}				else				{					gAborted = true;					Message (MSG_ERROR, "Input error: Expecting a backbone constraint in PAUP input file");		  			*Log << EOLN << "Input Error: Expecting a backbone constraint in PAUP input file" << EOLN;				}				}			if (!gAborted)			{				MonitorDialog->UpdateMeter (++quartetsDone);				MonitorDialog->ProcessExternal ();				gAborted = MonitorDialog->HasAborted ();			}		}		if (!gAborted && getNextBackBone (constraintName, constraintBackbone))		{			gAborted = true;			Message (MSG_ERROR, "Input error: Too many backbone constraints in PAUP input file");			*Log << EOLN << "Input Error:  Too many backbone constraints in PAUP input file" << EOLN;		}		if (!gAborted && getNextLength (constraintName, length))		{			gAborted = true;			Message (MSG_ERROR, "Input error: Too many lengths in PAUP log file");			*Log << EOLN << "Input Error:  Too many lengths in PAUP log file" << EOLN;		}		CHECK_ (fResolvedQuartets < 161701);		CHECK_ (gAborted || quartetsDone == fQuartetSet.GetQuartetsCurPartition ());	} 	else	{		MonitorDialog->SetItemText (4, (char*)(IsRooted () ? "Writing Triplets to File" : "Writing Quartets to File")); // need to update // JLT 010412 added cast				MonitorDialog->SetMeter (fQuartetSet.GetQuartetsCurPartition ());		int quartetsDone = 0;		const TQuartet* quartet;		// need to count quartets and have as backbone...what a		CHECK_ (!fResolvedQuartets); // ULONG_MAX 4294967295U // assume rooted // maxleaves = 100 = 161700 quartets		for (fQuartetSet.FirstQuartetCurPartition (); !gAborted && fQuartetSet.CurQuartetCurPartition (quartet); fQuartetSet.NextQuartetCurPartition ())		{					if (quartet->IsResolved ())			{					*fOStream << "constraints ddecay" << ++fResolvedQuartets << " backbone = ";				writeAsNexusNames (*quartet, nexus);				*fOStream << nexus.Array () << EOLN;				fOStream->flush ();			}			MonitorDialog->UpdateMeter (++quartetsDone);			MonitorDialog->ProcessExternal ();			gAborted = MonitorDialog->HasAborted ();		}		CHECK_ (fResolvedQuartets < 161701);		CHECK_ (gAborted || quartetsDone == fQuartetSet.GetQuartetsCurPartition ());				MonitorDialog->SetItemText (4, "Writing Searches To File");		MonitorDialog->SetMeter (fResolvedQuartets);		*fOStream << "set autoclose;" << EOLN;		unsigned long int resolvedQuartets = 1;		quartetsDone = 0;		while (resolvedQuartets <= fResolvedQuartets && !gAborted)		{			*fOStream << (IsHeuristic () ? "hsearch" : "bandb") << " constraints = ddecay" << resolvedQuartets++ << " enforce converse " << fHConstraints << ";" << EOLN;			fOStream->flush ();			++quartetsDone;			MonitorDialog->UpdateMeter (++quartetsDone);			MonitorDialog->ProcessExternal ();			gAborted = MonitorDialog->HasAborted ();		}		*fOStream << "log stop;" << EOLN << "end;" << EOLN;	} } // to do pass string with heuristic constraintsvoid TDecayAnalysis::Output (ostream& o, const TString& outgroupLeaf, const TString& fileName, const bool heuristic, const TString& search) { 	CHECK_ (!IsTypeSet ());	CHECK_ (!fileName.IsNull ());	CHECK_ (!search.IsNull ());		fOutgroupLeaf = outgroupLeaf;	fFileName = fileName;	fOStream = &o;	setHeuristic (heuristic);	fHConstraints = search;} // set out file and all detailsvoid TDecayAnalysis::Input (istream& sin, istream& slog, const TString& outgroupLeaf, const TString& inFileName, const TString& logFileName, const unsigned int length, const bool fuse) { 	CHECK_ (!IsTypeSet ());	CHECK_ (!inFileName.IsNull ());	CHECK_ (!logFileName.IsNull ());	CHECK_ (!fuse || IsRooted ()); // need to do unrooted DDA but not yet			TLeafSet leafSet = fConsensusLeafSet;	if (IsRooted ())	{		fOutgroupLeafNumber = leafSet.GetLeaves () + 1;		leafSet += fOutgroupLeafNumber; 		fTaxaBlock->AddLeaf (outgroupLeaf, fOutgroupLeafNumber);	}	SetFlag (kFuse, fuse);	if (IsFuse ())		fFuse = new TFuse (leafSet, IsRooted ());	fOutgroupLeaf = outgroupLeaf;	fInFileName = inFileName;	fLogFileName = logFileName;	fLength = length;		fReadIn = new TReadFile (sin, inFileName);	fReadLog = new TReadFile (slog, logFileName);	fReadIn->SetWhiteSpace (" \n\t\r");	fReadLog->SetWhiteSpace (" \n\t\r");}ostream& TDecayAnalysis::WriteLeafStabilities (ostream& o) const{	TTabString tabString (kFileWidth);				tabString.SetTab (20);		tabString.SetNewLine ();				tabString.AddToThis ("Leaf");	tabString.AddToken ("LS(DI)");	tabString.SetNewLine ();	tabString.WriteToLog ();	tabString.SetNull (); // have to set null as memory allocation problems...			unsigned int i = 0;	TString string;	double averageLS = 0;		while (fConsensusLeafSet.IthLeaf (++i))	{		tabString.AddToken (fTaxaBlock->GetLeafName (fConsensusLeafSet.IthLeaf (i)));		string.SetNull ();		string.AddToThis ((float)fLeafStability->IthItemRef (i), 3);		tabString.AddToThis (string);		averageLS += fLeafStability->IthItemRef (i);		tabString.SetNewLine ();		tabString.WriteToLog ();		tabString.SetNull ();	}	tabString.AddToThis ("Average");	string.SetNull ();	string.AddToThis ((float)(averageLS / (double)fConsensusLeafSet.GetLeaves ()), 3);	tabString.AddToThis (string);	tabString.WriteToLog ();		return (o);}ostream& TDecayAnalysis::WriteAsTable (ostream& o) const{		*Log << EOLN;	if (IsAborted ())	{		*Log << EOLN << "Double Decay Analysis Aborted " << EOLN;		*Log << EOLN << "Displayed Splits are Correct but there may be more with Lower Decay Indices" << EOLN;		}	TLeafSet leafSet = fConsensusLeafSet;//	leafSet += leafSet.GetLeaves () + 1; do without outgroupleaf		fSplitSet.Sort (); // may not be necessary	fSplitSet.WriteToLogAsTable (leafSet, 0, true);		*Log << EOLN;		fTaxaBlock->WriteToLogAsList (leafSet);				// then make basic trees...and put in window!!!			// at later date add option for derivative trees		return (o);}void TDecayAnalysis::writeAsNexusNames (const TQuartet& quartet, TString& nexus) const{	const unsigned int leafA = quartet.GetLeafA ();	const unsigned int leafB = quartet.GetLeafB ();	const unsigned int leafC = quartet.GetLeafC ();	const unsigned int leafD = quartet.GetLeafD ();		TString leafNameA = fTaxaBlock->GetLeafName (leafA);	TString leafNameB = fTaxaBlock->GetLeafName (leafB);	TString leafNameC = fTaxaBlock->GetLeafName (leafC);	TString leafNameD;	if (leafD)		leafNameD = fTaxaBlock->GetLeafName (leafD);	else		leafNameD = fOutgroupLeaf;		CHECK_ (leafNameD != leafNameA);	CHECK_ (leafNameD != leafNameB);	CHECK_ (leafNameD != leafNameC);		QuartetType quartetType = quartet.GetQuartetType ().GetQuartetType ();		nexus = "(";	switch (quartetType)	{		case kZero:			nexus += leafNameA;			nexus += ",";			nexus += leafNameB;			nexus += ",";			nexus += leafNameC;			nexus += ",";			nexus += leafNameD;			break;		case kOne:			nexus += "((";			nexus += leafNameA;			nexus += ",";			nexus += leafNameB;			nexus += "),";			nexus += leafNameC;			nexus += "),";			nexus += leafNameD;			break;		case kTwo:			nexus += "((";			nexus += leafNameA;			nexus += ",";			nexus += leafNameC;			nexus += "),";			nexus += leafNameB;			nexus += "),";			nexus += leafNameD;			break;		case kThree:			nexus += "((";			nexus += leafNameB;			nexus += ",";			nexus += leafNameC;			nexus += "),";			nexus += leafNameA;			nexus += "),";			nexus += leafNameD;			break;	}	nexus += ");";}TDecayAnalysis::~TDecayAnalysis (void){	if (fLeafStability)	{		delete (fLeafStability);	}	if (fFuse)		delete (fFuse);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif