#include "TReducedConsensus.h"#include "TItemNumber.h"#include "DialogIDs.h"extern BOOL gAborted;#if PRAGMA_MARK_SUPPORTED#pragma mark -#endifvoid TStrictReducedConsensus::addTree (void){	if (!fTreesDone)	{		CHECK_ (fConsensusSplitSet->IsEmpty ());		getSplitSet (fCurSourceTree.GetRoot (), *fConsensusSplitSet); 	}	else	{		CHECK_ (fTreeSplitSet.IsEmpty ());		getSplitSet (fCurSourceTree.GetRoot (), fTreeSplitSet);				intersectSplits ();		swap (fConsensusSplitSet, fIntersectionSplitSet);		fIntersectionSplitSet->DeleteAll ();		fTreeSplitSet.DeleteAll ();	}}void TStrictReducedConsensus::intersectSplits (void){		CHECK_ (fIntersectionSplitSet->IsEmpty ());	CHECK_ (fIntermediateSplitSet.IsEmpty ());		const TSplit* consensusSplit; // JLT 010412 made const	TSplit* detachSplit; // JLT 010412 added	fConsensusSplitSet->FirstSplit ();	while (fConsensusSplitSet->CurSplit (consensusSplit))	{		if (consensusSplit->GetLeafSet () == fConsensusLeafSet) // could speed up by having arranged in order of size...simply from how input into splitsets		{			const TSplit* treeSplit; // JLT 010412 made const			for (bool b = fTreeSplitSet.FirstSplit (treeSplit); b; b = fTreeSplitSet.NextSplit (treeSplit))			{				if (*treeSplit == *consensusSplit)				{									fConsensusSplitSet->DetachCurSplit (detachSplit);					fIntersectionSplitSet->AddSplit (detachSplit, false);					consensusSplit = NULL;					fTreeSplitSet.DeleteCurSplit ();					break;				}			}		}		if (consensusSplit)			fConsensusSplitSet->NextSplit ();	}		fConsensusSplitSet->FirstSplit ();	while (fConsensusSplitSet->CurSplit (consensusSplit))	{		TSplitSet intermediateSplitSet (IsRooted ());		const TSplit* treeSplit; // JLT 010412 made const		TSplit intersectionSplit (IsRooted ());		TSplit intersectionSplitUnrooted (IsRooted ());		 		for (bool b = fTreeSplitSet.FirstSplit (treeSplit); b; b = fTreeSplitSet.NextSplit (treeSplit))		{			consensusSplit->Intersection (*treeSplit, intersectionSplit);			if (!IsRooted ())			{				treeSplit->Flip ();				consensusSplit->Intersection (*treeSplit, intersectionSplitUnrooted);						}			if (intersectionSplit == *consensusSplit)			{				fConsensusSplitSet->DetachCurSplit (detachSplit);				fIntersectionSplitSet->AddSplit (detachSplit, false);				consensusSplit = NULL;				break;			}			if (!IsRooted () && intersectionSplitUnrooted == *consensusSplit)			{				fConsensusSplitSet->DetachCurSplit (detachSplit);				fIntersectionSplitSet->AddSplit (detachSplit, false);				consensusSplit = NULL;				break;			}			if (intersectionSplit.IsInformative ())				intermediateSplitSet.AddSplit (intersectionSplit, true);			if (!IsRooted () && intersectionSplitUnrooted.IsInformative ())				intermediateSplitSet.AddSplit (intersectionSplitUnrooted, true);										}		if (consensusSplit)		{			intermediateSplitSet.FirstSplit ();			while (!intermediateSplitSet.IsEmpty ())			{				intermediateSplitSet.DetachCurSplit (detachSplit);				fIntermediateSplitSet.AddSplit (detachSplit, true);			}			fConsensusSplitSet->NextSplit ();		}								}		fIntermediateSplitSet.FirstSplit ();	while (!fIntermediateSplitSet.IsEmpty ())	{		fIntermediateSplitSet.DetachCurSplit (detachSplit);		if (fIntersectionSplitSet->IsSplitRedundant (*detachSplit))			delete (detachSplit);		else			fIntersectionSplitSet->AddSplit (detachSplit, false);	}							}void TStrictReducedConsensus::Consensus (void){	if (!fSourceTreesBlock->IsSplitSet ())	{		TIntersectionConsensus::Consensus ();		if (!gAborted)		{			fSourceTreesBlock->SetSplitSet (new TSplitSet (*fConsensusSplitSet));			fConsensusSplitSet = (TSplitSet*)fSourceTreesBlock->GetSplitSet (); // JLT 010412 		}	}	else	{		fConsensusSplitSet = (TSplitSet*)fSourceTreesBlock->GetSplitSet ();		fTreesDone = fSourceTrees;		fWeightsDone = fSourceWeights;	}	if (!gAborted && !fConsensusSplitSet->IsEmpty ())	{				MonitorDialog = TheApp->CreateMonitor (dlgProgressText);		MonitorDialog->SetItemText (3, "0");		MonitorDialog->SetItemText (4, "Making Basic Tree");		MonitorDialog->Show ();		makeBasicForest ();		//		if (!gAborted)//		{		//			MonitorDialog->SetItemText (3, "0");//			MonitorDialog->SetItemText (4, "Making Derivative Trees");//			//			makeDerivativeForest ();//		}		TheApp->DestroyDialog ();	}}void TStrictReducedConsensus::makeBasicForest (void){	CHECK_ (!fConsensusSplitSet->IsEmpty ());	CHECK_ (!fSplitItemSets);	CHECK_ (!fBasicTrees);	fConsensusSplitSet->Sort ();		fSplitItemSets = new TArray<TItemSet> (fConsensusSplitSet->GetSplits ());		TLeafSet leafSet;	const TSplit* splitPtr;	for (bool b = fConsensusSplitSet->FirstSplit (splitPtr); b; b = fConsensusSplitSet->NextSplit (splitPtr))	{		if (splitPtr->GetLeafSet () != leafSet)		{			MonitorDialog->ProcessExternal ();				if ((gAborted = MonitorDialog->HasAborted ()) != false)				return;												TString string;			string.AddToThis (++fBasicTrees);			MonitorDialog->SetItemText (3, string.Array ());				leafSet = splitPtr->GetLeafSet ();			const TSplit* splitPtr2;							TSplitSet splitSet (IsRooted ());			TSplitSetIteratorConst&	splitSetIterator = fConsensusSplitSet->IteratorConst ();			unsigned int i = 1;			for (splitSetIterator.FirstSplit (); splitSetIterator.CurSplit (splitPtr2); splitSetIterator.NextSplit (), ++i)			{				if (leafSet.IsSubset (splitPtr2->GetLeafSet ()))				{					TSplit split (*splitPtr2);					split.PruneLeaves (splitPtr2->GetLeafSet () - leafSet);					if (split.IsInformative ())					{						fSplitItemSets->IthItemRef (fBasicTrees) += i;						splitSet.AddSplit (split);					}				}			}			CHECK_ (IsRooted () ? fConsensusTree.IsRooted () : !fConsensusTree.IsRooted ());							fConsensusTree.StarTree (leafSet);			for (splitSet.FirstSplit (); splitSet.CurSplit (splitPtr2); splitSet.NextSplit ())				fConsensusTree.AddToThis (*splitPtr2);								TString name = "STRICT_REDUCED";			name.AddToThis (fBasicTrees);			name.AddToThis ("_BASIC");										fConsensusTree.SetName (name);			fConsensusTree.SetTreeType (kStrictCladistic);										fTreesBlock->AddTree (fConsensusTree);						TItemSet itemSet;			itemSet += fBasicTrees;			fTreeItemSets.IthItemRef (fBasicTrees) = itemSet;		}	}	CHECK_ (fTreeItemSets.GetItems () == fTreesBlock->GetTrees ());}bool TStrictReducedConsensus::getDerivativeSplitSet (TItemSet trees, TSplitSet& splitSet){	CHECK_ (IsRooted () ? splitSet.IsRooted () : !splitSet.IsRooted ());	CHECK_ (1 < trees.GetItems ());		if (!splitSet.IsEmpty ())			splitSet.DeleteAll ();		// determine the splits which in at least one of the trees being combined	TItemSet splits;	for (unsigned int i = trees.FirstItem (); i; i = trees.NextItem ())		splits += fSplitItemSets->IthItemRef (i);			TLeafSet leafSet;	// determine the leaves common to all the trees being combined	unsigned int item;	for (unsigned int i = 1; (item = trees.IthItem (i)) != 0; ++i)	{		const TLeafSet* leafSetPtr = NULL;		fTreesBlock->GetIthTreeLeafSet (item, leafSetPtr);		CHECK_ (leafSetPtr);				if (i == 1)			leafSet = *leafSetPtr;		else			leafSet *= *leafSetPtr;				// check that sufficient leaves for each tree to contribute at least one leaf		if (leafSet.GetLeaves () < trees.GetItems () + (IsRooted () ? 2 : 3))			return (false);	}		// produce the set of informative splits that occur in the trees and number by tree if unique to that tree else number as 0	const TSplit* splitPtr = NULL;	fConsensusSplitSet->FirstSplit (splitPtr);	for (unsigned int splitNumber = 1; splitNumber <= splits.LastItem (); ++splitNumber, fConsensusSplitSet->NextSplit (splitPtr))	{		CHECK_ (fConsensusSplitSet->CurSplit ());				if (splits.IsItem (splitNumber))		{			TSplit split (*splitPtr);			split.PruneLeaves (split.GetLeafSet () - leafSet); // to do why leaves not being pruned ??			CHECK_ (split.GetLeafSet () == leafSet);						if (split.IsInformative ())			{				if (splitSet.FindSplit (split, splitPtr))					splitPtr->SetNumber (0);				else				{					for (unsigned int treeNumber = trees.FirstItem (); treeNumber; treeNumber = trees.NextItem ())					{						if (fSplitItemSets->IthItemRef (treeNumber).IsItem (splitNumber))						{							if (split.GetNumber ())							{								split.SetNumber (0);								break;							}							else								split.SetNumber (treeNumber);													}					}						CHECK_ (splitSet.IsEqualLeafSets ());															splitSet.AddSplit (split, false);					CHECK_ (splitSet.IsEqualLeafSets ());				}			}		}	}		// as require one split that is unique to each tree	if (splitSet.GetSplits () < trees.GetItems ())		return (false);			// check that all the trees have contributed at least one unique split	for (bool b = splitSet.FirstSplit (splitPtr); b; b = splitSet.NextSplit (splitPtr))		if (splitPtr->GetNumber ())			trees -= splitPtr->GetNumber (); // can delete tree as contributed unique split		// only return tree if every tree has contributed a unique split	return (!trees.GetItems ());}bool TStrictReducedConsensus::isInProfile (const TItemSet& trees){	for (unsigned int i = 1; i <= fTreesBlock->GetTrees (); ++i)		if (fTreeItemSets.IthItemRef (i) == trees)			return (true);	return (false);}void TStrictReducedConsensus::makeDerivativeForest (void){		CHECK_ (GetNumberOfBasicTrees ());	CHECK_ (!GetNumberOfDerivativeTrees ());			// combine basic trees	for (unsigned int i1 = 1; i1 < GetNumberOfBasicTrees (); ++i1)	{		TItemSet trees;		trees += i1;		for (unsigned int i2 = i1 + 1; i2 <= GetNumberOfBasicTrees (); ++i2)		{			trees += i2;			TSplitSet splitSet (IsRooted ());			// have derivative tree			MonitorDialog->ProcessExternal ();				if ((gAborted = MonitorDialog->HasAborted ()) != false)				return;			if (getDerivativeSplitSet (trees, splitSet) && !isInProfile (trees))			{				TString string;				string.AddToThis (GetNumberOfDerivativeTrees () + 1);				MonitorDialog->SetItemText (3, string.Array ());				CHECK_ (splitSet.IsEqualLeafSets ());								fConsensusTree.StarTree (splitSet.GetLeafSet ());				const TSplit* splitPtr; // JLT 010412 made const				for (bool b = splitSet.FirstSplit (splitPtr); b; b = splitSet.NextSplit (splitPtr))					fConsensusTree.AddToThis (*splitPtr);										TString name = "STRICT_REDUCED";				name.AddToThis (fTreesBlock->GetTrees () + 1);				name.AddToThis ("_DERIVATIVE");												fConsensusTree.SetName (name);				fConsensusTree.SetTreeType (kStrictCladistic);											fTreesBlock->AddTree (fConsensusTree);								fTreeItemSets.IthItemRef (fTreesBlock->GetTrees ()) = trees;			}						}	}		// combine basic trees with the derivatives and add new derivatives at the end	for (unsigned int i1 = 1; i1 <= GetNumberOfBasicTrees (); ++i1)	{		TItemSet trees;		trees += i1;		for (unsigned int i2 = GetNumberOfBasicTrees () + 1; i2 <= fTreesBlock->GetTrees (); ++i2)		{			trees += fTreeItemSets.IthItemRef (i2);			TSplitSet splitSet (IsRooted ());			// have derivative tree			if (getDerivativeSplitSet (trees, splitSet))			{				CHECK_ (splitSet.IsEqualLeafSets ());								fConsensusTree.StarTree (splitSet.GetLeafSet ());				const TSplit* splitPtr; // JLT 010412 made const				for (bool b = splitSet.FirstSplit (splitPtr); b; b = splitSet.NextSplit (splitPtr))					fConsensusTree.AddToThis (*splitPtr);										TString name = "STRICT_REDUCED";				name.AddToThis (fTreesBlock->GetTrees () + 1);				name.AddToThis ("_DERIVATIVE");												fConsensusTree.SetName (name);				fConsensusTree.SetTreeType (kStrictCladistic);											fTreesBlock->AddTree (fConsensusTree);								fTreeItemSets.IthItemRef (fTreesBlock->GetTrees ()) = trees;			}						}	}}void TStrictReducedConsensus::getSplitSet (const TTreeNode* node, TSplitSet& splitSet){	if (node)	{		if (!node->IsLeaf () && !node->IsRoot ())			splitSet.AddSplit (new TSplit (*node, fCurSourceTree.GetLeafSet (), IsRooted ()));		getSplitSet (node->GetChild (), splitSet);		getSplitSet (node->GetSibling (), splitSet);	}}TStrictReducedConsensus::TStrictReducedConsensus (const TSourceTreesFile* sourceTreesFile) 	: 	TReducedConsensus (sourceTreesFile)	, 	fSplitSetA (sourceTreesFile->IsRooted ())	, 	fSplitSetB (sourceTreesFile->IsRooted ())	,	fTreeSplitSet (sourceTreesFile->IsRooted ())	,	fIntermediateSplitSet (sourceTreesFile->IsRooted ())	,	fTreeItemSets (0, 100){ 	fConsensusSplitSet = &fSplitSetA;	fIntersectionSplitSet = &fSplitSetB;	fSplitItemSets = NULL;	fBasicTrees = 0;}TStrictReducedConsensus::TStrictReducedConsensus (const TStrictReducedConsensus& strictReducedConsensus) 	: TReducedConsensus (strictReducedConsensus) 	, 	fSplitSetA (strictReducedConsensus.fSplitSetA)	, 	fSplitSetB (strictReducedConsensus.fSplitSetB)	,	fTreeSplitSet (strictReducedConsensus.fTreeSplitSet)	,	fIntermediateSplitSet (strictReducedConsensus.fIntermediateSplitSet)	,	fTreeItemSets (strictReducedConsensus.fTreeItemSets)	,	fBasicTrees (strictReducedConsensus.fBasicTrees){	if (strictReducedConsensus.fSplitItemSets)		*fSplitItemSets = *(strictReducedConsensus.fSplitItemSets);	else		fSplitItemSets = NULL;	CHECK_ (0); }TStrictReducedConsensus::~TStrictReducedConsensus (void) { 	if (fSplitItemSets)		delete (fSplitItemSets);}#if PRAGMA_MARK_SUPPORTED#pragma mark -#endif